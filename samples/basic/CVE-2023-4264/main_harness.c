#include <tbs.h>
// #include "tbs_internal.h"

bool bt_tbs_valid_uri(const char *uri, size_t len)
{
	bool ret;
	return ret;
}

// struct bt_tbs_call {
// 	uint8_t index;
// 	uint8_t state;
// 	uint8_t flags;
// 	char remote_uri[10];
// } __packed;

// Added these because they were defined in the c file
// struct service_inst {
// 	/* Attribute values */
// 	char provider_name[CONFIG_BT_TBS_MAX_PROVIDER_NAME_LENGTH];
// 	char uci[BT_TBS_MAX_UCI_SIZE];
// 	uint8_t technology;
// 	uint8_t signal_strength;
// 	uint8_t signal_strength_interval;
// 	uint8_t ccid;
// 	uint16_t optional_opcodes;
// 	uint16_t status_flags;
// 	struct bt_tbs_in_uri incoming_uri;
// 	struct bt_tbs_in_uri friendly_name;
// 	struct bt_tbs_in_uri in_call;

// 	bool notify_current_calls;
// 	bool notify_call_states;
// 	bool pending_signal_strength_notification;
// 	struct k_work_delayable reporting_interval_work;

// 	/** Service Attributes */
// 	const struct bt_gatt_attr *attrs;
// 	/** Service Attribute count */
// 	size_t attr_count;
// };

// struct tbs_service_inst {
// 	struct service_inst inst;

// 	/* Attribute values */
// 	char uri_scheme_list[CONFIG_BT_TBS_MAX_SCHEME_LIST_LENGTH];
// 	struct bt_tbs_terminate_reason terminate_reason;

// 	/* Instance values */
// 	struct bt_tbs_call calls[CONFIG_BT_TBS_MAX_CALLS];
// };

// struct gtbs_service_inst {
// 	struct service_inst inst;
// };

// // Provide the stubbed implementation
// struct bt_tbs_call *call_alloc(struct tbs_service_inst *inst, uint8_t state, const char *uri, uint16_t uri_len)
// {
// 	// You can return a mock object or NULL based on your test requirements
// 	struct bt_tbs_call *call = malloc(sizeof(struct bt_tbs_call));
// 	// call_alloc can return null, hence we should not restrict the returned pointer
// 	// __CPROVER_assume(call != NULL); // Assume a valid pointer or make it nondeterministic
// 	return call;
// }

void harness()
{
	uint8_t bearer_index;

	uint8_t buf_len;
	// We want to restrict the length of strings we havoc so we can fully unrol strlen
	__CPROVER_assume(buf_len > 0 && buf_len < 100);
	char *buf = malloc(buf_len);
	if (buf != NULL) {
		// Because character pointers are string, we need to make it a valid string
		buf[buf_len - 1] = '\0';
	}
	char *to = buf;

	uint8_t buf2_len;
	__CPROVER_assume(buf2_len > 0 && buf2_len < 100);
	char *buf2 = malloc(buf2_len);
	if (buf2 != NULL) {
		buf2[buf2_len - 1] = '\0';
	}
	
	char *from = buf2;
	// char *from = buf + buf_len;

	uint8_t friendly_name_len;
	__CPROVER_assume(friendly_name_len > 0 && friendly_name_len < 100);
	char *friendly_name = malloc(friendly_name_len);
	if (friendly_name != NULL) {
		friendly_name[friendly_name_len - 1] = '\0';
	}
	// __CPROVER_assume(friendly_name != NULL);

	int a = bt_tbs_remote_incoming(bearer_index, to, from, friendly_name);
}

int main(void)
{

	harness();
	return 0;
}
