diff --git a/subsys/net/lib/mqtt/mqtt_decoder.c b/subsys/net/lib/mqtt/mqtt_decoder.c
index 678546b2f11..dc280aab08c 100644
--- a/subsys/net/lib/mqtt/mqtt_decoder.c
+++ b/subsys/net/lib/mqtt/mqtt_decoder.c
@@ -130,8 +130,7 @@ static int unpack_utf8_str(struct buf_ctx *buf, struct mqtt_utf8 *str)
  * @retval 0 if the procedure is successful.
  * @retval -EINVAL if the buffer would be exceeded during the read
  */
-static int unpack_data(uint32_t length, struct buf_ctx *buf,
-		       struct mqtt_binstr *str)
+static int unpack_data(uint32_t length, struct buf_ctx *buf, struct mqtt_binstr *str)
 {
 	NET_DBG(">> cur:%p, end:%p", (void *)buf->cur, (void *)buf->end);
 
@@ -165,14 +164,14 @@ static int unpack_data(uint32_t length, struct buf_ctx *buf,
  * @retval -EINVAL if the length decoding would use more that 4 bytes.
  * @retval -EAGAIN if the buffer would be exceeded during the read.
  */
-static int packet_length_decode(struct buf_ctx *buf, uint32_t *length)
+int packet_length_decode(struct buf_ctx *buf, uint32_t *length)
 {
 	uint8_t shift = 0U;
 	uint8_t bytes = 0U;
 
 	*length = 0U;
 	do {
-		if (bytes >= MQTT_MAX_LENGTH_BYTES) {
+		if (bytes > MQTT_MAX_LENGTH_BYTES) {
 			return -EINVAL;
 		}
 
@@ -180,23 +179,21 @@ static int packet_length_decode(struct buf_ctx *buf, uint32_t *length)
 			return -EAGAIN;
 		}
 
-		*length += ((uint32_t)*(buf->cur) & MQTT_LENGTH_VALUE_MASK)
-								<< shift;
+		*length += ((uint32_t) * (buf->cur) & MQTT_LENGTH_VALUE_MASK) << shift;
 		shift += MQTT_LENGTH_SHIFT;
 		bytes++;
 	} while ((*(buf->cur++) & MQTT_LENGTH_CONTINUATION_BIT) != 0U);
 
-	if (*length > MQTT_MAX_PAYLOAD_SIZE) {
-		return -EINVAL;
-	}
+	// if (*length > MQTT_MAX_PAYLOAD_SIZE) {
+	// 	return -EINVAL;
+	// }
 
 	NET_DBG("length:0x%08x", *length);
 
 	return 0;
 }
 
-int fixed_header_decode(struct buf_ctx *buf, uint8_t *type_and_flags,
-			uint32_t *length)
+int fixed_header_decode(struct buf_ctx *buf, uint8_t *type_and_flags, uint32_t *length)
 {
 	int err_code;
 
@@ -225,11 +222,9 @@ int connect_ack_decode(const struct mqtt_client *client, struct buf_ctx *buf,
 	}
 
 	if (client->protocol_version == MQTT_VERSION_3_1_1) {
-		param->session_present_flag =
-			flags & MQTT_CONNACK_FLAG_SESSION_PRESENT;
+		param->session_present_flag = flags & MQTT_CONNACK_FLAG_SESSION_PRESENT;
 
-		NET_DBG("[CID %p]: session_present_flag: %d", client,
-			 param->session_present_flag);
+		NET_DBG("[CID %p]: session_present_flag: %d", client, param->session_present_flag);
 	}
 
 	param->return_code = (enum mqtt_conn_return_code)ret_code;
@@ -265,8 +260,8 @@ int publish_decode(uint8_t flags, uint32_t var_length, struct buf_ctx *buf,
 
 	if (var_length < var_header_length) {
 		NET_ERR("Corrupted PUBLISH message, header length (%u) larger "
-			 "than total length (%u)", var_header_length,
-			 var_length);
+			"than total length (%u)",
+			var_header_length, var_length);
 		return -EINVAL;
 	}
 
@@ -291,8 +286,7 @@ int publish_release_decode(struct buf_ctx *buf, struct mqtt_pubrel_param *param)
 	return unpack_uint16(buf, &param->message_id);
 }
 
-int publish_complete_decode(struct buf_ctx *buf,
-			    struct mqtt_pubcomp_param *param)
+int publish_complete_decode(struct buf_ctx *buf, struct mqtt_pubcomp_param *param)
 {
 	return unpack_uint16(buf, &param->message_id);
 }
@@ -309,8 +303,7 @@ int subscribe_ack_decode(struct buf_ctx *buf, struct mqtt_suback_param *param)
 	return unpack_data(buf->end - buf->cur, buf, &param->return_codes);
 }
 
-int unsubscribe_ack_decode(struct buf_ctx *buf,
-			   struct mqtt_unsuback_param *param)
+int unsubscribe_ack_decode(struct buf_ctx *buf, struct mqtt_unsuback_param *param)
 {
 	return unpack_uint16(buf, &param->message_id);
 }
