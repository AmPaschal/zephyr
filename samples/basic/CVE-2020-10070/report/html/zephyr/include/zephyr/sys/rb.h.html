
<html>
<head>
<title>zephyr/include/zephyr/sys/rb.h</title>
<link rel="stylesheet" type="text/css" href="../../../../viewer.css">
</head>

<body>
<div class="code">
<div id="1" class="line none">    1 /*</div><div id="2" class="line none">    2  * Copyright (c) 2018 Intel Corporation</div><div id="3" class="line none">    3  *</div><div id="4" class="line none">    4  * SPDX-License-Identifier: Apache-2.0</div><div id="5" class="line none">    5  */</div><div id="6" class="line none">    6 </div><div id="7" class="line none">    7 /**</div><div id="8" class="line none">    8  * @file</div><div id="9" class="line none">    9  * @defgroup rbtree_apis Balanced Red/Black Tree</div><div id="10" class="line none">   10  * @ingroup datastructure_apis</div><div id="11" class="line none">   11  *</div><div id="12" class="line none">   12  * @brief Balanced Red/Black Tree implementation</div><div id="13" class="line none">   13  *</div><div id="14" class="line none">   14  * This implements an intrusive balanced tree that guarantees</div><div id="15" class="line none">   15  * O(log2(N)) runtime for all operations and amortized O(1) behavior</div><div id="16" class="line none">   16  * for creation and destruction of whole trees. The algorithms and</div><div id="17" class="line none">   17  * naming are conventional per existing academic and didactic</div><div id="18" class="line none">   18  * implementations, c.f.:</div><div id="19" class="line none">   19  *</div><div id="20" class="line none">   20  * https://en.wikipedia.org/wiki/Red%E2%80%93black_tree</div><div id="21" class="line none">   21  *</div><div id="22" class="line none">   22  * The implementation is size-optimized to prioritize runtime memory</div><div id="23" class="line none">   23  * usage. The data structure is intrusive, which is to say the @ref</div><div id="24" class="line none">   24  * rbnode handle is intended to be placed in a separate struct, in the</div><div id="25" class="line none">   25  * same way as with other such structures (e.g. Zephyr's @ref</div><div id="26" class="line none">   26  * doubly-linked-list_apis), and requires no data pointer to be stored</div><div id="27" class="line none">   27  * in the node. The color bit is unioned with a pointer (fairly common</div><div id="28" class="line none">   28  * for such libraries). Most notably, there is no "parent" pointer</div><div id="29" class="line none">   29  * stored in the node, the upper structure of the tree being generated</div><div id="30" class="line none">   30  * dynamically via a stack as the tree is recursed. So the overall</div><div id="31" class="line none">   31  * memory overhead of a node is just two pointers, identical with a</div><div id="32" class="line none">   32  * doubly-linked list.</div><div id="33" class="line none">   33  *</div><div id="34" class="line none">   34  * @{</div><div id="35" class="line none">   35  */</div><div id="36" class="line none">   36 </div><div id="37" class="line none">   37 #ifndef <a href="rb.h.html#38">ZEPHYR_INCLUDE_SYS_RB_H_</a></div><div id="38" class="line none">   38 #define <a href="rb.h.html#38">ZEPHYR_INCLUDE_SYS_RB_H_</a></div><div id="39" class="line none">   39 </div><div id="40" class="line none">   40 #include &lt;stdbool.h&gt;</div><div id="41" class="line none">   41 #include &lt;stdint.h&gt;</div><div id="42" class="line none">   42 </div><div id="43" class="line none">   43 /* Our SDK/toolchains integration seems to be inconsistent about</div><div id="44" class="line none">   44  * whether they expose alloca.h or not.  On gcc it's a moot point as</div><div id="45" class="line none">   45  * it's always builtin.</div><div id="46" class="line none">   46  */</div><div id="47" class="line none">   47 #ifdef __GNUC__</div><div id="48" class="line none">   48 #ifndef <a href="../logging/log_msg.h.html#20">alloca</a></div><div id="49" class="line none">   49 #define <a href="../logging/log_msg.h.html#20">alloca</a> __builtin_alloca</div><div id="50" class="line none">   50 #endif</div><div id="51" class="line none">   51 #else</div><div id="52" class="line none">   52 #include &lt;<a href="../logging/log_msg.h.html#20">alloca</a>.h&gt;</div><div id="53" class="line none">   53 #endif</div><div id="54" class="line none">   54 </div><div id="55" class="line none">   55 /**</div><div id="56" class="line none">   56  * @brief Balanced red/black tree node structure</div><div id="57" class="line none">   57  */</div><div id="58" class="line none">   58 struct <a href="rb.h.html#58">rbnode</a> {</div><div id="59" class="line none">   59         /** @cond INTERNAL_HIDDEN */</div><div id="60" class="line none">   60         struct <a href="rb.h.html#58">rbnode</a> *<a href="rb.h.html#60">children</a>[2];</div><div id="61" class="line none">   61         /** @endcond */</div><div id="62" class="line none">   62 };</div><div id="63" class="line none">   63 </div><div id="64" class="line none">   64 /* Theoretical maximum depth of tree based on pointer size. If memory</div><div id="65" class="line none">   65  * is filled with 2-pointer nodes, and the tree can be twice as a</div><div id="66" class="line none">   66  * packed binary tree, plus root...  Works out to 59 entries for 32</div><div id="67" class="line none">   67  * bit pointers and 121 at 64 bits.</div><div id="68" class="line none">   68  */</div><div id="69" class="line none">   69 #define <a href="rb.h.html#69">Z_TBITS</a>(t) ((sizeof(t)) &lt; 8 ? 2 : 3)</div><div id="70" class="line none">   70 #define <a href="rb.h.html#70">Z_PBITS</a>(t) (8 * sizeof(t))</div><div id="71" class="line none">   71 #define <a href="rb.h.html#71">Z_MAX_RBTREE_DEPTH</a> (2 * (<a href="rb.h.html#70">Z_PBITS</a>(int *) - <a href="rb.h.html#69">Z_TBITS</a>(int *) - 1) + 1)</div><div id="72" class="line none">   72 </div><div id="73" class="line none">   73 /**</div><div id="74" class="line none">   74  * @typedef rb_lessthan_t</div><div id="75" class="line none">   75  * @brief Red/black tree comparison predicate</div><div id="76" class="line none">   76  *</div><div id="77" class="line none">   77  * Compares the two nodes and returns true if node A is strictly less</div><div id="78" class="line none">   78  * than B according to the tree's sorting criteria, false otherwise.</div><div id="79" class="line none">   79  *</div><div id="80" class="line none">   80  * Note that during insert, the new node being inserted will always be</div><div id="81" class="line none">   81  * "A", where "B" is the existing node within the tree against which</div><div id="82" class="line none">   82  * it is being compared.  This trait can be used (with care!) to</div><div id="83" class="line none">   83  * implement "most/least recently added" semantics between nodes which</div><div id="84" class="line none">   84  * would otherwise compare as equal.</div><div id="85" class="line none">   85  */</div><div id="86" class="line none">   86 typedef bool (*<a href="rb.h.html#86">rb_lessthan_t</a>)(struct <a href="rb.h.html#58">rbnode</a> *a, struct <a href="rb.h.html#58">rbnode</a> *b);</div><div id="87" class="line none">   87 </div><div id="88" class="line none">   88 /**</div><div id="89" class="line none">   89  * @brief Balanced red/black tree structure</div><div id="90" class="line none">   90  */</div><div id="91" class="line none">   91 struct <a href="rb.h.html#91">rbtree</a> {</div><div id="92" class="line none">   92         /** Root node of the tree */</div><div id="93" class="line none">   93         struct <a href="rb.h.html#58">rbnode</a> *<a href="rb.h.html#93">root</a>;</div><div id="94" class="line none">   94         /** Comparison function for nodes in the tree */</div><div id="95" class="line none">   95         <a href="rb.h.html#86">rb_lessthan_t</a> <a href="rb.h.html#95">lessthan_fn</a>;</div><div id="96" class="line none">   96         /** @cond INTERNAL_HIDDEN */</div><div id="97" class="line none">   97         int <a href="rb.h.html#97">max_depth</a>;</div><div id="98" class="line none">   98 #ifdef CONFIG_MISRA_SANE</div><div id="99" class="line none">   99         struct <a href="rb.h.html#58">rbnode</a> *<a href="rb.h.html#99">iter_stack</a>[<a href="rb.h.html#71">Z_MAX_RBTREE_DEPTH</a>];</div><div id="100" class="line none">  100         unsigned char <a href="rb.h.html#100">iter_left</a>[<a href="rb.h.html#71">Z_MAX_RBTREE_DEPTH</a>];</div><div id="101" class="line none">  101 #endif</div><div id="102" class="line none">  102         /** @endcond */</div><div id="103" class="line none">  103 };</div><div id="104" class="line none">  104 </div><div id="105" class="line none">  105 /**</div><div id="106" class="line none">  106  * @brief Prototype for node visitor callback.</div><div id="107" class="line none">  107  * @param node Node being visited</div><div id="108" class="line none">  108  * @param cookie User-specified data</div><div id="109" class="line none">  109  */</div><div id="110" class="line none">  110 typedef void (*<a href="rb.h.html#110">rb_visit_t</a>)(struct <a href="rb.h.html#58">rbnode</a> *<a href="../kernel.h.html#3883">node</a>, void *cookie);</div><div id="111" class="line none">  111 </div><div id="112" class="line none">  112 struct <a href="rb.h.html#58">rbnode</a> *z_rb_child(struct <a href="rb.h.html#58">rbnode</a> *<a href="../kernel.h.html#3883">node</a>, uint8_t side);</div><div id="113" class="line none">  113 int z_rb_is_black(struct <a href="rb.h.html#58">rbnode</a> *<a href="../kernel.h.html#3883">node</a>);</div><div id="114" class="line none">  114 #ifndef CONFIG_MISRA_SANE</div><div id="115" class="line none">  115 void z_rb_walk(struct <a href="rb.h.html#58">rbnode</a> *<a href="../kernel.h.html#3883">node</a>, <a href="rb.h.html#110">rb_visit_t</a> visit_fn, void *cookie);</div><div id="116" class="line none">  116 #endif</div><div id="117" class="line none">  117 struct <a href="rb.h.html#58">rbnode</a> *z_rb_get_minmax(struct <a href="rb.h.html#91">rbtree</a> *<a href="../kernel_structs.h.html#110">tree</a>, uint8_t side);</div><div id="118" class="line none">  118 </div><div id="119" class="line none">  119 /**</div><div id="120" class="line none">  120  * @brief Insert node into tree</div><div id="121" class="line none">  121  */</div><div id="122" class="line none">  122 void rb_insert(struct <a href="rb.h.html#91">rbtree</a> *<a href="../kernel_structs.h.html#110">tree</a>, struct <a href="rb.h.html#58">rbnode</a> *<a href="../kernel.h.html#3883">node</a>);</div><div id="123" class="line none">  123 </div><div id="124" class="line none">  124 /**</div><div id="125" class="line none">  125  * @brief Remove node from tree</div><div id="126" class="line none">  126  */</div><div id="127" class="line none">  127 void rb_remove(struct <a href="rb.h.html#91">rbtree</a> *<a href="../kernel_structs.h.html#110">tree</a>, struct <a href="rb.h.html#58">rbnode</a> *<a href="../kernel.h.html#3883">node</a>);</div><div id="128" class="line none">  128 </div><div id="129" class="line none">  129 /**</div><div id="130" class="line none">  130  * @brief Returns the lowest-sorted member of the tree</div><div id="131" class="line none">  131  */</div><div id="132" class="line none">  132 static inline struct <a href="rb.h.html#58">rbnode</a> *<a href="rb.h.html#132">rb_get_min</a>(struct <a href="rb.h.html#91">rbtree</a> *<a href="../kernel_structs.h.html#110">tree</a>)</div><div id="133" class="line none">  133 {</div><div id="134" class="line none">  134         return z_rb_get_minmax(<a href="../kernel_structs.h.html#110">tree</a>, 0U);</div><div id="135" class="line none">  135 }</div><div id="136" class="line none">  136 </div><div id="137" class="line none">  137 /**</div><div id="138" class="line none">  138  * @brief Returns the highest-sorted member of the tree</div><div id="139" class="line none">  139  */</div><div id="140" class="line none">  140 static inline struct <a href="rb.h.html#58">rbnode</a> *<a href="rb.h.html#140">rb_get_max</a>(struct <a href="rb.h.html#91">rbtree</a> *<a href="../kernel_structs.h.html#110">tree</a>)</div><div id="141" class="line none">  141 {</div><div id="142" class="line none">  142         return z_rb_get_minmax(<a href="../kernel_structs.h.html#110">tree</a>, 1U);</div><div id="143" class="line none">  143 }</div><div id="144" class="line none">  144 </div><div id="145" class="line none">  145 /**</div><div id="146" class="line none">  146  * @brief Returns true if the given node is part of the tree</div><div id="147" class="line none">  147  *</div><div id="148" class="line none">  148  * Note that this does not internally dereference the node pointer</div><div id="149" class="line none">  149  * (though the tree's lessthan callback might!), it just tests it for</div><div id="150" class="line none">  150  * equality with items in the tree.  So it's feasible to use this to</div><div id="151" class="line none">  151  * implement a "set" construct by simply testing the pointer value</div><div id="152" class="line none">  152  * itself.</div><div id="153" class="line none">  153  */</div><div id="154" class="line none">  154 bool rb_contains(struct <a href="rb.h.html#91">rbtree</a> *<a href="../kernel_structs.h.html#110">tree</a>, struct <a href="rb.h.html#58">rbnode</a> *<a href="../kernel.h.html#3883">node</a>);</div><div id="155" class="line none">  155 </div><div id="156" class="line none">  156 #ifndef CONFIG_MISRA_SANE</div><div id="157" class="line none">  157 /**</div><div id="158" class="line none">  158  * @brief Walk/enumerate a rbtree</div><div id="159" class="line none">  159  *</div><div id="160" class="line none">  160  * Very simple recursive enumeration.  Low code size, but requiring a</div><div id="161" class="line none">  161  * separate function can be clumsy for the user and there is no way to</div><div id="162" class="line none">  162  * break out of the loop early.  See RB_FOR_EACH for an iterative</div><div id="163" class="line none">  163  * implementation.</div><div id="164" class="line none">  164  */</div><div id="165" class="line none">  165 static inline void <a href="rb.h.html#165">rb_walk</a>(struct <a href="rb.h.html#91">rbtree</a> *<a href="../kernel_structs.h.html#110">tree</a>, <a href="rb.h.html#110">rb_visit_t</a> visit_fn,</div><div id="166" class="line none">  166                            void *cookie)</div><div id="167" class="line none">  167 {</div><div id="168" class="line none">  168         z_rb_walk(<a href="../kernel_structs.h.html#110">tree</a>-&gt;<a href="rb.h.html#93">root</a>, visit_fn, cookie);</div><div id="169" class="line none">  169 }</div><div id="170" class="line none">  170 #endif</div><div id="171" class="line none">  171 </div><div id="172" class="line none">  172 struct <a href="rb.h.html#172">_rb_foreach</a> {</div><div id="173" class="line none">  173         struct <a href="rb.h.html#58">rbnode</a> **<a href="rb.h.html#173">stack</a>;</div><div id="174" class="line none">  174         uint8_t *<a href="rb.h.html#174">is_left</a>;</div><div id="175" class="line none">  175         int32_t <a href="../kernel.h.html#2762">top</a>;</div><div id="176" class="line none">  176 };</div><div id="177" class="line none">  177 </div><div id="178" class="line none">  178 #ifdef CONFIG_MISRA_SANE</div><div id="179" class="line none">  179 #define <a href="rb.h.html#179">_RB_FOREACH_INIT</a>(<a href="../kernel_structs.h.html#110">tree</a>, <a href="../kernel.h.html#3883">node</a>) {                                  \</div><div id="180" class="line none">  180         .<a href="rb.h.html#173">stack</a>   = &amp;(<a href="../kernel_structs.h.html#110">tree</a>)-&gt;<a href="rb.h.html#99">iter_stack</a>[0],                              \</div><div id="181" class="line none">  181         .<a href="rb.h.html#174">is_left</a> = &amp;(<a href="../kernel_structs.h.html#110">tree</a>)-&gt;<a href="rb.h.html#100">iter_left</a>[0],                               \</div><div id="182" class="line none">  182         .<a href="../kernel.h.html#2762">top</a>     = -1                                                   \</div><div id="183" class="line none">  183 }</div><div id="184" class="line none">  184 #else</div><div id="185" class="line none">  185 #define <a href="rb.h.html#179">_RB_FOREACH_INIT</a>(<a href="../kernel_structs.h.html#110">tree</a>, <a href="../kernel.h.html#3883">node</a>) {                                  \</div><div id="186" class="line none">  186         .<a href="rb.h.html#173">stack</a>   = (struct <a href="rb.h.html#58">rbnode</a> **)                                   \</div><div id="187" class="line none">  187                         <a href="../logging/log_msg.h.html#20">alloca</a>((<a href="../kernel_structs.h.html#110">tree</a>)-&gt;<a href="rb.h.html#97">max_depth</a> * sizeof(struct <a href="rb.h.html#58">rbnode</a> *)), \</div><div id="188" class="line none">  188         .<a href="rb.h.html#174">is_left</a> = (uint8_t *)<a href="../logging/log_msg.h.html#20">alloca</a>((<a href="../kernel_structs.h.html#110">tree</a>)-&gt;<a href="rb.h.html#97">max_depth</a> * sizeof(uint8_t)),\</div><div id="189" class="line none">  189         .<a href="../kernel.h.html#2762">top</a>     = -1                                                   \</div><div id="190" class="line none">  190 }</div><div id="191" class="line none">  191 #endif</div><div id="192" class="line none">  192 </div><div id="193" class="line none">  193 struct <a href="rb.h.html#58">rbnode</a> *z_rb_foreach_next(struct <a href="rb.h.html#91">rbtree</a> *<a href="../kernel_structs.h.html#110">tree</a>, struct <a href="rb.h.html#172">_rb_foreach</a> *f);</div><div id="194" class="line none">  194 </div><div id="195" class="line none">  195 /**</div><div id="196" class="line none">  196  * @brief Walk a tree in-order without recursing</div><div id="197" class="line none">  197  *</div><div id="198" class="line none">  198  * While @ref rb_walk() is very simple, recursing on the C stack can</div><div id="199" class="line none">  199  * be clumsy for some purposes and on some architectures wastes</div><div id="200" class="line none">  200  * significant memory in stack frames.  This macro implements a</div><div id="201" class="line none">  201  * non-recursive "foreach" loop that can iterate directly on the tree,</div><div id="202" class="line none">  202  * at a moderate cost in code size.</div><div id="203" class="line none">  203  *</div><div id="204" class="line none">  204  * Note that the resulting loop is not safe against modifications to</div><div id="205" class="line none">  205  * the tree.  Changes to the tree structure during the loop will</div><div id="206" class="line none">  206  * produce incorrect results, as nodes may be skipped or duplicated.</div><div id="207" class="line none">  207  * Unlike linked lists, no _SAFE variant exists.</div><div id="208" class="line none">  208  *</div><div id="209" class="line none">  209  * Note also that the macro expands its arguments multiple times, so</div><div id="210" class="line none">  210  * they should not be expressions with side effects.</div><div id="211" class="line none">  211  *</div><div id="212" class="line none">  212  * @param tree A pointer to a struct rbtree to walk</div><div id="213" class="line none">  213  * @param node The symbol name of a local struct rbnode* variable to</div><div id="214" class="line none">  214  *             use as the iterator</div><div id="215" class="line none">  215  */</div><div id="216" class="line none">  216 #define <a href="rb.h.html#216">RB_FOR_EACH</a>(<a href="../kernel_structs.h.html#110">tree</a>, <a href="../kernel.h.html#3883">node</a>) \</div><div id="217" class="line none">  217         for (struct <a href="rb.h.html#172">_rb_foreach</a> __f = <a href="rb.h.html#179">_RB_FOREACH_INIT</a>(<a href="../kernel_structs.h.html#110">tree</a>, <a href="../kernel.h.html#3883">node</a>);     \</div><div id="218" class="line none">  218              ((<a href="../kernel.h.html#3883">node</a>) = z_rb_foreach_next((<a href="../kernel_structs.h.html#110">tree</a>), &amp;__f));                \</div><div id="219" class="line none">  219              /**/)</div><div id="220" class="line none">  220 </div><div id="221" class="line none">  221 /**</div><div id="222" class="line none">  222  * @brief Loop over rbtree with implicit container field logic</div><div id="223" class="line none">  223  *</div><div id="224" class="line none">  224  * As for RB_FOR_EACH(), but "node" can have an arbitrary type</div><div id="225" class="line none">  225  * containing a struct rbnode.</div><div id="226" class="line none">  226  *</div><div id="227" class="line none">  227  * @param tree A pointer to a struct rbtree to walk</div><div id="228" class="line none">  228  * @param node The symbol name of a local iterator</div><div id="229" class="line none">  229  * @param field The field name of a struct rbnode inside node</div><div id="230" class="line none">  230  */</div><div id="231" class="line none">  231 #define <a href="rb.h.html#231">RB_FOR_EACH_CONTAINER</a>(<a href="../kernel_structs.h.html#110">tree</a>, <a href="../kernel.h.html#3883">node</a>, field)                           \</div><div id="232" class="line none">  232         for (struct <a href="rb.h.html#172">_rb_foreach</a> __f = <a href="rb.h.html#179">_RB_FOREACH_INIT</a>(<a href="../kernel_structs.h.html#110">tree</a>, <a href="../kernel.h.html#3883">node</a>);        \</div><div id="233" class="line none">  233                         ({struct <a href="rb.h.html#58">rbnode</a> *n = z_rb_foreach_next(<a href="../kernel_structs.h.html#110">tree</a>, &amp;__f); \</div><div id="234" class="line none">  234                          (<a href="../kernel.h.html#3883">node</a>) = n ? CONTAINER_OF(n, __typeof__(*(<a href="../kernel.h.html#3883">node</a>)),   \</div><div id="235" class="line none">  235                                          field) : NULL; (<a href="../kernel.h.html#3883">node</a>); }) != NULL;        \</div><div id="236" class="line none">  236                          /**/)</div><div id="237" class="line none">  237 </div><div id="238" class="line none">  238 /** @} */</div><div id="239" class="line none">  239 </div><div id="240" class="line none">  240 #endif /* ZEPHYR_INCLUDE_SYS_RB_H_ */</div>
</div>
</body>
</html>
