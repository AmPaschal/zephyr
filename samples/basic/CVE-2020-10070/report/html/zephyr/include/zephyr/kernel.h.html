
<html>
<head>
<title>zephyr/include/zephyr/kernel.h</title>
<link rel="stylesheet" type="text/css" href="../../../viewer.css">
</head>

<body>
<div class="code">
<div id="1" class="line none">    1 /*</div><div id="2" class="line none">    2  * Copyright (c) 2016, Wind River Systems, Inc.</div><div id="3" class="line none">    3  *</div><div id="4" class="line none">    4  * SPDX-License-Identifier: Apache-2.0</div><div id="5" class="line none">    5  */</div><div id="6" class="line none">    6 </div><div id="7" class="line none">    7 /**</div><div id="8" class="line none">    8  * @file</div><div id="9" class="line none">    9  *</div><div id="10" class="line none">   10  * @brief Public kernel APIs.</div><div id="11" class="line none">   11  */</div><div id="12" class="line none">   12 </div><div id="13" class="line none">   13 #ifndef <a href="kernel.h.html#14">ZEPHYR_INCLUDE_KERNEL_H_</a></div><div id="14" class="line none">   14 #define <a href="kernel.h.html#14">ZEPHYR_INCLUDE_KERNEL_H_</a></div><div id="15" class="line none">   15 </div><div id="16" class="line none">   16 #if !defined(_ASMLANGUAGE)</div><div id="17" class="line none">   17 #include &lt;zephyr/kernel_includes.h&gt;</div><div id="18" class="line none">   18 #include &lt;errno.h&gt;</div><div id="19" class="line none">   19 #include &lt;limits.h&gt;</div><div id="20" class="line none">   20 #include &lt;stdbool.h&gt;</div><div id="21" class="line none">   21 #include &lt;zephyr/toolchain.h&gt;</div><div id="22" class="line none">   22 #include &lt;zephyr/tracing/tracing_macros.h&gt;</div><div id="23" class="line none">   23 #include &lt;zephyr/sys/mem_stats.h&gt;</div><div id="24" class="line none">   24 #include &lt;zephyr/sys/iterable_sections.h&gt;</div><div id="25" class="line none">   25 </div><div id="26" class="line none">   26 #ifdef __cplusplus</div><div id="27" class="line none">   27 extern "C" {</div><div id="28" class="line none">   28 #endif</div><div id="29" class="line none">   29 </div><div id="30" class="line none">   30 /*</div><div id="31" class="line none">   31  * Zephyr currently assumes the size of a couple standard types to simplify</div><div id="32" class="line none">   32  * print string formats. Let's make sure this doesn't change without notice.</div><div id="33" class="line none">   33  */</div><div id="34" class="line none">   34 BUILD_ASSERT(sizeof(int32_t) == sizeof(int));</div><div id="35" class="line none">   35 BUILD_ASSERT(sizeof(int64_t) == sizeof(long long));</div><div id="36" class="line none">   36 BUILD_ASSERT(sizeof(intptr_t) == sizeof(long));</div><div id="37" class="line none">   37 </div><div id="38" class="line none">   38 /**</div><div id="39" class="line none">   39  * @brief Kernel APIs</div><div id="40" class="line none">   40  * @defgroup kernel_apis Kernel APIs</div><div id="41" class="line none">   41  * @since 1.0</div><div id="42" class="line none">   42  * @version 1.0.0</div><div id="43" class="line none">   43  * @{</div><div id="44" class="line none">   44  * @}</div><div id="45" class="line none">   45  */</div><div id="46" class="line none">   46 </div><div id="47" class="line none">   47 #define <a href="kernel.h.html#47">K_ANY</a> NULL</div><div id="48" class="line none">   48 </div><div id="49" class="line none">   49 #if (CONFIG_NUM_COOP_PRIORITIES + CONFIG_NUM_PREEMPT_PRIORITIES) == 0</div><div id="50" class="line none">   50 #error Zero available <a href="kernel.h.html#4031">thread</a> priorities defined!</div><div id="51" class="line none">   51 #endif</div><div id="52" class="line none">   52 </div><div id="53" class="line none">   53 #define <a href="kernel.h.html#53">K_PRIO_COOP</a>(x) (-(CONFIG_NUM_COOP_PRIORITIES - (x)))</div><div id="54" class="line none">   54 #define <a href="kernel.h.html#54">K_PRIO_PREEMPT</a>(x) (x)</div><div id="55" class="line none">   55 </div><div id="56" class="line none">   56 #define <a href="kernel.h.html#56">K_HIGHEST_THREAD_PRIO</a> (-CONFIG_NUM_COOP_PRIORITIES)</div><div id="57" class="line none">   57 #define <a href="kernel.h.html#57">K_LOWEST_THREAD_PRIO</a> CONFIG_NUM_PREEMPT_PRIORITIES</div><div id="58" class="line none">   58 #define <a href="kernel.h.html#58">K_IDLE_PRIO</a> <a href="kernel.h.html#57">K_LOWEST_THREAD_PRIO</a></div><div id="59" class="line none">   59 #define <a href="kernel.h.html#59">K_HIGHEST_APPLICATION_THREAD_PRIO</a> (<a href="kernel.h.html#56">K_HIGHEST_THREAD_PRIO</a>)</div><div id="60" class="line none">   60 #define <a href="kernel.h.html#60">K_LOWEST_APPLICATION_THREAD_PRIO</a> (<a href="kernel.h.html#57">K_LOWEST_THREAD_PRIO</a> - 1)</div><div id="61" class="line none">   61 </div><div id="62" class="line none">   62 #ifdef CONFIG_POLL</div><div id="63" class="line none">   63 #define <a href="kernel.h.html#63">Z_POLL_EVENT_OBJ_INIT</a>(<a href="kernel.h.html#5739">obj</a>) \</div><div id="64" class="line none">   64         .<a href="kernel.h.html#5690">poll_events</a> = <a href="sys/dlist.h.html#211">SYS_DLIST_STATIC_INIT</a>(&amp;<a href="kernel.h.html#5739">obj</a>.<a href="kernel.h.html#5690">poll_events</a>),</div><div id="65" class="line none">   65 #define <a href="kernel.h.html#65">Z_DECL_POLL_EVENT</a> <a href="sys/dlist.h.html#50">sys_dlist_t</a> <a href="kernel.h.html#5690">poll_events</a>;</div><div id="66" class="line none">   66 #else</div><div id="67" class="line none">   67 #define <a href="kernel.h.html#63">Z_POLL_EVENT_OBJ_INIT</a>(<a href="kernel.h.html#5739">obj</a>)</div><div id="68" class="line none">   68 #define <a href="kernel.h.html#65">Z_DECL_POLL_EVENT</a></div><div id="69" class="line none">   69 #endif</div><div id="70" class="line none">   70 </div><div id="71" class="line none">   71 struct <a href="arch/arch_interface.h.html#43">k_thread</a>;</div><div id="72" class="line none">   72 struct <a href="sys/kobject.h.html#20">k_mutex</a>;</div><div id="73" class="line none">   73 struct <a href="kernel.h.html#3111">k_sem</a>;</div><div id="74" class="line none">   74 struct <a href="kernel.h.html#4423">k_msgq</a>;</div><div id="75" class="line none">   75 struct <a href="kernel.h.html#4736">k_mbox</a>;</div><div id="76" class="line none">   76 struct <a href="kernel.h.html#4867">k_pipe</a>;</div><div id="77" class="line none">   77 struct <a href="kernel.h.html#1850">k_queue</a>;</div><div id="78" class="line none">   78 struct <a href="kernel.h.html#2388">k_fifo</a>;</div><div id="79" class="line none">   79 struct <a href="kernel.h.html#2627">k_lifo</a>;</div><div id="80" class="line none">   80 struct <a href="kernel.h.html#2759">k_stack</a>;</div><div id="81" class="line none">   81 struct <a href="kernel.h.html#5083">k_mem_slab</a>;</div><div id="82" class="line none">   82 struct <a href="kernel.h.html#1446">k_timer</a>;</div><div id="83" class="line none">   83 struct <a href="kernel.h.html#5712">k_poll_event</a>;</div><div id="84" class="line none">   84 struct <a href="kernel.h.html#5688">k_poll_signal</a>;</div><div id="85" class="line none">   85 struct k_mem_domain;</div><div id="86" class="line none">   86 struct k_mem_partition;</div><div id="87" class="line none">   87 struct <a href="kernel.h.html#2142">k_futex</a>;</div><div id="88" class="line none">   88 struct <a href="kernel.h.html#2221">k_event</a>;</div><div id="89" class="line none">   89 </div><div id="90" class="line none">   90 enum <a href="kernel.h.html#90">execution_context_types</a> {</div><div id="91" class="line none">   91         <a href="kernel.h.html#91">K_ISR</a> = 0,</div><div id="92" class="line none">   92         <a href="kernel.h.html#92">K_COOP_THREAD</a>,</div><div id="93" class="line none">   93         <a href="kernel.h.html#93">K_PREEMPT_THREAD</a>,</div><div id="94" class="line none">   94 };</div><div id="95" class="line none">   95 </div><div id="96" class="line none">   96 /* private, used by k_poll and k_work_poll */</div><div id="97" class="line none">   97 struct <a href="kernel.h.html#4274">k_work_poll</a>;</div><div id="98" class="line none">   98 typedef int (*<a href="kernel.h.html#98">_poller_cb_t</a>)(struct <a href="kernel.h.html#5712">k_poll_event</a> *event, uint32_t <a href="kernel.h.html#5726">state</a>);</div><div id="99" class="line none">   99 </div><div id="100" class="line none">  100 /**</div><div id="101" class="line none">  101  * @addtogroup thread_apis</div><div id="102" class="line none">  102  * @{</div><div id="103" class="line none">  103  */</div><div id="104" class="line none">  104 </div><div id="105" class="line none">  105 typedef void (*<a href="kernel.h.html#105">k_thread_user_cb_t</a>)(const struct <a href="arch/arch_interface.h.html#43">k_thread</a> *<a href="kernel.h.html#4031">thread</a>,</div><div id="106" class="line none">  106                                    void *<a href="kernel.h.html#1470">user_data</a>);</div><div id="107" class="line none">  107 </div><div id="108" class="line none">  108 /**</div><div id="109" class="line none">  109  * @brief Iterate over all the threads in the system.</div><div id="110" class="line none">  110  *</div><div id="111" class="line none">  111  * This routine iterates over all the threads in the system and</div><div id="112" class="line none">  112  * calls the user_cb function for each thread.</div><div id="113" class="line none">  113  *</div><div id="114" class="line none">  114  * @param user_cb Pointer to the user callback function.</div><div id="115" class="line none">  115  * @param user_data Pointer to user data.</div><div id="116" class="line none">  116  *</div><div id="117" class="line none">  117  * @note @kconfig{CONFIG_THREAD_MONITOR} must be set for this function</div><div id="118" class="line none">  118  * to be effective.</div><div id="119" class="line none">  119  * @note This API uses @ref k_spin_lock to protect the _kernel.threads</div><div id="120" class="line none">  120  * list which means creation of new threads and terminations of existing</div><div id="121" class="line none">  121  * threads are blocked until this API returns.</div><div id="122" class="line none">  122  */</div><div id="123" class="line none">  123 void k_thread_foreach(<a href="kernel.h.html#105">k_thread_user_cb_t</a> user_cb, void *<a href="kernel.h.html#1470">user_data</a>);</div><div id="124" class="line none">  124 </div><div id="125" class="line none">  125 /**</div><div id="126" class="line none">  126  * @brief Iterate over all the threads in the system without locking.</div><div id="127" class="line none">  127  *</div><div id="128" class="line none">  128  * This routine works exactly the same like @ref k_thread_foreach</div><div id="129" class="line none">  129  * but unlocks interrupts when user_cb is executed.</div><div id="130" class="line none">  130  *</div><div id="131" class="line none">  131  * @param user_cb Pointer to the user callback function.</div><div id="132" class="line none">  132  * @param user_data Pointer to user data.</div><div id="133" class="line none">  133  *</div><div id="134" class="line none">  134  * @note @kconfig{CONFIG_THREAD_MONITOR} must be set for this function</div><div id="135" class="line none">  135  * to be effective.</div><div id="136" class="line none">  136  * @note This API uses @ref k_spin_lock only when accessing the _kernel.threads</div><div id="137" class="line none">  137  * queue elements. It unlocks it during user callback function processing.</div><div id="138" class="line none">  138  * If a new task is created when this @c foreach function is in progress,</div><div id="139" class="line none">  139  * the added new task would not be included in the enumeration.</div><div id="140" class="line none">  140  * If a task is aborted during this enumeration, there would be a race here</div><div id="141" class="line none">  141  * and there is a possibility that this aborted task would be included in the</div><div id="142" class="line none">  142  * enumeration.</div><div id="143" class="line none">  143  * @note If the task is aborted and the memory occupied by its @c k_thread</div><div id="144" class="line none">  144  * structure is reused when this @c k_thread_foreach_unlocked is in progress</div><div id="145" class="line none">  145  * it might even lead to the system behave unstable.</div><div id="146" class="line none">  146  * This function may never return, as it would follow some @c next task</div><div id="147" class="line none">  147  * pointers treating given pointer as a pointer to the k_thread structure</div><div id="148" class="line none">  148  * while it is something different right now.</div><div id="149" class="line none">  149  * Do not reuse the memory that was occupied by k_thread structure of aborted</div><div id="150" class="line none">  150  * task if it was aborted after this function was called in any context.</div><div id="151" class="line none">  151  */</div><div id="152" class="line none">  152 void k_thread_foreach_unlocked(</div><div id="153" class="line none">  153         <a href="kernel.h.html#105">k_thread_user_cb_t</a> user_cb, void *<a href="kernel.h.html#1470">user_data</a>);</div><div id="154" class="line none">  154 </div><div id="155" class="line none">  155 /** @} */</div><div id="156" class="line none">  156 </div><div id="157" class="line none">  157 /**</div><div id="158" class="line none">  158  * @defgroup thread_apis Thread APIs</div><div id="159" class="line none">  159  * @ingroup kernel_apis</div><div id="160" class="line none">  160  * @{</div><div id="161" class="line none">  161  */</div><div id="162" class="line none">  162 </div><div id="163" class="line none">  163 #endif /* !_ASMLANGUAGE */</div><div id="164" class="line none">  164 </div><div id="165" class="line none">  165 </div><div id="166" class="line none">  166 /*</div><div id="167" class="line none">  167  * Thread user options. May be needed by assembly code. Common part uses low</div><div id="168" class="line none">  168  * bits, arch-specific use high bits.</div><div id="169" class="line none">  169  */</div><div id="170" class="line none">  170 </div><div id="171" class="line none">  171 /**</div><div id="172" class="line none">  172  * @brief system thread that must not abort</div><div id="173" class="line none">  173  * */</div><div id="174" class="line none">  174 #define <a href="kernel.h.html#174">K_ESSENTIAL</a> (BIT(0))</div><div id="175" class="line none">  175 </div><div id="176" class="line none">  176 /**</div><div id="177" class="line none">  177  * @brief FPU registers are managed by context switch</div><div id="178" class="line none">  178  *</div><div id="179" class="line none">  179  * @details</div><div id="180" class="line none">  180  * This option indicates that the thread uses the CPU's floating point</div><div id="181" class="line none">  181  * registers. This instructs the kernel to take additional steps to save</div><div id="182" class="line none">  182  * and restore the contents of these registers when scheduling the thread.</div><div id="183" class="line none">  183  * No effect if @kconfig{CONFIG_FPU_SHARING} is not enabled.</div><div id="184" class="line none">  184  */</div><div id="185" class="line none">  185 #define <a href="kernel.h.html#185">K_FP_IDX</a> 1</div><div id="186" class="line none">  186 #define <a href="kernel.h.html#186">K_FP_REGS</a> (BIT(<a href="kernel.h.html#185">K_FP_IDX</a>))</div><div id="187" class="line none">  187 </div><div id="188" class="line none">  188 /**</div><div id="189" class="line none">  189  * @brief user mode thread</div><div id="190" class="line none">  190  *</div><div id="191" class="line none">  191  * This thread has dropped from supervisor mode to user mode and consequently</div><div id="192" class="line none">  192  * has additional restrictions</div><div id="193" class="line none">  193  */</div><div id="194" class="line none">  194 #define <a href="kernel.h.html#194">K_USER</a> (BIT(2))</div><div id="195" class="line none">  195 </div><div id="196" class="line none">  196 /**</div><div id="197" class="line none">  197  * @brief Inherit Permissions</div><div id="198" class="line none">  198  *</div><div id="199" class="line none">  199  * @details</div><div id="200" class="line none">  200  * Indicates that the thread being created should inherit all kernel object</div><div id="201" class="line none">  201  * permissions from the thread that created it. No effect if</div><div id="202" class="line none">  202  * @kconfig{CONFIG_USERSPACE} is not enabled.</div><div id="203" class="line none">  203  */</div><div id="204" class="line none">  204 #define <a href="kernel.h.html#204">K_INHERIT_PERMS</a> (BIT(3))</div><div id="205" class="line none">  205 </div><div id="206" class="line none">  206 /**</div><div id="207" class="line none">  207  * @brief Callback item state</div><div id="208" class="line none">  208  *</div><div id="209" class="line none">  209  * @details</div><div id="210" class="line none">  210  * This is a single bit of state reserved for "callback manager"</div><div id="211" class="line none">  211  * utilities (p4wq initially) who need to track operations invoked</div><div id="212" class="line none">  212  * from within a user-provided callback they have been invoked.</div><div id="213" class="line none">  213  * Effectively it serves as a tiny bit of zero-overhead TLS data.</div><div id="214" class="line none">  214  */</div><div id="215" class="line none">  215 #define <a href="kernel.h.html#215">K_CALLBACK_STATE</a> (BIT(4))</div><div id="216" class="line none">  216 </div><div id="217" class="line none">  217 /**</div><div id="218" class="line none">  218  * @brief DSP registers are managed by context switch</div><div id="219" class="line none">  219  *</div><div id="220" class="line none">  220  * @details</div><div id="221" class="line none">  221  * This option indicates that the thread uses the CPU's DSP registers.</div><div id="222" class="line none">  222  * This instructs the kernel to take additional steps to save and</div><div id="223" class="line none">  223  * restore the contents of these registers when scheduling the thread.</div><div id="224" class="line none">  224  * No effect if @kconfig{CONFIG_DSP_SHARING} is not enabled.</div><div id="225" class="line none">  225  */</div><div id="226" class="line none">  226 #define <a href="kernel.h.html#226">K_DSP_IDX</a> 6</div><div id="227" class="line none">  227 #define <a href="kernel.h.html#227">K_DSP_REGS</a> (BIT(<a href="kernel.h.html#226">K_DSP_IDX</a>))</div><div id="228" class="line none">  228 </div><div id="229" class="line none">  229 /**</div><div id="230" class="line none">  230  * @brief AGU registers are managed by context switch</div><div id="231" class="line none">  231  *</div><div id="232" class="line none">  232  * @details</div><div id="233" class="line none">  233  * This option indicates that the thread uses the ARC processor's XY</div><div id="234" class="line none">  234  * memory and DSP feature. Often used with @kconfig{CONFIG_ARC_AGU_SHARING}.</div><div id="235" class="line none">  235  * No effect if @kconfig{CONFIG_ARC_AGU_SHARING} is not enabled.</div><div id="236" class="line none">  236  */</div><div id="237" class="line none">  237 #define <a href="kernel.h.html#237">K_AGU_IDX</a> 7</div><div id="238" class="line none">  238 #define <a href="kernel.h.html#238">K_AGU_REGS</a> (BIT(<a href="kernel.h.html#237">K_AGU_IDX</a>))</div><div id="239" class="line none">  239 </div><div id="240" class="line none">  240 /**</div><div id="241" class="line none">  241  * @brief FP and SSE registers are managed by context switch on x86</div><div id="242" class="line none">  242  *</div><div id="243" class="line none">  243  * @details</div><div id="244" class="line none">  244  * This option indicates that the thread uses the x86 CPU's floating point</div><div id="245" class="line none">  245  * and SSE registers. This instructs the kernel to take additional steps to</div><div id="246" class="line none">  246  * save and restore the contents of these registers when scheduling</div><div id="247" class="line none">  247  * the thread. No effect if @kconfig{CONFIG_X86_SSE} is not enabled.</div><div id="248" class="line none">  248  */</div><div id="249" class="line none">  249 #define <a href="kernel.h.html#249">K_SSE_REGS</a> (BIT(7))</div><div id="250" class="line none">  250 </div><div id="251" class="line none">  251 /* end - thread options */</div><div id="252" class="line none">  252 </div><div id="253" class="line none">  253 #if !defined(_ASMLANGUAGE)</div><div id="254" class="line none">  254 /**</div><div id="255" class="line none">  255  * @brief Dynamically allocate a thread stack.</div><div id="256" class="line none">  256  *</div><div id="257" class="line none">  257  * Relevant stack creation flags include:</div><div id="258" class="line none">  258  * - @ref K_USER allocate a userspace thread (requires `CONFIG_USERSPACE=y`)</div><div id="259" class="line none">  259  *</div><div id="260" class="line none">  260  * @param size Stack size in bytes.</div><div id="261" class="line none">  261  * @param flags Stack creation flags, or 0.</div><div id="262" class="line none">  262  *</div><div id="263" class="line none">  263  * @retval the allocated thread stack on success.</div><div id="264" class="line none">  264  * @retval NULL on failure.</div><div id="265" class="line none">  265  *</div><div id="266" class="line none">  266  * @see CONFIG_DYNAMIC_THREAD</div><div id="267" class="line none">  267  */</div><div id="268" class="line none">  268 __syscall <a href="arch/arch_interface.h.html#46">k_thread_stack_t</a> *k_thread_stack_alloc(size_t <a href="kernel.h.html#4716">size</a>, int <a href="kernel.h.html#2764">flags</a>);</div><div id="269" class="line none">  269 </div><div id="270" class="line none">  270 /**</div><div id="271" class="line none">  271  * @brief Free a dynamically allocated thread stack.</div><div id="272" class="line none">  272  *</div><div id="273" class="line none">  273  * @param stack Pointer to the thread stack.</div><div id="274" class="line none">  274  *</div><div id="275" class="line none">  275  * @retval 0 on success.</div><div id="276" class="line none">  276  * @retval -EBUSY if the thread stack is in use.</div><div id="277" class="line none">  277  * @retval -EINVAL if @p stack is invalid.</div><div id="278" class="line none">  278  * @retval -ENOSYS if dynamic thread stack allocation is disabled</div><div id="279" class="line none">  279  *</div><div id="280" class="line none">  280  * @see CONFIG_DYNAMIC_THREAD</div><div id="281" class="line none">  281  */</div><div id="282" class="line none">  282 __syscall int k_thread_stack_free(<a href="arch/arch_interface.h.html#46">k_thread_stack_t</a> *<a href="sys/rb.h.html#173">stack</a>);</div><div id="283" class="line none">  283 </div><div id="284" class="line none">  284 /**</div><div id="285" class="line none">  285  * @brief Create a thread.</div><div id="286" class="line none">  286  *</div><div id="287" class="line none">  287  * This routine initializes a thread, then schedules it for execution.</div><div id="288" class="line none">  288  *</div><div id="289" class="line none">  289  * The new thread may be scheduled for immediate execution or a delayed start.</div><div id="290" class="line none">  290  * If the newly spawned thread does not have a delayed start the kernel</div><div id="291" class="line none">  291  * scheduler may preempt the current thread to allow the new thread to</div><div id="292" class="line none">  292  * execute.</div><div id="293" class="line none">  293  *</div><div id="294" class="line none">  294  * Thread options are architecture-specific, and can include K_ESSENTIAL,</div><div id="295" class="line none">  295  * K_FP_REGS, and K_SSE_REGS. Multiple options may be specified by separating</div><div id="296" class="line none">  296  * them using "|" (the logical OR operator).</div><div id="297" class="line none">  297  *</div><div id="298" class="line none">  298  * Stack objects passed to this function must be originally defined with</div><div id="299" class="line none">  299  * either of these macros in order to be portable:</div><div id="300" class="line none">  300  *</div><div id="301" class="line none">  301  * - K_THREAD_STACK_DEFINE() - For stacks that may support either user or</div><div id="302" class="line none">  302  *   supervisor threads.</div><div id="303" class="line none">  303  * - K_KERNEL_STACK_DEFINE() - For stacks that may support supervisor</div><div id="304" class="line none">  304  *   threads only. These stacks use less memory if CONFIG_USERSPACE is</div><div id="305" class="line none">  305  *   enabled.</div><div id="306" class="line none">  306  *</div><div id="307" class="line none">  307  * The stack_size parameter has constraints. It must either be:</div><div id="308" class="line none">  308  *</div><div id="309" class="line none">  309  * - The original size value passed to K_THREAD_STACK_DEFINE() or</div><div id="310" class="line none">  310  *   K_KERNEL_STACK_DEFINE()</div><div id="311" class="line none">  311  * - The return value of K_THREAD_STACK_SIZEOF(stack) if the stack was</div><div id="312" class="line none">  312  *   defined with K_THREAD_STACK_DEFINE()</div><div id="313" class="line none">  313  * - The return value of K_KERNEL_STACK_SIZEOF(stack) if the stack was</div><div id="314" class="line none">  314  *   defined with K_KERNEL_STACK_DEFINE().</div><div id="315" class="line none">  315  *</div><div id="316" class="line none">  316  * Using other values, or sizeof(stack) may produce undefined behavior.</div><div id="317" class="line none">  317  *</div><div id="318" class="line none">  318  * @param new_thread Pointer to uninitialized struct k_thread</div><div id="319" class="line none">  319  * @param stack Pointer to the stack space.</div><div id="320" class="line none">  320  * @param stack_size Stack size in bytes.</div><div id="321" class="line none">  321  * @param entry Thread entry function.</div><div id="322" class="line none">  322  * @param p1 1st entry point parameter.</div><div id="323" class="line none">  323  * @param p2 2nd entry point parameter.</div><div id="324" class="line none">  324  * @param p3 3rd entry point parameter.</div><div id="325" class="line none">  325  * @param prio Thread priority.</div><div id="326" class="line none">  326  * @param options Thread options.</div><div id="327" class="line none">  327  * @param delay Scheduling delay, or K_NO_WAIT (for no delay).</div><div id="328" class="line none">  328  *</div><div id="329" class="line none">  329  * @return ID of new thread.</div><div id="330" class="line none">  330  *</div><div id="331" class="line none">  331  */</div><div id="332" class="line none">  332 __syscall <a href="kernel/thread.h.html#380">k_tid_t</a> k_thread_create(struct <a href="arch/arch_interface.h.html#43">k_thread</a> *new_thread,</div><div id="333" class="line none">  333                                   <a href="arch/arch_interface.h.html#46">k_thread_stack_t</a> *<a href="sys/rb.h.html#173">stack</a>,</div><div id="334" class="line none">  334                                   size_t stack_size,</div><div id="335" class="line none">  335                                   <a href="arch/arch_interface.h.html#48">k_thread_entry_t</a> <a href="kernel/thread.h.html#288">entry</a>,</div><div id="336" class="line none">  336                                   void *p1, void *p2, void *p3,</div><div id="337" class="line none">  337                                   int <a href="kernel/thread.h.html#95">prio</a>, uint32_t options, k_timeout_t delay);</div><div id="338" class="line none">  338 </div><div id="339" class="line none">  339 /**</div><div id="340" class="line none">  340  * @brief Drop a thread's privileges permanently to user mode</div><div id="341" class="line none">  341  *</div><div id="342" class="line none">  342  * This allows a supervisor thread to be re-used as a user thread.</div><div id="343" class="line none">  343  * This function does not return, but control will transfer to the provided</div><div id="344" class="line none">  344  * entry point as if this was a new user thread.</div><div id="345" class="line none">  345  *</div><div id="346" class="line none">  346  * The implementation ensures that the stack buffer contents are erased.</div><div id="347" class="line none">  347  * Any thread-local storage will be reverted to a pristine state.</div><div id="348" class="line none">  348  *</div><div id="349" class="line none">  349  * Memory domain membership, resource pool assignment, kernel object</div><div id="350" class="line none">  350  * permissions, priority, and thread options are preserved.</div><div id="351" class="line none">  351  *</div><div id="352" class="line none">  352  * A common use of this function is to re-use the main thread as a user thread</div><div id="353" class="line none">  353  * once all supervisor mode-only tasks have been completed.</div><div id="354" class="line none">  354  *</div><div id="355" class="line none">  355  * @param entry Function to start executing from</div><div id="356" class="line none">  356  * @param p1 1st entry point parameter</div><div id="357" class="line none">  357  * @param p2 2nd entry point parameter</div><div id="358" class="line none">  358  * @param p3 3rd entry point parameter</div><div id="359" class="line none">  359  */</div><div id="360" class="line none">  360 FUNC_NORETURN void k_thread_user_mode_enter(<a href="arch/arch_interface.h.html#48">k_thread_entry_t</a> <a href="kernel/thread.h.html#288">entry</a>,</div><div id="361" class="line none">  361                                                    void *p1, void *p2,</div><div id="362" class="line none">  362                                                    void *p3);</div><div id="363" class="line none">  363 </div><div id="364" class="line none">  364 /**</div><div id="365" class="line none">  365  * @brief Grant a thread access to a set of kernel objects</div><div id="366" class="line none">  366  *</div><div id="367" class="line none">  367  * This is a convenience function. For the provided thread, grant access to</div><div id="368" class="line none">  368  * the remaining arguments, which must be pointers to kernel objects.</div><div id="369" class="line none">  369  *</div><div id="370" class="line none">  370  * The thread object must be initialized (i.e. running). The objects don't</div><div id="371" class="line none">  371  * need to be.</div><div id="372" class="line none">  372  * Note that NULL shouldn't be passed as an argument.</div><div id="373" class="line none">  373  *</div><div id="374" class="line none">  374  * @param thread Thread to grant access to objects</div><div id="375" class="line none">  375  * @param ... list of kernel object pointers</div><div id="376" class="line none">  376  */</div><div id="377" class="line none">  377 #define <a href="kernel.h.html#377">k_thread_access_grant</a>(<a href="kernel.h.html#4031">thread</a>, ...) \</div><div id="378" class="line none">  378         FOR_EACH_FIXED_ARG(k_object_access_grant, (;), (<a href="kernel.h.html#4031">thread</a>), __VA_ARGS__)</div><div id="379" class="line none">  379 </div><div id="380" class="line none">  380 /**</div><div id="381" class="line none">  381  * @brief Assign a resource memory pool to a thread</div><div id="382" class="line none">  382  *</div><div id="383" class="line none">  383  * By default, threads have no resource pool assigned unless their parent</div><div id="384" class="line none">  384  * thread has a resource pool, in which case it is inherited. Multiple</div><div id="385" class="line none">  385  * threads may be assigned to the same memory pool.</div><div id="386" class="line none">  386  *</div><div id="387" class="line none">  387  * Changing a thread's resource pool will not migrate allocations from the</div><div id="388" class="line none">  388  * previous pool.</div><div id="389" class="line none">  389  *</div><div id="390" class="line none">  390  * @param thread Target thread to assign a memory pool for resource requests.</div><div id="391" class="line none">  391  * @param heap Heap object to use for resources,</div><div id="392" class="line none">  392  *             or NULL if the thread should no longer have a memory pool.</div><div id="393" class="line none">  393  */</div><div id="394" class="line none">  394 static inline void <a href="kernel.h.html#394">k_thread_heap_assign</a>(struct <a href="arch/arch_interface.h.html#43">k_thread</a> *<a href="kernel.h.html#4031">thread</a>,</div><div id="395" class="line none">  395                                         struct <a href="kernel/thread.h.html#349">k_heap</a> *<a href="kernel.h.html#5318">heap</a>)</div><div id="396" class="line none">  396 {</div><div id="397" class="line none">  397         <a href="kernel.h.html#4031">thread</a>-&gt;<a href="kernel/thread.h.html#349">resource_pool</a> = <a href="kernel.h.html#5318">heap</a>;</div><div id="398" class="line none">  398 }</div><div id="399" class="line none">  399 </div><div id="400" class="line none">  400 #if defined(CONFIG_INIT_STACKS) &amp;&amp; defined(CONFIG_THREAD_STACK_INFO)</div><div id="401" class="line none">  401 /**</div><div id="402" class="line none">  402  * @brief Obtain stack usage information for the specified thread</div><div id="403" class="line none">  403  *</div><div id="404" class="line none">  404  * User threads will need to have permission on the target thread object.</div><div id="405" class="line none">  405  *</div><div id="406" class="line none">  406  * Some hardware may prevent inspection of a stack buffer currently in use.</div><div id="407" class="line none">  407  * If this API is called from supervisor mode, on the currently running thread,</div><div id="408" class="line none">  408  * on a platform which selects @kconfig{CONFIG_NO_UNUSED_STACK_INSPECTION}, an</div><div id="409" class="line none">  409  * error will be generated.</div><div id="410" class="line none">  410  *</div><div id="411" class="line none">  411  * @param thread Thread to inspect stack information</div><div id="412" class="line none">  412  * @param unused_ptr Output parameter, filled in with the unused stack space</div><div id="413" class="line none">  413  *      of the target thread in bytes.</div><div id="414" class="line none">  414  * @return 0 on success</div><div id="415" class="line none">  415  * @return -EBADF Bad thread object (user mode only)</div><div id="416" class="line none">  416  * @return -EPERM No permissions on thread object (user mode only)</div><div id="417" class="line none">  417  * #return -ENOTSUP Forbidden by hardware policy</div><div id="418" class="line none">  418  * @return -EINVAL Thread is uninitialized or exited (user mode only)</div><div id="419" class="line none">  419  * @return -EFAULT Bad memory address for unused_ptr (user mode only)</div><div id="420" class="line none">  420  */</div><div id="421" class="line none">  421 __syscall int k_thread_stack_space_get(const struct <a href="arch/arch_interface.h.html#43">k_thread</a> *<a href="kernel.h.html#4031">thread</a>,</div><div id="422" class="line none">  422                                        size_t *unused_ptr);</div><div id="423" class="line none">  423 #endif</div><div id="424" class="line none">  424 </div><div id="425" class="line none">  425 #if (K_HEAP_MEM_POOL_SIZE &gt; 0)</div><div id="426" class="line none">  426 /**</div><div id="427" class="line none">  427  * @brief Assign the system heap as a thread's resource pool</div><div id="428" class="line none">  428  *</div><div id="429" class="line none">  429  * Similar to k_thread_heap_assign(), but the thread will use</div><div id="430" class="line none">  430  * the kernel heap to draw memory.</div><div id="431" class="line none">  431  *</div><div id="432" class="line none">  432  * Use with caution, as a malicious thread could perform DoS attacks on the</div><div id="433" class="line none">  433  * kernel heap.</div><div id="434" class="line none">  434  *</div><div id="435" class="line none">  435  * @param thread Target thread to assign the system heap for resource requests</div><div id="436" class="line none">  436  *</div><div id="437" class="line none">  437  */</div><div id="438" class="line none">  438 void k_thread_system_pool_assign(struct <a href="arch/arch_interface.h.html#43">k_thread</a> *<a href="kernel.h.html#4031">thread</a>);</div><div id="439" class="line none">  439 #endif /* (K_HEAP_MEM_POOL_SIZE &gt; 0) */</div><div id="440" class="line none">  440 </div><div id="441" class="line none">  441 /**</div><div id="442" class="line none">  442  * @brief Sleep until a thread exits</div><div id="443" class="line none">  443  *</div><div id="444" class="line none">  444  * The caller will be put to sleep until the target thread exits, either due</div><div id="445" class="line none">  445  * to being aborted, self-exiting, or taking a fatal error. This API returns</div><div id="446" class="line none">  446  * immediately if the thread isn't running.</div><div id="447" class="line none">  447  *</div><div id="448" class="line none">  448  * This API may only be called from ISRs with a K_NO_WAIT timeout,</div><div id="449" class="line none">  449  * where it can be useful as a predicate to detect when a thread has</div><div id="450" class="line none">  450  * aborted.</div><div id="451" class="line none">  451  *</div><div id="452" class="line none">  452  * @param thread Thread to wait to exit</div><div id="453" class="line none">  453  * @param timeout upper bound time to wait for the thread to exit.</div><div id="454" class="line none">  454  * @retval 0 success, target thread has exited or wasn't running</div><div id="455" class="line none">  455  * @retval -EBUSY returned without waiting</div><div id="456" class="line none">  456  * @retval -EAGAIN waiting period timed out</div><div id="457" class="line none">  457  * @retval -EDEADLK target thread is joining on the caller, or target thread</div><div id="458" class="line none">  458  *                  is the caller</div><div id="459" class="line none">  459  */</div><div id="460" class="line none">  460 __syscall int k_thread_join(struct <a href="arch/arch_interface.h.html#43">k_thread</a> *<a href="kernel.h.html#4031">thread</a>, k_timeout_t <a href="kernel.h.html#1452">timeout</a>);</div><div id="461" class="line none">  461 </div><div id="462" class="line none">  462 /**</div><div id="463" class="line none">  463  * @brief Put the current thread to sleep.</div><div id="464" class="line none">  464  *</div><div id="465" class="line none">  465  * This routine puts the current thread to sleep for @a duration,</div><div id="466" class="line none">  466  * specified as a k_timeout_t object.</div><div id="467" class="line none">  467  *</div><div id="468" class="line none">  468  * @note if @a timeout is set to K_FOREVER then the thread is suspended.</div><div id="469" class="line none">  469  *</div><div id="470" class="line none">  470  * @param timeout Desired duration of sleep.</div><div id="471" class="line none">  471  *</div><div id="472" class="line none">  472  * @return Zero if the requested time has elapsed or if the thread was woken up</div><div id="473" class="line none">  473  * by the \ref k_wakeup call, the time left to sleep rounded up to the nearest</div><div id="474" class="line none">  474  * millisecond.</div><div id="475" class="line none">  475  */</div><div id="476" class="line none">  476 __syscall int32_t k_sleep(k_timeout_t <a href="kernel.h.html#1452">timeout</a>);</div><div id="477" class="line none">  477 </div><div id="478" class="line none">  478 /**</div><div id="479" class="line none">  479  * @brief Put the current thread to sleep.</div><div id="480" class="line none">  480  *</div><div id="481" class="line none">  481  * This routine puts the current thread to sleep for @a duration milliseconds.</div><div id="482" class="line none">  482  *</div><div id="483" class="line none">  483  * @param ms Number of milliseconds to sleep.</div><div id="484" class="line none">  484  *</div><div id="485" class="line none">  485  * @return Zero if the requested time has elapsed or if the thread was woken up</div><div id="486" class="line none">  486  * by the \ref k_wakeup call, the time left to sleep rounded up to the nearest</div><div id="487" class="line none">  487  * millisecond.</div><div id="488" class="line none">  488  */</div><div id="489" class="line none">  489 static inline int32_t <a href="kernel.h.html#489">k_msleep</a>(int32_t ms)</div><div id="490" class="line none">  490 {</div><div id="491" class="line none">  491         return k_sleep(Z_TIMEOUT_MS(ms));</div><div id="492" class="line none">  492 }</div><div id="493" class="line none">  493 </div><div id="494" class="line none">  494 /**</div><div id="495" class="line none">  495  * @brief Put the current thread to sleep with microsecond resolution.</div><div id="496" class="line none">  496  *</div><div id="497" class="line none">  497  * This function is unlikely to work as expected without kernel tuning.</div><div id="498" class="line none">  498  * In particular, because the lower bound on the duration of a sleep is</div><div id="499" class="line none">  499  * the duration of a tick, @kconfig{CONFIG_SYS_CLOCK_TICKS_PER_SEC} must be</div><div id="500" class="line none">  500  * adjusted to achieve the resolution desired. The implications of doing</div><div id="501" class="line none">  501  * this must be understood before attempting to use k_usleep(). Use with</div><div id="502" class="line none">  502  * caution.</div><div id="503" class="line none">  503  *</div><div id="504" class="line none">  504  * @param us Number of microseconds to sleep.</div><div id="505" class="line none">  505  *</div><div id="506" class="line none">  506  * @return Zero if the requested time has elapsed or if the thread was woken up</div><div id="507" class="line none">  507  * by the \ref k_wakeup call, the time left to sleep rounded up to the nearest</div><div id="508" class="line none">  508  * microsecond.</div><div id="509" class="line none">  509  */</div><div id="510" class="line none">  510 __syscall int32_t k_usleep(int32_t us);</div><div id="511" class="line none">  511 </div><div id="512" class="line none">  512 /**</div><div id="513" class="line none">  513  * @brief Cause the current thread to busy wait.</div><div id="514" class="line none">  514  *</div><div id="515" class="line none">  515  * This routine causes the current thread to execute a "do nothing" loop for</div><div id="516" class="line none">  516  * @a usec_to_wait microseconds.</div><div id="517" class="line none">  517  *</div><div id="518" class="line none">  518  * @note The clock used for the microsecond-resolution delay here may</div><div id="519" class="line none">  519  * be skewed relative to the clock used for system timeouts like</div><div id="520" class="line none">  520  * k_sleep().  For example k_busy_wait(1000) may take slightly more or</div><div id="521" class="line none">  521  * less time than k_sleep(K_MSEC(1)), with the offset dependent on</div><div id="522" class="line none">  522  * clock tolerances.</div><div id="523" class="line none">  523  *</div><div id="524" class="line none">  524  * @note In case when @kconfig{CONFIG_SYSTEM_CLOCK_SLOPPY_IDLE} and</div><div id="525" class="line none">  525  * @kconfig{CONFIG_PM} options are enabled, this function may not work.</div><div id="526" class="line none">  526  * The timer/clock used for delay processing may be disabled/inactive.</div><div id="527" class="line none">  527  */</div><div id="528" class="line none">  528 __syscall void k_busy_wait(uint32_t usec_to_wait);</div><div id="529" class="line none">  529 </div><div id="530" class="line none">  530 /**</div><div id="531" class="line none">  531  * @brief Check whether it is possible to yield in the current context.</div><div id="532" class="line none">  532  *</div><div id="533" class="line none">  533  * This routine checks whether the kernel is in a state where it is possible to</div><div id="534" class="line none">  534  * yield or call blocking API's. It should be used by code that needs to yield</div><div id="535" class="line none">  535  * to perform correctly, but can feasibly be called from contexts where that</div><div id="536" class="line none">  536  * is not possible. For example in the PRE_KERNEL initialization step, or when</div><div id="537" class="line none">  537  * being run from the idle thread.</div><div id="538" class="line none">  538  *</div><div id="539" class="line none">  539  * @return True if it is possible to yield in the current context, false otherwise.</div><div id="540" class="line none">  540  */</div><div id="541" class="line none">  541 bool k_can_yield(void);</div><div id="542" class="line none">  542 </div><div id="543" class="line none">  543 /**</div><div id="544" class="line none">  544  * @brief Yield the current thread.</div><div id="545" class="line none">  545  *</div><div id="546" class="line none">  546  * This routine causes the current thread to yield execution to another</div><div id="547" class="line none">  547  * thread of the same or higher priority. If there are no other ready threads</div><div id="548" class="line none">  548  * of the same or higher priority, the routine returns immediately.</div><div id="549" class="line none">  549  */</div><div id="550" class="line none">  550 __syscall void k_yield(void);</div><div id="551" class="line none">  551 </div><div id="552" class="line none">  552 /**</div><div id="553" class="line none">  553  * @brief Wake up a sleeping thread.</div><div id="554" class="line none">  554  *</div><div id="555" class="line none">  555  * This routine prematurely wakes up @a thread from sleeping.</div><div id="556" class="line none">  556  *</div><div id="557" class="line none">  557  * If @a thread is not currently sleeping, the routine has no effect.</div><div id="558" class="line none">  558  *</div><div id="559" class="line none">  559  * @param thread ID of thread to wake.</div><div id="560" class="line none">  560  */</div><div id="561" class="line none">  561 __syscall void k_wakeup(<a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4031">thread</a>);</div><div id="562" class="line none">  562 </div><div id="563" class="line none">  563 /**</div><div id="564" class="line none">  564  * @brief Query thread ID of the current thread.</div><div id="565" class="line none">  565  *</div><div id="566" class="line none">  566  * This unconditionally queries the kernel via a system call.</div><div id="567" class="line none">  567  *</div><div id="568" class="line none">  568  * @note Use k_current_get() unless absolutely sure this is necessary.</div><div id="569" class="line none">  569  *       This should only be used directly where the thread local</div><div id="570" class="line none">  570  *       variable cannot be used or may contain invalid values</div><div id="571" class="line none">  571  *       if thread local storage (TLS) is enabled. If TLS is not</div><div id="572" class="line none">  572  *       enabled, this is the same as k_current_get().</div><div id="573" class="line none">  573  *</div><div id="574" class="line none">  574  * @return ID of current thread.</div><div id="575" class="line none">  575  */</div><div id="576" class="line none">  576 __attribute_const__</div><div id="577" class="line none">  577 __syscall <a href="kernel/thread.h.html#380">k_tid_t</a> k_sched_current_thread_query(void);</div><div id="578" class="line none">  578 </div><div id="579" class="line none">  579 /**</div><div id="580" class="line none">  580  * @brief Get thread ID of the current thread.</div><div id="581" class="line none">  581  *</div><div id="582" class="line none">  582  * @return ID of current thread.</div><div id="583" class="line none">  583  *</div><div id="584" class="line none">  584  */</div><div id="585" class="line none">  585 __attribute_const__</div><div id="586" class="line none">  586 static inline <a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#586">k_current_get</a>(void)</div><div id="587" class="line none">  587 {</div><div id="588" class="line none">  588 #ifdef CONFIG_CURRENT_THREAD_USE_TLS</div><div id="589" class="line none">  589 </div><div id="590" class="line none">  590         /* Thread-local cache of current thread ID, set in z_thread_entry() */</div><div id="591" class="line none">  591         extern __thread <a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#591">z_tls_current</a>;</div><div id="592" class="line none">  592 </div><div id="593" class="line missed">  593         return <a href="kernel.h.html#591">z_tls_current</a>;</div><div id="594" class="line none">  594 #else</div><div id="595" class="line none">  595         return k_sched_current_thread_query();</div><div id="596" class="line none">  596 #endif</div><div id="597" class="line missed">  597 }</div><div id="598" class="line none">  598 </div><div id="599" class="line none">  599 /**</div><div id="600" class="line none">  600  * @brief Abort a thread.</div><div id="601" class="line none">  601  *</div><div id="602" class="line none">  602  * This routine permanently stops execution of @a thread. The thread is taken</div><div id="603" class="line none">  603  * off all kernel queues it is part of (i.e. the ready queue, the timeout</div><div id="604" class="line none">  604  * queue, or a kernel object wait queue). However, any kernel resources the</div><div id="605" class="line none">  605  * thread might currently own (such as mutexes or memory blocks) are not</div><div id="606" class="line none">  606  * released. It is the responsibility of the caller of this routine to ensure</div><div id="607" class="line none">  607  * all necessary cleanup is performed.</div><div id="608" class="line none">  608  *</div><div id="609" class="line none">  609  * After k_thread_abort() returns, the thread is guaranteed not to be</div><div id="610" class="line none">  610  * running or to become runnable anywhere on the system.  Normally</div><div id="611" class="line none">  611  * this is done via blocking the caller (in the same manner as</div><div id="612" class="line none">  612  * k_thread_join()), but in interrupt context on SMP systems the</div><div id="613" class="line none">  613  * implementation is required to spin for threads that are running on</div><div id="614" class="line none">  614  * other CPUs.</div><div id="615" class="line none">  615  *</div><div id="616" class="line none">  616  * @param thread ID of thread to abort.</div><div id="617" class="line none">  617  */</div><div id="618" class="line none">  618 __syscall void k_thread_abort(<a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4031">thread</a>);</div><div id="619" class="line none">  619 </div><div id="620" class="line none">  620 </div><div id="621" class="line none">  621 /**</div><div id="622" class="line none">  622  * @brief Start an inactive thread</div><div id="623" class="line none">  623  *</div><div id="624" class="line none">  624  * If a thread was created with K_FOREVER in the delay parameter, it will</div><div id="625" class="line none">  625  * not be added to the scheduling queue until this function is called</div><div id="626" class="line none">  626  * on it.</div><div id="627" class="line none">  627  *</div><div id="628" class="line none">  628  * @param thread thread to start</div><div id="629" class="line none">  629  */</div><div id="630" class="line none">  630 __syscall void k_thread_start(<a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4031">thread</a>);</div><div id="631" class="line none">  631 </div><div id="632" class="line none">  632 k_ticks_t z_timeout_expires(const struct <a href="kernel_structs.h.html#293">_timeout</a> *<a href="kernel.h.html#1452">timeout</a>);</div><div id="633" class="line none">  633 k_ticks_t z_timeout_remaining(const struct <a href="kernel_structs.h.html#293">_timeout</a> *<a href="kernel.h.html#1452">timeout</a>);</div><div id="634" class="line none">  634 </div><div id="635" class="line none">  635 #ifdef CONFIG_SYS_CLOCK_EXISTS</div><div id="636" class="line none">  636 </div><div id="637" class="line none">  637 /**</div><div id="638" class="line none">  638  * @brief Get time when a thread wakes up, in system ticks</div><div id="639" class="line none">  639  *</div><div id="640" class="line none">  640  * This routine computes the system uptime when a waiting thread next</div><div id="641" class="line none">  641  * executes, in units of system ticks.  If the thread is not waiting,</div><div id="642" class="line none">  642  * it returns current system time.</div><div id="643" class="line none">  643  */</div><div id="644" class="line none">  644 __syscall k_ticks_t k_thread_timeout_expires_ticks(const struct <a href="arch/arch_interface.h.html#43">k_thread</a> *<a href="kernel.h.html#4031">thread</a>);</div><div id="645" class="line none">  645 </div><div id="646" class="line none">  646 static inline k_ticks_t <a href="kernel.h.html#646">z_impl_k_thread_timeout_expires_ticks</a>(</div><div id="647" class="line none">  647                                                 const struct <a href="arch/arch_interface.h.html#43">k_thread</a> *<a href="kernel.h.html#4031">thread</a>)</div><div id="648" class="line none">  648 {</div><div id="649" class="line none">  649         return z_timeout_expires(&amp;<a href="kernel.h.html#4031">thread</a>-&gt;<a href="kernel.h.html#2762">base</a>.<a href="kernel.h.html#1452">timeout</a>);</div><div id="650" class="line none">  650 }</div><div id="651" class="line none">  651 </div><div id="652" class="line none">  652 /**</div><div id="653" class="line none">  653  * @brief Get time remaining before a thread wakes up, in system ticks</div><div id="654" class="line none">  654  *</div><div id="655" class="line none">  655  * This routine computes the time remaining before a waiting thread</div><div id="656" class="line none">  656  * next executes, in units of system ticks.  If the thread is not</div><div id="657" class="line none">  657  * waiting, it returns zero.</div><div id="658" class="line none">  658  */</div><div id="659" class="line none">  659 __syscall k_ticks_t k_thread_timeout_remaining_ticks(const struct <a href="arch/arch_interface.h.html#43">k_thread</a> *<a href="kernel.h.html#4031">thread</a>);</div><div id="660" class="line none">  660 </div><div id="661" class="line none">  661 static inline k_ticks_t <a href="kernel.h.html#661">z_impl_k_thread_timeout_remaining_ticks</a>(</div><div id="662" class="line none">  662                                                 const struct <a href="arch/arch_interface.h.html#43">k_thread</a> *<a href="kernel.h.html#4031">thread</a>)</div><div id="663" class="line none">  663 {</div><div id="664" class="line none">  664         return z_timeout_remaining(&amp;<a href="kernel.h.html#4031">thread</a>-&gt;<a href="kernel.h.html#2762">base</a>.<a href="kernel.h.html#1452">timeout</a>);</div><div id="665" class="line none">  665 }</div><div id="666" class="line none">  666 </div><div id="667" class="line none">  667 #endif /* CONFIG_SYS_CLOCK_EXISTS */</div><div id="668" class="line none">  668 </div><div id="669" class="line none">  669 /**</div><div id="670" class="line none">  670  * @cond INTERNAL_HIDDEN</div><div id="671" class="line none">  671  */</div><div id="672" class="line none">  672 </div><div id="673" class="line none">  673 struct <a href="kernel.h.html#673">_static_thread_data</a> {</div><div id="674" class="line none">  674         struct <a href="arch/arch_interface.h.html#43">k_thread</a> *<a href="kernel.h.html#674">init_thread</a>;</div><div id="675" class="line none">  675         <a href="arch/arch_interface.h.html#46">k_thread_stack_t</a> *<a href="kernel.h.html#675">init_stack</a>;</div><div id="676" class="line none">  676         unsigned int <a href="kernel.h.html#676">init_stack_size</a>;</div><div id="677" class="line none">  677         <a href="arch/arch_interface.h.html#48">k_thread_entry_t</a> <a href="kernel.h.html#677">init_entry</a>;</div><div id="678" class="line none">  678         void *<a href="kernel.h.html#678">init_p1</a>;</div><div id="679" class="line none">  679         void *<a href="kernel.h.html#679">init_p2</a>;</div><div id="680" class="line none">  680         void *<a href="kernel.h.html#680">init_p3</a>;</div><div id="681" class="line none">  681         int <a href="kernel.h.html#681">init_prio</a>;</div><div id="682" class="line none">  682         uint32_t <a href="kernel.h.html#682">init_options</a>;</div><div id="683" class="line none">  683         const char *<a href="kernel.h.html#683">init_name</a>;</div><div id="684" class="line none">  684 #ifdef CONFIG_TIMER_READS_ITS_FREQUENCY_AT_RUNTIME</div><div id="685" class="line none">  685         int32_t <a href="kernel.h.html#685">init_delay_ms</a>;</div><div id="686" class="line none">  686 #else</div><div id="687" class="line none">  687         k_timeout_t <a href="kernel.h.html#687">init_delay</a>;</div><div id="688" class="line none">  688 #endif</div><div id="689" class="line none">  689 };</div><div id="690" class="line none">  690 </div><div id="691" class="line none">  691 #ifdef CONFIG_TIMER_READS_ITS_FREQUENCY_AT_RUNTIME</div><div id="692" class="line none">  692 #define <a href="kernel.h.html#692">Z_THREAD_INIT_DELAY_INITIALIZER</a>(ms) .<a href="kernel.h.html#685">init_delay_ms</a> = (ms)</div><div id="693" class="line none">  693 #define <a href="kernel.h.html#693">Z_THREAD_INIT_DELAY</a>(<a href="kernel.h.html#4031">thread</a>) SYS_TIMEOUT_MS((<a href="kernel.h.html#4031">thread</a>)-&gt;<a href="kernel.h.html#685">init_delay_ms</a>)</div><div id="694" class="line none">  694 #else</div><div id="695" class="line none">  695 #define <a href="kernel.h.html#692">Z_THREAD_INIT_DELAY_INITIALIZER</a>(ms) .<a href="kernel.h.html#687">init_delay</a> = SYS_TIMEOUT_MS(ms)</div><div id="696" class="line none">  696 #define <a href="kernel.h.html#693">Z_THREAD_INIT_DELAY</a>(<a href="kernel.h.html#4031">thread</a>) (<a href="kernel.h.html#4031">thread</a>)-&gt;<a href="kernel.h.html#687">init_delay</a></div><div id="697" class="line none">  697 #endif</div><div id="698" class="line none">  698 </div><div id="699" class="line none">  699 #define <a href="kernel.h.html#699">Z_THREAD_INITIALIZER</a>(<a href="kernel.h.html#4031">thread</a>, <a href="sys/rb.h.html#173">stack</a>, stack_size,           \</div><div id="700" class="line none">  700                             <a href="kernel/thread.h.html#288">entry</a>, p1, p2, p3,                   \</div><div id="701" class="line none">  701                             <a href="kernel/thread.h.html#95">prio</a>, options, delay, tname)         \</div><div id="702" class="line none">  702         {                                                        \</div><div id="703" class="line none">  703         .<a href="kernel.h.html#674">init_thread</a> = (<a href="kernel.h.html#4031">thread</a>),                                 \</div><div id="704" class="line none">  704         .<a href="kernel.h.html#675">init_stack</a> = (<a href="sys/rb.h.html#173">stack</a>),                                   \</div><div id="705" class="line none">  705         .<a href="kernel.h.html#676">init_stack_size</a> = (stack_size),                         \</div><div id="706" class="line none">  706         .<a href="kernel.h.html#677">init_entry</a> = (<a href="arch/arch_interface.h.html#48">k_thread_entry_t</a>)<a href="kernel/thread.h.html#288">entry</a>,                   \</div><div id="707" class="line none">  707         .<a href="kernel.h.html#678">init_p1</a> = (void *)p1,                                   \</div><div id="708" class="line none">  708         .<a href="kernel.h.html#679">init_p2</a> = (void *)p2,                                   \</div><div id="709" class="line none">  709         .<a href="kernel.h.html#680">init_p3</a> = (void *)p3,                                   \</div><div id="710" class="line none">  710         .<a href="kernel.h.html#681">init_prio</a> = (<a href="kernel/thread.h.html#95">prio</a>),                                     \</div><div id="711" class="line none">  711         .<a href="kernel.h.html#682">init_options</a> = (options),                               \</div><div id="712" class="line none">  712         .<a href="kernel.h.html#683">init_name</a> = STRINGIFY(tname),                           \</div><div id="713" class="line none">  713         <a href="kernel.h.html#692">Z_THREAD_INIT_DELAY_INITIALIZER</a>(delay)                   \</div><div id="714" class="line none">  714         }</div><div id="715" class="line none">  715 </div><div id="716" class="line none">  716 /*</div><div id="717" class="line none">  717  * Refer to K_THREAD_DEFINE() and K_KERNEL_THREAD_DEFINE() for</div><div id="718" class="line none">  718  * information on arguments.</div><div id="719" class="line none">  719  */</div><div id="720" class="line none">  720 #define <a href="kernel.h.html#720">Z_THREAD_COMMON_DEFINE</a>(<a href="kernel.h.html#4006">name</a>, stack_size,                        \</div><div id="721" class="line none">  721                                <a href="kernel/thread.h.html#288">entry</a>, p1, p2, p3,                       \</div><div id="722" class="line none">  722                                <a href="kernel/thread.h.html#95">prio</a>, options, delay)                    \</div><div id="723" class="line none">  723         struct <a href="arch/arch_interface.h.html#43">k_thread</a> _k_thread_obj_##<a href="kernel.h.html#4006">name</a>;                           \</div><div id="724" class="line none">  724         STRUCT_SECTION_ITERABLE(<a href="kernel.h.html#673">_static_thread_data</a>,                    \</div><div id="725" class="line none">  725                                 _k_thread_data_##<a href="kernel.h.html#4006">name</a>) =                \</div><div id="726" class="line none">  726                 <a href="kernel.h.html#699">Z_THREAD_INITIALIZER</a>(&amp;_k_thread_obj_##<a href="kernel.h.html#4006">name</a>,             \</div><div id="727" class="line none">  727                                      _k_thread_stack_##<a href="kernel.h.html#4006">name</a>, stack_size,\</div><div id="728" class="line none">  728                                      <a href="kernel/thread.h.html#288">entry</a>, p1, p2, p3, <a href="kernel/thread.h.html#95">prio</a>, options,  \</div><div id="729" class="line none">  729                                      delay, <a href="kernel.h.html#4006">name</a>);                      \</div><div id="730" class="line none">  730         const <a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4006">name</a> = (<a href="kernel/thread.h.html#380">k_tid_t</a>)&amp;_k_thread_obj_##<a href="kernel.h.html#4006">name</a></div><div id="731" class="line none">  731 </div><div id="732" class="line none">  732 /**</div><div id="733" class="line none">  733  * INTERNAL_HIDDEN @endcond</div><div id="734" class="line none">  734  */</div><div id="735" class="line none">  735 </div><div id="736" class="line none">  736 /**</div><div id="737" class="line none">  737  * @brief Statically define and initialize a thread.</div><div id="738" class="line none">  738  *</div><div id="739" class="line none">  739  * The thread may be scheduled for immediate execution or a delayed start.</div><div id="740" class="line none">  740  *</div><div id="741" class="line none">  741  * Thread options are architecture-specific, and can include K_ESSENTIAL,</div><div id="742" class="line none">  742  * K_FP_REGS, and K_SSE_REGS. Multiple options may be specified by separating</div><div id="743" class="line none">  743  * them using "|" (the logical OR operator).</div><div id="744" class="line none">  744  *</div><div id="745" class="line none">  745  * The ID of the thread can be accessed using:</div><div id="746" class="line none">  746  *</div><div id="747" class="line none">  747  * @code extern const k_tid_t &lt;name&gt;; @endcode</div><div id="748" class="line none">  748  *</div><div id="749" class="line none">  749  * @param name Name of the thread.</div><div id="750" class="line none">  750  * @param stack_size Stack size in bytes.</div><div id="751" class="line none">  751  * @param entry Thread entry function.</div><div id="752" class="line none">  752  * @param p1 1st entry point parameter.</div><div id="753" class="line none">  753  * @param p2 2nd entry point parameter.</div><div id="754" class="line none">  754  * @param p3 3rd entry point parameter.</div><div id="755" class="line none">  755  * @param prio Thread priority.</div><div id="756" class="line none">  756  * @param options Thread options.</div><div id="757" class="line none">  757  * @param delay Scheduling delay (in milliseconds), zero for no delay.</div><div id="758" class="line none">  758  *</div><div id="759" class="line none">  759  * @note Static threads with zero delay should not normally have</div><div id="760" class="line none">  760  * MetaIRQ priority levels.  This can preempt the system</div><div id="761" class="line none">  761  * initialization handling (depending on the priority of the main</div><div id="762" class="line none">  762  * thread) and cause surprising ordering side effects.  It will not</div><div id="763" class="line none">  763  * affect anything in the OS per se, but consider it bad practice.</div><div id="764" class="line none">  764  * Use a SYS_INIT() callback if you need to run code before entrance</div><div id="765" class="line none">  765  * to the application main().</div><div id="766" class="line none">  766  */</div><div id="767" class="line none">  767 #define <a href="kernel.h.html#767">K_THREAD_DEFINE</a>(<a href="kernel.h.html#4006">name</a>, stack_size,                                \</div><div id="768" class="line none">  768                         <a href="kernel/thread.h.html#288">entry</a>, p1, p2, p3,                               \</div><div id="769" class="line none">  769                         <a href="kernel/thread.h.html#95">prio</a>, options, delay)                            \</div><div id="770" class="line none">  770         K_THREAD_STACK_DEFINE(_k_thread_stack_##<a href="kernel.h.html#4006">name</a>, stack_size);       \</div><div id="771" class="line none">  771         <a href="kernel.h.html#720">Z_THREAD_COMMON_DEFINE</a>(<a href="kernel.h.html#4006">name</a>, stack_size, <a href="kernel/thread.h.html#288">entry</a>, p1, p2, p3,      \</div><div id="772" class="line none">  772                                <a href="kernel/thread.h.html#95">prio</a>, options, delay)</div><div id="773" class="line none">  773 </div><div id="774" class="line none">  774 /**</div><div id="775" class="line none">  775  * @brief Statically define and initialize a thread intended to run only in kernel mode.</div><div id="776" class="line none">  776  *</div><div id="777" class="line none">  777  * The thread may be scheduled for immediate execution or a delayed start.</div><div id="778" class="line none">  778  *</div><div id="779" class="line none">  779  * Thread options are architecture-specific, and can include K_ESSENTIAL,</div><div id="780" class="line none">  780  * K_FP_REGS, and K_SSE_REGS. Multiple options may be specified by separating</div><div id="781" class="line none">  781  * them using "|" (the logical OR operator).</div><div id="782" class="line none">  782  *</div><div id="783" class="line none">  783  * The ID of the thread can be accessed using:</div><div id="784" class="line none">  784  *</div><div id="785" class="line none">  785  * @code extern const k_tid_t &lt;name&gt;; @endcode</div><div id="786" class="line none">  786  *</div><div id="787" class="line none">  787  * @note Threads defined by this can only run in kernel mode, and cannot be</div><div id="788" class="line none">  788  *       transformed into user thread via k_thread_user_mode_enter().</div><div id="789" class="line none">  789  *</div><div id="790" class="line none">  790  * @warning Depending on the architecture, the stack size (@p stack_size)</div><div id="791" class="line none">  791  *          may need to be multiples of CONFIG_MMU_PAGE_SIZE (if MMU)</div><div id="792" class="line none">  792  *          or in power-of-two size (if MPU).</div><div id="793" class="line none">  793  *</div><div id="794" class="line none">  794  * @param name Name of the thread.</div><div id="795" class="line none">  795  * @param stack_size Stack size in bytes.</div><div id="796" class="line none">  796  * @param entry Thread entry function.</div><div id="797" class="line none">  797  * @param p1 1st entry point parameter.</div><div id="798" class="line none">  798  * @param p2 2nd entry point parameter.</div><div id="799" class="line none">  799  * @param p3 3rd entry point parameter.</div><div id="800" class="line none">  800  * @param prio Thread priority.</div><div id="801" class="line none">  801  * @param options Thread options.</div><div id="802" class="line none">  802  * @param delay Scheduling delay (in milliseconds), zero for no delay.</div><div id="803" class="line none">  803  */</div><div id="804" class="line none">  804 #define <a href="kernel.h.html#804">K_KERNEL_THREAD_DEFINE</a>(<a href="kernel.h.html#4006">name</a>, stack_size,                        \</div><div id="805" class="line none">  805                                <a href="kernel/thread.h.html#288">entry</a>, p1, p2, p3,                       \</div><div id="806" class="line none">  806                                <a href="kernel/thread.h.html#95">prio</a>, options, delay)                    \</div><div id="807" class="line none">  807         K_KERNEL_STACK_DEFINE(_k_thread_stack_##<a href="kernel.h.html#4006">name</a>, stack_size);      \</div><div id="808" class="line none">  808         <a href="kernel.h.html#720">Z_THREAD_COMMON_DEFINE</a>(<a href="kernel.h.html#4006">name</a>, stack_size, <a href="kernel/thread.h.html#288">entry</a>, p1, p2, p3,     \</div><div id="809" class="line none">  809                                <a href="kernel/thread.h.html#95">prio</a>, options, delay)</div><div id="810" class="line none">  810 </div><div id="811" class="line none">  811 /**</div><div id="812" class="line none">  812  * @brief Get a thread's priority.</div><div id="813" class="line none">  813  *</div><div id="814" class="line none">  814  * This routine gets the priority of @a thread.</div><div id="815" class="line none">  815  *</div><div id="816" class="line none">  816  * @param thread ID of thread whose priority is needed.</div><div id="817" class="line none">  817  *</div><div id="818" class="line none">  818  * @return Priority of @a thread.</div><div id="819" class="line none">  819  */</div><div id="820" class="line none">  820 __syscall int k_thread_priority_get(<a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4031">thread</a>);</div><div id="821" class="line none">  821 </div><div id="822" class="line none">  822 /**</div><div id="823" class="line none">  823  * @brief Set a thread's priority.</div><div id="824" class="line none">  824  *</div><div id="825" class="line none">  825  * This routine immediately changes the priority of @a thread.</div><div id="826" class="line none">  826  *</div><div id="827" class="line none">  827  * Rescheduling can occur immediately depending on the priority @a thread is</div><div id="828" class="line none">  828  * set to:</div><div id="829" class="line none">  829  *</div><div id="830" class="line none">  830  * - If its priority is raised above the priority of the caller of this</div><div id="831" class="line none">  831  * function, and the caller is preemptible, @a thread will be scheduled in.</div><div id="832" class="line none">  832  *</div><div id="833" class="line none">  833  * - If the caller operates on itself, it lowers its priority below that of</div><div id="834" class="line none">  834  * other threads in the system, and the caller is preemptible, the thread of</div><div id="835" class="line none">  835  * highest priority will be scheduled in.</div><div id="836" class="line none">  836  *</div><div id="837" class="line none">  837  * Priority can be assigned in the range of -CONFIG_NUM_COOP_PRIORITIES to</div><div id="838" class="line none">  838  * CONFIG_NUM_PREEMPT_PRIORITIES-1, where -CONFIG_NUM_COOP_PRIORITIES is the</div><div id="839" class="line none">  839  * highest priority.</div><div id="840" class="line none">  840  *</div><div id="841" class="line none">  841  * @param thread ID of thread whose priority is to be set.</div><div id="842" class="line none">  842  * @param prio New priority.</div><div id="843" class="line none">  843  *</div><div id="844" class="line none">  844  * @warning Changing the priority of a thread currently involved in mutex</div><div id="845" class="line none">  845  * priority inheritance may result in undefined behavior.</div><div id="846" class="line none">  846  */</div><div id="847" class="line none">  847 __syscall void k_thread_priority_set(<a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4031">thread</a>, int <a href="kernel/thread.h.html#95">prio</a>);</div><div id="848" class="line none">  848 </div><div id="849" class="line none">  849 </div><div id="850" class="line none">  850 #ifdef CONFIG_SCHED_DEADLINE</div><div id="851" class="line none">  851 /**</div><div id="852" class="line none">  852  * @brief Set deadline expiration time for scheduler</div><div id="853" class="line none">  853  *</div><div id="854" class="line none">  854  * This sets the "deadline" expiration as a time delta from the</div><div id="855" class="line none">  855  * current time, in the same units used by k_cycle_get_32().  The</div><div id="856" class="line none">  856  * scheduler (when deadline scheduling is enabled) will choose the</div><div id="857" class="line none">  857  * next expiring thread when selecting between threads at the same</div><div id="858" class="line none">  858  * static priority.  Threads at different priorities will be scheduled</div><div id="859" class="line none">  859  * according to their static priority.</div><div id="860" class="line none">  860  *</div><div id="861" class="line none">  861  * @note Deadlines are stored internally using 32 bit unsigned</div><div id="862" class="line none">  862  * integers.  The number of cycles between the "first" deadline in the</div><div id="863" class="line none">  863  * scheduler queue and the "last" deadline must be less than 2^31 (i.e</div><div id="864" class="line none">  864  * a signed non-negative quantity).  Failure to adhere to this rule</div><div id="865" class="line none">  865  * may result in scheduled threads running in an incorrect deadline</div><div id="866" class="line none">  866  * order.</div><div id="867" class="line none">  867  *</div><div id="868" class="line none">  868  * @note Despite the API naming, the scheduler makes no guarantees</div><div id="869" class="line none">  869  * the thread WILL be scheduled within that deadline, nor does it take</div><div id="870" class="line none">  870  * extra metadata (like e.g. the "runtime" and "period" parameters in</div><div id="871" class="line none">  871  * Linux sched_setattr()) that allows the kernel to validate the</div><div id="872" class="line none">  872  * scheduling for achievability.  Such features could be implemented</div><div id="873" class="line none">  873  * above this call, which is simply input to the priority selection</div><div id="874" class="line none">  874  * logic.</div><div id="875" class="line none">  875  *</div><div id="876" class="line none">  876  * @note You should enable @kconfig{CONFIG_SCHED_DEADLINE} in your project</div><div id="877" class="line none">  877  * configuration.</div><div id="878" class="line none">  878  *</div><div id="879" class="line none">  879  * @param thread A thread on which to set the deadline</div><div id="880" class="line none">  880  * @param deadline A time delta, in cycle units</div><div id="881" class="line none">  881  *</div><div id="882" class="line none">  882  */</div><div id="883" class="line none">  883 __syscall void k_thread_deadline_set(<a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4031">thread</a>, int deadline);</div><div id="884" class="line none">  884 #endif</div><div id="885" class="line none">  885 </div><div id="886" class="line none">  886 #ifdef CONFIG_SCHED_CPU_MASK</div><div id="887" class="line none">  887 /**</div><div id="888" class="line none">  888  * @brief Sets all CPU enable masks to zero</div><div id="889" class="line none">  889  *</div><div id="890" class="line none">  890  * After this returns, the thread will no longer be schedulable on any</div><div id="891" class="line none">  891  * CPUs.  The thread must not be currently runnable.</div><div id="892" class="line none">  892  *</div><div id="893" class="line none">  893  * @note You should enable @kconfig{CONFIG_SCHED_CPU_MASK} in your project</div><div id="894" class="line none">  894  * configuration.</div><div id="895" class="line none">  895  *</div><div id="896" class="line none">  896  * @param thread Thread to operate upon</div><div id="897" class="line none">  897  * @return Zero on success, otherwise error code</div><div id="898" class="line none">  898  */</div><div id="899" class="line none">  899 int k_thread_cpu_mask_clear(<a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4031">thread</a>);</div><div id="900" class="line none">  900 </div><div id="901" class="line none">  901 /**</div><div id="902" class="line none">  902  * @brief Sets all CPU enable masks to one</div><div id="903" class="line none">  903  *</div><div id="904" class="line none">  904  * After this returns, the thread will be schedulable on any CPU.  The</div><div id="905" class="line none">  905  * thread must not be currently runnable.</div><div id="906" class="line none">  906  *</div><div id="907" class="line none">  907  * @note You should enable @kconfig{CONFIG_SCHED_CPU_MASK} in your project</div><div id="908" class="line none">  908  * configuration.</div><div id="909" class="line none">  909  *</div><div id="910" class="line none">  910  * @param thread Thread to operate upon</div><div id="911" class="line none">  911  * @return Zero on success, otherwise error code</div><div id="912" class="line none">  912  */</div><div id="913" class="line none">  913 int k_thread_cpu_mask_enable_all(<a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4031">thread</a>);</div><div id="914" class="line none">  914 </div><div id="915" class="line none">  915 /**</div><div id="916" class="line none">  916  * @brief Enable thread to run on specified CPU</div><div id="917" class="line none">  917  *</div><div id="918" class="line none">  918  * The thread must not be currently runnable.</div><div id="919" class="line none">  919  *</div><div id="920" class="line none">  920  * @note You should enable @kconfig{CONFIG_SCHED_CPU_MASK} in your project</div><div id="921" class="line none">  921  * configuration.</div><div id="922" class="line none">  922  *</div><div id="923" class="line none">  923  * @param thread Thread to operate upon</div><div id="924" class="line none">  924  * @param cpu CPU index</div><div id="925" class="line none">  925  * @return Zero on success, otherwise error code</div><div id="926" class="line none">  926  */</div><div id="927" class="line none">  927 int k_thread_cpu_mask_enable(<a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4031">thread</a>, int <a href="kernel/thread.h.html#115">cpu</a>);</div><div id="928" class="line none">  928 </div><div id="929" class="line none">  929 /**</div><div id="930" class="line none">  930  * @brief Prevent thread to run on specified CPU</div><div id="931" class="line none">  931  *</div><div id="932" class="line none">  932  * The thread must not be currently runnable.</div><div id="933" class="line none">  933  *</div><div id="934" class="line none">  934  * @note You should enable @kconfig{CONFIG_SCHED_CPU_MASK} in your project</div><div id="935" class="line none">  935  * configuration.</div><div id="936" class="line none">  936  *</div><div id="937" class="line none">  937  * @param thread Thread to operate upon</div><div id="938" class="line none">  938  * @param cpu CPU index</div><div id="939" class="line none">  939  * @return Zero on success, otherwise error code</div><div id="940" class="line none">  940  */</div><div id="941" class="line none">  941 int k_thread_cpu_mask_disable(<a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4031">thread</a>, int <a href="kernel/thread.h.html#115">cpu</a>);</div><div id="942" class="line none">  942 </div><div id="943" class="line none">  943 /**</div><div id="944" class="line none">  944  * @brief Pin a thread to a CPU</div><div id="945" class="line none">  945  *</div><div id="946" class="line none">  946  * Pin a thread to a CPU by first clearing the cpu mask and then enabling the</div><div id="947" class="line none">  947  * thread on the selected CPU.</div><div id="948" class="line none">  948  *</div><div id="949" class="line none">  949  * @param thread Thread to operate upon</div><div id="950" class="line none">  950  * @param cpu CPU index</div><div id="951" class="line none">  951  * @return Zero on success, otherwise error code</div><div id="952" class="line none">  952  */</div><div id="953" class="line none">  953 int k_thread_cpu_pin(<a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4031">thread</a>, int <a href="kernel/thread.h.html#115">cpu</a>);</div><div id="954" class="line none">  954 #endif</div><div id="955" class="line none">  955 </div><div id="956" class="line none">  956 /**</div><div id="957" class="line none">  957  * @brief Suspend a thread.</div><div id="958" class="line none">  958  *</div><div id="959" class="line none">  959  * This routine prevents the kernel scheduler from making @a thread</div><div id="960" class="line none">  960  * the current thread. All other internal operations on @a thread are</div><div id="961" class="line none">  961  * still performed; for example, kernel objects it is waiting on are</div><div id="962" class="line none">  962  * still handed to it.  Note that any existing timeouts</div><div id="963" class="line none">  963  * (e.g. k_sleep(), or a timeout argument to k_sem_take() et. al.)</div><div id="964" class="line none">  964  * will be canceled.  On resume, the thread will begin running</div><div id="965" class="line none">  965  * immediately and return from the blocked call.</div><div id="966" class="line none">  966  *</div><div id="967" class="line none">  967  * When the target thread is active on another CPU, the caller will block until</div><div id="968" class="line none">  968  * the target thread is halted (suspended or aborted).  But if the caller is in</div><div id="969" class="line none">  969  * an interrupt context, it will spin waiting for that target thread active on</div><div id="970" class="line none">  970  * another CPU to halt.</div><div id="971" class="line none">  971  *</div><div id="972" class="line none">  972  * If @a thread is already suspended, the routine has no effect.</div><div id="973" class="line none">  973  *</div><div id="974" class="line none">  974  * @param thread ID of thread to suspend.</div><div id="975" class="line none">  975  */</div><div id="976" class="line none">  976 __syscall void k_thread_suspend(<a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4031">thread</a>);</div><div id="977" class="line none">  977 </div><div id="978" class="line none">  978 /**</div><div id="979" class="line none">  979  * @brief Resume a suspended thread.</div><div id="980" class="line none">  980  *</div><div id="981" class="line none">  981  * This routine allows the kernel scheduler to make @a thread the current</div><div id="982" class="line none">  982  * thread, when it is next eligible for that role.</div><div id="983" class="line none">  983  *</div><div id="984" class="line none">  984  * If @a thread is not currently suspended, the routine has no effect.</div><div id="985" class="line none">  985  *</div><div id="986" class="line none">  986  * @param thread ID of thread to resume.</div><div id="987" class="line none">  987  */</div><div id="988" class="line none">  988 __syscall void k_thread_resume(<a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4031">thread</a>);</div><div id="989" class="line none">  989 </div><div id="990" class="line none">  990 /**</div><div id="991" class="line none">  991  * @brief Set time-slicing period and scope.</div><div id="992" class="line none">  992  *</div><div id="993" class="line none">  993  * This routine specifies how the scheduler will perform time slicing of</div><div id="994" class="line none">  994  * preemptible threads.</div><div id="995" class="line none">  995  *</div><div id="996" class="line none">  996  * To enable time slicing, @a slice must be non-zero. The scheduler</div><div id="997" class="line none">  997  * ensures that no thread runs for more than the specified time limit</div><div id="998" class="line none">  998  * before other threads of that priority are given a chance to execute.</div><div id="999" class="line none">  999  * Any thread whose priority is higher than @a prio is exempted, and may</div><div id="1000" class="line none"> 1000  * execute as long as desired without being preempted due to time slicing.</div><div id="1001" class="line none"> 1001  *</div><div id="1002" class="line none"> 1002  * Time slicing only limits the maximum amount of time a thread may continuously</div><div id="1003" class="line none"> 1003  * execute. Once the scheduler selects a thread for execution, there is no</div><div id="1004" class="line none"> 1004  * minimum guaranteed time the thread will execute before threads of greater or</div><div id="1005" class="line none"> 1005  * equal priority are scheduled.</div><div id="1006" class="line none"> 1006  *</div><div id="1007" class="line none"> 1007  * When the current thread is the only one of that priority eligible</div><div id="1008" class="line none"> 1008  * for execution, this routine has no effect; the thread is immediately</div><div id="1009" class="line none"> 1009  * rescheduled after the slice period expires.</div><div id="1010" class="line none"> 1010  *</div><div id="1011" class="line none"> 1011  * To disable timeslicing, set both @a slice and @a prio to zero.</div><div id="1012" class="line none"> 1012  *</div><div id="1013" class="line none"> 1013  * @param slice Maximum time slice length (in milliseconds).</div><div id="1014" class="line none"> 1014  * @param prio Highest thread priority level eligible for time slicing.</div><div id="1015" class="line none"> 1015  */</div><div id="1016" class="line none"> 1016 void k_sched_time_slice_set(int32_t slice, int <a href="kernel/thread.h.html#95">prio</a>);</div><div id="1017" class="line none"> 1017 </div><div id="1018" class="line none"> 1018 /**</div><div id="1019" class="line none"> 1019  * @brief Set thread time slice</div><div id="1020" class="line none"> 1020  *</div><div id="1021" class="line none"> 1021  * As for k_sched_time_slice_set, but (when</div><div id="1022" class="line none"> 1022  * CONFIG_TIMESLICE_PER_THREAD=y) sets the timeslice for a specific</div><div id="1023" class="line none"> 1023  * thread.  When non-zero, this timeslice will take precedence over</div><div id="1024" class="line none"> 1024  * the global value.</div><div id="1025" class="line none"> 1025  *</div><div id="1026" class="line none"> 1026  * When such a thread's timeslice expires, the configured callback</div><div id="1027" class="line none"> 1027  * will be called before the thread is removed/re-added to the run</div><div id="1028" class="line none"> 1028  * queue.  This callback will occur in interrupt context, and the</div><div id="1029" class="line none"> 1029  * specified thread is guaranteed to have been preempted by the</div><div id="1030" class="line none"> 1030  * currently-executing ISR.  Such a callback is free to, for example,</div><div id="1031" class="line none"> 1031  * modify the thread priority or slice time for future execution,</div><div id="1032" class="line none"> 1032  * suspend the thread, etc...</div><div id="1033" class="line none"> 1033  *</div><div id="1034" class="line none"> 1034  * @note Unlike the older API, the time slice parameter here is</div><div id="1035" class="line none"> 1035  * specified in ticks, not milliseconds.  Ticks have always been the</div><div id="1036" class="line none"> 1036  * internal unit, and not all platforms have integer conversions</div><div id="1037" class="line none"> 1037  * between the two.</div><div id="1038" class="line none"> 1038  *</div><div id="1039" class="line none"> 1039  * @note Threads with a non-zero slice time set will be timesliced</div><div id="1040" class="line none"> 1040  * always, even if they are higher priority than the maximum timeslice</div><div id="1041" class="line none"> 1041  * priority set via k_sched_time_slice_set().</div><div id="1042" class="line none"> 1042  *</div><div id="1043" class="line none"> 1043  * @note The callback notification for slice expiration happens, as it</div><div id="1044" class="line none"> 1044  * must, while the thread is still "current", and thus it happens</div><div id="1045" class="line none"> 1045  * before any registered timeouts at this tick.  This has the somewhat</div><div id="1046" class="line none"> 1046  * confusing side effect that the tick time (c.f. k_uptime_get()) does</div><div id="1047" class="line none"> 1047  * not yet reflect the expired ticks.  Applications wishing to make</div><div id="1048" class="line none"> 1048  * fine-grained timing decisions within this callback should use the</div><div id="1049" class="line none"> 1049  * cycle API, or derived facilities like k_thread_runtime_stats_get().</div><div id="1050" class="line none"> 1050  *</div><div id="1051" class="line none"> 1051  * @param th A valid, initialized thread</div><div id="1052" class="line none"> 1052  * @param slice_ticks Maximum timeslice, in ticks</div><div id="1053" class="line none"> 1053  * @param expired Callback function called on slice expiration</div><div id="1054" class="line none"> 1054  * @param data Parameter for the expiration handler</div><div id="1055" class="line none"> 1055  */</div><div id="1056" class="line none"> 1056 void k_thread_time_slice_set(struct <a href="arch/arch_interface.h.html#43">k_thread</a> *th, int32_t <a href="kernel/thread.h.html#140">slice_ticks</a>,</div><div id="1057" class="line none"> 1057                              <a href="kernel_structs.h.html#307">k_thread_timeslice_fn_t</a> expired, void *<a href="logging/log_msg.h.html#100">data</a>);</div><div id="1058" class="line none"> 1058 </div><div id="1059" class="line none"> 1059 /** @} */</div><div id="1060" class="line none"> 1060 </div><div id="1061" class="line none"> 1061 /**</div><div id="1062" class="line none"> 1062  * @addtogroup isr_apis</div><div id="1063" class="line none"> 1063  * @{</div><div id="1064" class="line none"> 1064  */</div><div id="1065" class="line none"> 1065 </div><div id="1066" class="line none"> 1066 /**</div><div id="1067" class="line none"> 1067  * @brief Determine if code is running at interrupt level.</div><div id="1068" class="line none"> 1068  *</div><div id="1069" class="line none"> 1069  * This routine allows the caller to customize its actions, depending on</div><div id="1070" class="line none"> 1070  * whether it is a thread or an ISR.</div><div id="1071" class="line none"> 1071  *</div><div id="1072" class="line none"> 1072  * @funcprops \isr_ok</div><div id="1073" class="line none"> 1073  *</div><div id="1074" class="line none"> 1074  * @return false if invoked by a thread.</div><div id="1075" class="line none"> 1075  * @return true if invoked by an ISR.</div><div id="1076" class="line none"> 1076  */</div><div id="1077" class="line none"> 1077 bool k_is_in_isr(void);</div><div id="1078" class="line none"> 1078 </div><div id="1079" class="line none"> 1079 /**</div><div id="1080" class="line none"> 1080  * @brief Determine if code is running in a preemptible thread.</div><div id="1081" class="line none"> 1081  *</div><div id="1082" class="line none"> 1082  * This routine allows the caller to customize its actions, depending on</div><div id="1083" class="line none"> 1083  * whether it can be preempted by another thread. The routine returns a 'true'</div><div id="1084" class="line none"> 1084  * value if all of the following conditions are met:</div><div id="1085" class="line none"> 1085  *</div><div id="1086" class="line none"> 1086  * - The code is running in a thread, not at ISR.</div><div id="1087" class="line none"> 1087  * - The thread's priority is in the preemptible range.</div><div id="1088" class="line none"> 1088  * - The thread has not locked the scheduler.</div><div id="1089" class="line none"> 1089  *</div><div id="1090" class="line none"> 1090  * @funcprops \isr_ok</div><div id="1091" class="line none"> 1091  *</div><div id="1092" class="line none"> 1092  * @return 0 if invoked by an ISR or by a cooperative thread.</div><div id="1093" class="line none"> 1093  * @return Non-zero if invoked by a preemptible thread.</div><div id="1094" class="line none"> 1094  */</div><div id="1095" class="line none"> 1095 __syscall int k_is_preempt_thread(void);</div><div id="1096" class="line none"> 1096 </div><div id="1097" class="line none"> 1097 /**</div><div id="1098" class="line none"> 1098  * @brief Test whether startup is in the before-main-task phase.</div><div id="1099" class="line none"> 1099  *</div><div id="1100" class="line none"> 1100  * This routine allows the caller to customize its actions, depending on</div><div id="1101" class="line none"> 1101  * whether it being invoked before the kernel is fully active.</div><div id="1102" class="line none"> 1102  *</div><div id="1103" class="line none"> 1103  * @funcprops \isr_ok</div><div id="1104" class="line none"> 1104  *</div><div id="1105" class="line none"> 1105  * @return true if invoked before post-kernel initialization</div><div id="1106" class="line none"> 1106  * @return false if invoked during/after post-kernel initialization</div><div id="1107" class="line none"> 1107  */</div><div id="1108" class="line none"> 1108 static inline bool <a href="kernel.h.html#1108">k_is_pre_kernel</a>(void)</div><div id="1109" class="line none"> 1109 {</div><div id="1110" class="line none"> 1110         extern bool z_sys_post_kernel; /* in init.c */</div><div id="1111" class="line none"> 1111 </div><div id="1112" class="line none"> 1112         return !z_sys_post_kernel;</div><div id="1113" class="line none"> 1113 }</div><div id="1114" class="line none"> 1114 </div><div id="1115" class="line none"> 1115 /**</div><div id="1116" class="line none"> 1116  * @}</div><div id="1117" class="line none"> 1117  */</div><div id="1118" class="line none"> 1118 </div><div id="1119" class="line none"> 1119 /**</div><div id="1120" class="line none"> 1120  * @addtogroup thread_apis</div><div id="1121" class="line none"> 1121  * @{</div><div id="1122" class="line none"> 1122  */</div><div id="1123" class="line none"> 1123 </div><div id="1124" class="line none"> 1124 /**</div><div id="1125" class="line none"> 1125  * @brief Lock the scheduler.</div><div id="1126" class="line none"> 1126  *</div><div id="1127" class="line none"> 1127  * This routine prevents the current thread from being preempted by another</div><div id="1128" class="line none"> 1128  * thread by instructing the scheduler to treat it as a cooperative thread.</div><div id="1129" class="line none"> 1129  * If the thread subsequently performs an operation that makes it unready,</div><div id="1130" class="line none"> 1130  * it will be context switched out in the normal manner. When the thread</div><div id="1131" class="line none"> 1131  * again becomes the current thread, its non-preemptible status is maintained.</div><div id="1132" class="line none"> 1132  *</div><div id="1133" class="line none"> 1133  * This routine can be called recursively.</div><div id="1134" class="line none"> 1134  *</div><div id="1135" class="line none"> 1135  * Owing to clever implementation details, scheduler locks are</div><div id="1136" class="line none"> 1136  * extremely fast for non-userspace threads (just one byte</div><div id="1137" class="line none"> 1137  * inc/decrement in the thread struct).</div><div id="1138" class="line none"> 1138  *</div><div id="1139" class="line none"> 1139  * @note This works by elevating the thread priority temporarily to a</div><div id="1140" class="line none"> 1140  * cooperative priority, allowing cheap synchronization vs. other</div><div id="1141" class="line none"> 1141  * preemptible or cooperative threads running on the current CPU.  It</div><div id="1142" class="line none"> 1142  * does not prevent preemption or asynchrony of other types.  It does</div><div id="1143" class="line none"> 1143  * not prevent threads from running on other CPUs when CONFIG_SMP=y.</div><div id="1144" class="line none"> 1144  * It does not prevent interrupts from happening, nor does it prevent</div><div id="1145" class="line none"> 1145  * threads with MetaIRQ priorities from preempting the current thread.</div><div id="1146" class="line none"> 1146  * In general this is a historical API not well-suited to modern</div><div id="1147" class="line none"> 1147  * applications, use with care.</div><div id="1148" class="line none"> 1148  */</div><div id="1149" class="line none"> 1149 void k_sched_lock(void);</div><div id="1150" class="line none"> 1150 </div><div id="1151" class="line none"> 1151 /**</div><div id="1152" class="line none"> 1152  * @brief Unlock the scheduler.</div><div id="1153" class="line none"> 1153  *</div><div id="1154" class="line none"> 1154  * This routine reverses the effect of a previous call to k_sched_lock().</div><div id="1155" class="line none"> 1155  * A thread must call the routine once for each time it called k_sched_lock()</div><div id="1156" class="line none"> 1156  * before the thread becomes preemptible.</div><div id="1157" class="line none"> 1157  */</div><div id="1158" class="line none"> 1158 void k_sched_unlock(void);</div><div id="1159" class="line none"> 1159 </div><div id="1160" class="line none"> 1160 /**</div><div id="1161" class="line none"> 1161  * @brief Set current thread's custom data.</div><div id="1162" class="line none"> 1162  *</div><div id="1163" class="line none"> 1163  * This routine sets the custom data for the current thread to @ value.</div><div id="1164" class="line none"> 1164  *</div><div id="1165" class="line none"> 1165  * Custom data is not used by the kernel itself, and is freely available</div><div id="1166" class="line none"> 1166  * for a thread to use as it sees fit. It can be used as a framework</div><div id="1167" class="line none"> 1167  * upon which to build thread-local storage.</div><div id="1168" class="line none"> 1168  *</div><div id="1169" class="line none"> 1169  * @param value New custom data value.</div><div id="1170" class="line none"> 1170  *</div><div id="1171" class="line none"> 1171  */</div><div id="1172" class="line none"> 1172 __syscall void k_thread_custom_data_set(void *value);</div><div id="1173" class="line none"> 1173 </div><div id="1174" class="line none"> 1174 /**</div><div id="1175" class="line none"> 1175  * @brief Get current thread's custom data.</div><div id="1176" class="line none"> 1176  *</div><div id="1177" class="line none"> 1177  * This routine returns the custom data for the current thread.</div><div id="1178" class="line none"> 1178  *</div><div id="1179" class="line none"> 1179  * @return Current custom data value.</div><div id="1180" class="line none"> 1180  */</div><div id="1181" class="line none"> 1181 __syscall void *k_thread_custom_data_get(void);</div><div id="1182" class="line none"> 1182 </div><div id="1183" class="line none"> 1183 /**</div><div id="1184" class="line none"> 1184  * @brief Set current thread name</div><div id="1185" class="line none"> 1185  *</div><div id="1186" class="line none"> 1186  * Set the name of the thread to be used when @kconfig{CONFIG_THREAD_MONITOR}</div><div id="1187" class="line none"> 1187  * is enabled for tracing and debugging.</div><div id="1188" class="line none"> 1188  *</div><div id="1189" class="line none"> 1189  * @param thread Thread to set name, or NULL to set the current thread</div><div id="1190" class="line none"> 1190  * @param str Name string</div><div id="1191" class="line none"> 1191  * @retval 0 on success</div><div id="1192" class="line none"> 1192  * @retval -EFAULT Memory access error with supplied string</div><div id="1193" class="line none"> 1193  * @retval -ENOSYS Thread name configuration option not enabled</div><div id="1194" class="line none"> 1194  * @retval -EINVAL Thread name too long</div><div id="1195" class="line none"> 1195  */</div><div id="1196" class="line none"> 1196 __syscall int k_thread_name_set(<a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4031">thread</a>, const char *str);</div><div id="1197" class="line none"> 1197 </div><div id="1198" class="line none"> 1198 /**</div><div id="1199" class="line none"> 1199  * @brief Get thread name</div><div id="1200" class="line none"> 1200  *</div><div id="1201" class="line none"> 1201  * Get the name of a thread</div><div id="1202" class="line none"> 1202  *</div><div id="1203" class="line none"> 1203  * @param thread Thread ID</div><div id="1204" class="line none"> 1204  * @retval Thread name, or NULL if configuration not enabled</div><div id="1205" class="line none"> 1205  */</div><div id="1206" class="line none"> 1206 const char *k_thread_name_get(<a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4031">thread</a>);</div><div id="1207" class="line none"> 1207 </div><div id="1208" class="line none"> 1208 /**</div><div id="1209" class="line none"> 1209  * @brief Copy the thread name into a supplied buffer</div><div id="1210" class="line none"> 1210  *</div><div id="1211" class="line none"> 1211  * @param thread Thread to obtain name information</div><div id="1212" class="line none"> 1212  * @param buf Destination buffer</div><div id="1213" class="line none"> 1213  * @param size Destination buffer size</div><div id="1214" class="line none"> 1214  * @retval -ENOSPC Destination buffer too small</div><div id="1215" class="line none"> 1215  * @retval -EFAULT Memory access error</div><div id="1216" class="line none"> 1216  * @retval -ENOSYS Thread name feature not enabled</div><div id="1217" class="line none"> 1217  * @retval 0 Success</div><div id="1218" class="line none"> 1218  */</div><div id="1219" class="line none"> 1219 __syscall int k_thread_name_copy(<a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4031">thread</a>, char *<a href="logging/log_msg.h.html#118">buf</a>,</div><div id="1220" class="line none"> 1220                                  size_t <a href="kernel.h.html#4716">size</a>);</div><div id="1221" class="line none"> 1221 </div><div id="1222" class="line none"> 1222 /**</div><div id="1223" class="line none"> 1223  * @brief Get thread state string</div><div id="1224" class="line none"> 1224  *</div><div id="1225" class="line none"> 1225  * This routine generates a human friendly string containing the thread's</div><div id="1226" class="line none"> 1226  * state, and copies as much of it as possible into @a buf.</div><div id="1227" class="line none"> 1227  *</div><div id="1228" class="line none"> 1228  * @param thread_id Thread ID</div><div id="1229" class="line none"> 1229  * @param buf Buffer into which to copy state strings</div><div id="1230" class="line none"> 1230  * @param buf_size Size of the buffer</div><div id="1231" class="line none"> 1231  *</div><div id="1232" class="line none"> 1232  * @retval Pointer to @a buf if data was copied, else a pointer to "".</div><div id="1233" class="line none"> 1233  */</div><div id="1234" class="line none"> 1234 const char *k_thread_state_str(<a href="kernel/thread.h.html#380">k_tid_t</a> thread_id, char *<a href="logging/log_msg.h.html#118">buf</a>, size_t buf_size);</div><div id="1235" class="line none"> 1235 </div><div id="1236" class="line none"> 1236 /**</div><div id="1237" class="line none"> 1237  * @}</div><div id="1238" class="line none"> 1238  */</div><div id="1239" class="line none"> 1239 </div><div id="1240" class="line none"> 1240 /**</div><div id="1241" class="line none"> 1241  * @addtogroup clock_apis</div><div id="1242" class="line none"> 1242  * @{</div><div id="1243" class="line none"> 1243  */</div><div id="1244" class="line none"> 1244 </div><div id="1245" class="line none"> 1245 /**</div><div id="1246" class="line none"> 1246  * @brief Generate null timeout delay.</div><div id="1247" class="line none"> 1247  *</div><div id="1248" class="line none"> 1248  * This macro generates a timeout delay that instructs a kernel API</div><div id="1249" class="line none"> 1249  * not to wait if the requested operation cannot be performed immediately.</div><div id="1250" class="line none"> 1250  *</div><div id="1251" class="line none"> 1251  * @return Timeout delay value.</div><div id="1252" class="line none"> 1252  */</div><div id="1253" class="line none"> 1253 #define <a href="kernel.h.html#1253">K_NO_WAIT</a> Z_TIMEOUT_NO_WAIT</div><div id="1254" class="line none"> 1254 </div><div id="1255" class="line none"> 1255 /**</div><div id="1256" class="line none"> 1256  * @brief Generate timeout delay from nanoseconds.</div><div id="1257" class="line none"> 1257  *</div><div id="1258" class="line none"> 1258  * This macro generates a timeout delay that instructs a kernel API to</div><div id="1259" class="line none"> 1259  * wait up to @a t nanoseconds to perform the requested operation.</div><div id="1260" class="line none"> 1260  * Note that timer precision is limited to the tick rate, not the</div><div id="1261" class="line none"> 1261  * requested value.</div><div id="1262" class="line none"> 1262  *</div><div id="1263" class="line none"> 1263  * @param t Duration in nanoseconds.</div><div id="1264" class="line none"> 1264  *</div><div id="1265" class="line none"> 1265  * @return Timeout delay value.</div><div id="1266" class="line none"> 1266  */</div><div id="1267" class="line none"> 1267 #define <a href="kernel.h.html#1267">K_NSEC</a>(t)     Z_TIMEOUT_NS(t)</div><div id="1268" class="line none"> 1268 </div><div id="1269" class="line none"> 1269 /**</div><div id="1270" class="line none"> 1270  * @brief Generate timeout delay from microseconds.</div><div id="1271" class="line none"> 1271  *</div><div id="1272" class="line none"> 1272  * This macro generates a timeout delay that instructs a kernel API</div><div id="1273" class="line none"> 1273  * to wait up to @a t microseconds to perform the requested operation.</div><div id="1274" class="line none"> 1274  * Note that timer precision is limited to the tick rate, not the</div><div id="1275" class="line none"> 1275  * requested value.</div><div id="1276" class="line none"> 1276  *</div><div id="1277" class="line none"> 1277  * @param t Duration in microseconds.</div><div id="1278" class="line none"> 1278  *</div><div id="1279" class="line none"> 1279  * @return Timeout delay value.</div><div id="1280" class="line none"> 1280  */</div><div id="1281" class="line none"> 1281 #define <a href="kernel.h.html#1281">K_USEC</a>(t)     Z_TIMEOUT_US(t)</div><div id="1282" class="line none"> 1282 </div><div id="1283" class="line none"> 1283 /**</div><div id="1284" class="line none"> 1284  * @brief Generate timeout delay from cycles.</div><div id="1285" class="line none"> 1285  *</div><div id="1286" class="line none"> 1286  * This macro generates a timeout delay that instructs a kernel API</div><div id="1287" class="line none"> 1287  * to wait up to @a t cycles to perform the requested operation.</div><div id="1288" class="line none"> 1288  *</div><div id="1289" class="line none"> 1289  * @param t Duration in cycles.</div><div id="1290" class="line none"> 1290  *</div><div id="1291" class="line none"> 1291  * @return Timeout delay value.</div><div id="1292" class="line none"> 1292  */</div><div id="1293" class="line none"> 1293 #define <a href="kernel.h.html#1293">K_CYC</a>(t)     Z_TIMEOUT_CYC(t)</div><div id="1294" class="line none"> 1294 </div><div id="1295" class="line none"> 1295 /**</div><div id="1296" class="line none"> 1296  * @brief Generate timeout delay from system ticks.</div><div id="1297" class="line none"> 1297  *</div><div id="1298" class="line none"> 1298  * This macro generates a timeout delay that instructs a kernel API</div><div id="1299" class="line none"> 1299  * to wait up to @a t ticks to perform the requested operation.</div><div id="1300" class="line none"> 1300  *</div><div id="1301" class="line none"> 1301  * @param t Duration in system ticks.</div><div id="1302" class="line none"> 1302  *</div><div id="1303" class="line none"> 1303  * @return Timeout delay value.</div><div id="1304" class="line none"> 1304  */</div><div id="1305" class="line none"> 1305 #define <a href="kernel.h.html#1305">K_TICKS</a>(t)     Z_TIMEOUT_TICKS(t)</div><div id="1306" class="line none"> 1306 </div><div id="1307" class="line none"> 1307 /**</div><div id="1308" class="line none"> 1308  * @brief Generate timeout delay from milliseconds.</div><div id="1309" class="line none"> 1309  *</div><div id="1310" class="line none"> 1310  * This macro generates a timeout delay that instructs a kernel API</div><div id="1311" class="line none"> 1311  * to wait up to @a ms milliseconds to perform the requested operation.</div><div id="1312" class="line none"> 1312  *</div><div id="1313" class="line none"> 1313  * @param ms Duration in milliseconds.</div><div id="1314" class="line none"> 1314  *</div><div id="1315" class="line none"> 1315  * @return Timeout delay value.</div><div id="1316" class="line none"> 1316  */</div><div id="1317" class="line none"> 1317 #define <a href="kernel.h.html#1317">K_MSEC</a>(ms)     Z_TIMEOUT_MS(ms)</div><div id="1318" class="line none"> 1318 </div><div id="1319" class="line none"> 1319 /**</div><div id="1320" class="line none"> 1320  * @brief Generate timeout delay from seconds.</div><div id="1321" class="line none"> 1321  *</div><div id="1322" class="line none"> 1322  * This macro generates a timeout delay that instructs a kernel API</div><div id="1323" class="line none"> 1323  * to wait up to @a s seconds to perform the requested operation.</div><div id="1324" class="line none"> 1324  *</div><div id="1325" class="line none"> 1325  * @param s Duration in seconds.</div><div id="1326" class="line none"> 1326  *</div><div id="1327" class="line none"> 1327  * @return Timeout delay value.</div><div id="1328" class="line none"> 1328  */</div><div id="1329" class="line none"> 1329 #define <a href="kernel.h.html#1329">K_SECONDS</a>(s)   <a href="kernel.h.html#1317">K_MSEC</a>((s) * MSEC_PER_SEC)</div><div id="1330" class="line none"> 1330 </div><div id="1331" class="line none"> 1331 /**</div><div id="1332" class="line none"> 1332  * @brief Generate timeout delay from minutes.</div><div id="1333" class="line none"> 1333 </div><div id="1334" class="line none"> 1334  * This macro generates a timeout delay that instructs a kernel API</div><div id="1335" class="line none"> 1335  * to wait up to @a m minutes to perform the requested operation.</div><div id="1336" class="line none"> 1336  *</div><div id="1337" class="line none"> 1337  * @param m Duration in minutes.</div><div id="1338" class="line none"> 1338  *</div><div id="1339" class="line none"> 1339  * @return Timeout delay value.</div><div id="1340" class="line none"> 1340  */</div><div id="1341" class="line none"> 1341 #define <a href="kernel.h.html#1341">K_MINUTES</a>(m)   <a href="kernel.h.html#1329">K_SECONDS</a>((m) * 60)</div><div id="1342" class="line none"> 1342 </div><div id="1343" class="line none"> 1343 /**</div><div id="1344" class="line none"> 1344  * @brief Generate timeout delay from hours.</div><div id="1345" class="line none"> 1345  *</div><div id="1346" class="line none"> 1346  * This macro generates a timeout delay that instructs a kernel API</div><div id="1347" class="line none"> 1347  * to wait up to @a h hours to perform the requested operation.</div><div id="1348" class="line none"> 1348  *</div><div id="1349" class="line none"> 1349  * @param h Duration in hours.</div><div id="1350" class="line none"> 1350  *</div><div id="1351" class="line none"> 1351  * @return Timeout delay value.</div><div id="1352" class="line none"> 1352  */</div><div id="1353" class="line none"> 1353 #define <a href="kernel.h.html#1353">K_HOURS</a>(h)     <a href="kernel.h.html#1341">K_MINUTES</a>((h) * 60)</div><div id="1354" class="line none"> 1354 </div><div id="1355" class="line none"> 1355 /**</div><div id="1356" class="line none"> 1356  * @brief Generate infinite timeout delay.</div><div id="1357" class="line none"> 1357  *</div><div id="1358" class="line none"> 1358  * This macro generates a timeout delay that instructs a kernel API</div><div id="1359" class="line none"> 1359  * to wait as long as necessary to perform the requested operation.</div><div id="1360" class="line none"> 1360  *</div><div id="1361" class="line none"> 1361  * @return Timeout delay value.</div><div id="1362" class="line none"> 1362  */</div><div id="1363" class="line none"> 1363 #define <a href="kernel.h.html#1363">K_FOREVER</a> Z_FOREVER</div><div id="1364" class="line none"> 1364 </div><div id="1365" class="line none"> 1365 #ifdef CONFIG_TIMEOUT_64BIT</div><div id="1366" class="line none"> 1366 </div><div id="1367" class="line none"> 1367 /**</div><div id="1368" class="line none"> 1368  * @brief Generates an absolute/uptime timeout value from system ticks</div><div id="1369" class="line none"> 1369  *</div><div id="1370" class="line none"> 1370  * This macro generates a timeout delay that represents an expiration</div><div id="1371" class="line none"> 1371  * at the absolute uptime value specified, in system ticks.  That is, the</div><div id="1372" class="line none"> 1372  * timeout will expire immediately after the system uptime reaches the</div><div id="1373" class="line none"> 1373  * specified tick count.</div><div id="1374" class="line none"> 1374  *</div><div id="1375" class="line none"> 1375  * @param t Tick uptime value</div><div id="1376" class="line none"> 1376  * @return Timeout delay value</div><div id="1377" class="line none"> 1377  */</div><div id="1378" class="line none"> 1378 #define <a href="kernel.h.html#1378">K_TIMEOUT_ABS_TICKS</a>(t) \</div><div id="1379" class="line none"> 1379         Z_TIMEOUT_TICKS(Z_TICK_ABS((k_ticks_t)MAX(t, 0)))</div><div id="1380" class="line none"> 1380 </div><div id="1381" class="line none"> 1381 /**</div><div id="1382" class="line none"> 1382  * @brief Generates an absolute/uptime timeout value from milliseconds</div><div id="1383" class="line none"> 1383  *</div><div id="1384" class="line none"> 1384  * This macro generates a timeout delay that represents an expiration</div><div id="1385" class="line none"> 1385  * at the absolute uptime value specified, in milliseconds.  That is,</div><div id="1386" class="line none"> 1386  * the timeout will expire immediately after the system uptime reaches</div><div id="1387" class="line none"> 1387  * the specified tick count.</div><div id="1388" class="line none"> 1388  *</div><div id="1389" class="line none"> 1389  * @param t Millisecond uptime value</div><div id="1390" class="line none"> 1390  * @return Timeout delay value</div><div id="1391" class="line none"> 1391  */</div><div id="1392" class="line none"> 1392 #define <a href="kernel.h.html#1392">K_TIMEOUT_ABS_MS</a>(t) <a href="kernel.h.html#1378">K_TIMEOUT_ABS_TICKS</a>(k_ms_to_ticks_ceil64(t))</div><div id="1393" class="line none"> 1393 </div><div id="1394" class="line none"> 1394 /**</div><div id="1395" class="line none"> 1395  * @brief Generates an absolute/uptime timeout value from microseconds</div><div id="1396" class="line none"> 1396  *</div><div id="1397" class="line none"> 1397  * This macro generates a timeout delay that represents an expiration</div><div id="1398" class="line none"> 1398  * at the absolute uptime value specified, in microseconds.  That is,</div><div id="1399" class="line none"> 1399  * the timeout will expire immediately after the system uptime reaches</div><div id="1400" class="line none"> 1400  * the specified time.  Note that timer precision is limited by the</div><div id="1401" class="line none"> 1401  * system tick rate and not the requested timeout value.</div><div id="1402" class="line none"> 1402  *</div><div id="1403" class="line none"> 1403  * @param t Microsecond uptime value</div><div id="1404" class="line none"> 1404  * @return Timeout delay value</div><div id="1405" class="line none"> 1405  */</div><div id="1406" class="line none"> 1406 #define <a href="kernel.h.html#1406">K_TIMEOUT_ABS_US</a>(t) <a href="kernel.h.html#1378">K_TIMEOUT_ABS_TICKS</a>(k_us_to_ticks_ceil64(t))</div><div id="1407" class="line none"> 1407 </div><div id="1408" class="line none"> 1408 /**</div><div id="1409" class="line none"> 1409  * @brief Generates an absolute/uptime timeout value from nanoseconds</div><div id="1410" class="line none"> 1410  *</div><div id="1411" class="line none"> 1411  * This macro generates a timeout delay that represents an expiration</div><div id="1412" class="line none"> 1412  * at the absolute uptime value specified, in nanoseconds.  That is,</div><div id="1413" class="line none"> 1413  * the timeout will expire immediately after the system uptime reaches</div><div id="1414" class="line none"> 1414  * the specified time.  Note that timer precision is limited by the</div><div id="1415" class="line none"> 1415  * system tick rate and not the requested timeout value.</div><div id="1416" class="line none"> 1416  *</div><div id="1417" class="line none"> 1417  * @param t Nanosecond uptime value</div><div id="1418" class="line none"> 1418  * @return Timeout delay value</div><div id="1419" class="line none"> 1419  */</div><div id="1420" class="line none"> 1420 #define <a href="kernel.h.html#1420">K_TIMEOUT_ABS_NS</a>(t) <a href="kernel.h.html#1378">K_TIMEOUT_ABS_TICKS</a>(k_ns_to_ticks_ceil64(t))</div><div id="1421" class="line none"> 1421 </div><div id="1422" class="line none"> 1422 /**</div><div id="1423" class="line none"> 1423  * @brief Generates an absolute/uptime timeout value from system cycles</div><div id="1424" class="line none"> 1424  *</div><div id="1425" class="line none"> 1425  * This macro generates a timeout delay that represents an expiration</div><div id="1426" class="line none"> 1426  * at the absolute uptime value specified, in cycles.  That is, the</div><div id="1427" class="line none"> 1427  * timeout will expire immediately after the system uptime reaches the</div><div id="1428" class="line none"> 1428  * specified time.  Note that timer precision is limited by the system</div><div id="1429" class="line none"> 1429  * tick rate and not the requested timeout value.</div><div id="1430" class="line none"> 1430  *</div><div id="1431" class="line none"> 1431  * @param t Cycle uptime value</div><div id="1432" class="line none"> 1432  * @return Timeout delay value</div><div id="1433" class="line none"> 1433  */</div><div id="1434" class="line none"> 1434 #define <a href="kernel.h.html#1434">K_TIMEOUT_ABS_CYC</a>(t) <a href="kernel.h.html#1378">K_TIMEOUT_ABS_TICKS</a>(k_cyc_to_ticks_ceil64(t))</div><div id="1435" class="line none"> 1435 </div><div id="1436" class="line none"> 1436 #endif</div><div id="1437" class="line none"> 1437 </div><div id="1438" class="line none"> 1438 /**</div><div id="1439" class="line none"> 1439  * @}</div><div id="1440" class="line none"> 1440  */</div><div id="1441" class="line none"> 1441 </div><div id="1442" class="line none"> 1442 /**</div><div id="1443" class="line none"> 1443  * @cond INTERNAL_HIDDEN</div><div id="1444" class="line none"> 1444  */</div><div id="1445" class="line none"> 1445 </div><div id="1446" class="line none"> 1446 struct <a href="kernel.h.html#1446">k_timer</a> {</div><div id="1447" class="line none"> 1447         /*</div><div id="1448" class="line none"> 1448          * _timeout structure must be first here if we want to use</div><div id="1449" class="line none"> 1449          * dynamic timer allocation. timeout.node is used in the double-linked</div><div id="1450" class="line none"> 1450          * list of free timers</div><div id="1451" class="line none"> 1451          */</div><div id="1452" class="line none"> 1452         struct <a href="kernel_structs.h.html#293">_timeout</a> <a href="kernel.h.html#1452">timeout</a>;</div><div id="1453" class="line none"> 1453 </div><div id="1454" class="line none"> 1454         /* wait queue for the (single) thread waiting on this timer */</div><div id="1455" class="line none"> 1455         <a href="kernel_structs.h.html#286">_wait_q_t</a> <a href="kernel.h.html#1455">wait_q</a>;</div><div id="1456" class="line none"> 1456 </div><div id="1457" class="line none"> 1457         /* runs in ISR context */</div><div id="1458" class="line none"> 1458         void (*<a href="kernel.h.html#1458">expiry_fn</a>)(struct <a href="kernel.h.html#1446">k_timer</a> *timer);</div><div id="1459" class="line none"> 1459 </div><div id="1460" class="line none"> 1460         /* runs in the context of the thread that calls k_timer_stop() */</div><div id="1461" class="line none"> 1461         void (*<a href="kernel.h.html#1461">stop_fn</a>)(struct <a href="kernel.h.html#1446">k_timer</a> *timer);</div><div id="1462" class="line none"> 1462 </div><div id="1463" class="line none"> 1463         /* timer period */</div><div id="1464" class="line none"> 1464         k_timeout_t <a href="kernel.h.html#1464">period</a>;</div><div id="1465" class="line none"> 1465 </div><div id="1466" class="line none"> 1466         /* timer status */</div><div id="1467" class="line none"> 1467         uint32_t <a href="kernel.h.html#1467">status</a>;</div><div id="1468" class="line none"> 1468 </div><div id="1469" class="line none"> 1469         /* user-specific data, also used to support legacy features */</div><div id="1470" class="line none"> 1470         void *<a href="kernel.h.html#1470">user_data</a>;</div><div id="1471" class="line none"> 1471 </div><div id="1472" class="line none"> 1472         SYS_PORT_TRACING_TRACKING_FIELD(<a href="kernel.h.html#1446">k_timer</a>)</div><div id="1473" class="line none"> 1473 </div><div id="1474" class="line none"> 1474 #ifdef CONFIG_OBJ_CORE_TIMER</div><div id="1475" class="line none"> 1475         struct k_obj_core  <a href="kernel.h.html#1475">obj_core</a>;</div><div id="1476" class="line none"> 1476 #endif</div><div id="1477" class="line none"> 1477 };</div><div id="1478" class="line none"> 1478 </div><div id="1479" class="line none"> 1479 #define <a href="kernel.h.html#1479">Z_TIMER_INITIALIZER</a>(<a href="kernel.h.html#5739">obj</a>, expiry, stop) \</div><div id="1480" class="line none"> 1480         { \</div><div id="1481" class="line none"> 1481         .<a href="kernel.h.html#1452">timeout</a> = { \</div><div id="1482" class="line none"> 1482                 .<a href="kernel.h.html#3883">node</a> = {},\</div><div id="1483" class="line none"> 1483                 .<a href="kernel_structs.h.html#298">fn</a> = z_timer_expiration_handler, \</div><div id="1484" class="line none"> 1484                 .<a href="kernel_structs.h.html#301">dticks</a> = 0, \</div><div id="1485" class="line none"> 1485         }, \</div><div id="1486" class="line none"> 1486         .<a href="kernel.h.html#1455">wait_q</a> = <a href="kernel_structs.h.html#280">Z_WAIT_Q_INIT</a>(&amp;<a href="kernel.h.html#5739">obj</a>.<a href="kernel.h.html#1455">wait_q</a>), \</div><div id="1487" class="line none"> 1487         .<a href="kernel.h.html#1458">expiry_fn</a> = expiry, \</div><div id="1488" class="line none"> 1488         .<a href="kernel.h.html#1461">stop_fn</a> = stop, \</div><div id="1489" class="line none"> 1489         .<a href="kernel.h.html#1467">status</a> = 0, \</div><div id="1490" class="line none"> 1490         .<a href="kernel.h.html#1470">user_data</a> = 0, \</div><div id="1491" class="line none"> 1491         }</div><div id="1492" class="line none"> 1492 </div><div id="1493" class="line none"> 1493 /**</div><div id="1494" class="line none"> 1494  * INTERNAL_HIDDEN @endcond</div><div id="1495" class="line none"> 1495  */</div><div id="1496" class="line none"> 1496 </div><div id="1497" class="line none"> 1497 /**</div><div id="1498" class="line none"> 1498  * @defgroup timer_apis Timer APIs</div><div id="1499" class="line none"> 1499  * @ingroup kernel_apis</div><div id="1500" class="line none"> 1500  * @{</div><div id="1501" class="line none"> 1501  */</div><div id="1502" class="line none"> 1502 </div><div id="1503" class="line none"> 1503 /**</div><div id="1504" class="line none"> 1504  * @typedef k_timer_expiry_t</div><div id="1505" class="line none"> 1505  * @brief Timer expiry function type.</div><div id="1506" class="line none"> 1506  *</div><div id="1507" class="line none"> 1507  * A timer's expiry function is executed by the system clock interrupt handler</div><div id="1508" class="line none"> 1508  * each time the timer expires. The expiry function is optional, and is only</div><div id="1509" class="line none"> 1509  * invoked if the timer has been initialized with one.</div><div id="1510" class="line none"> 1510  *</div><div id="1511" class="line none"> 1511  * @param timer     Address of timer.</div><div id="1512" class="line none"> 1512  */</div><div id="1513" class="line none"> 1513 typedef void (*<a href="kernel.h.html#1513">k_timer_expiry_t</a>)(struct <a href="kernel.h.html#1446">k_timer</a> *timer);</div><div id="1514" class="line none"> 1514 </div><div id="1515" class="line none"> 1515 /**</div><div id="1516" class="line none"> 1516  * @typedef k_timer_stop_t</div><div id="1517" class="line none"> 1517  * @brief Timer stop function type.</div><div id="1518" class="line none"> 1518  *</div><div id="1519" class="line none"> 1519  * A timer's stop function is executed if the timer is stopped prematurely.</div><div id="1520" class="line none"> 1520  * The function runs in the context of call that stops the timer.  As</div><div id="1521" class="line none"> 1521  * k_timer_stop() can be invoked from an ISR, the stop function must be</div><div id="1522" class="line none"> 1522  * callable from interrupt context (isr-ok).</div><div id="1523" class="line none"> 1523  *</div><div id="1524" class="line none"> 1524  * The stop function is optional, and is only invoked if the timer has been</div><div id="1525" class="line none"> 1525  * initialized with one.</div><div id="1526" class="line none"> 1526  *</div><div id="1527" class="line none"> 1527  * @param timer     Address of timer.</div><div id="1528" class="line none"> 1528  */</div><div id="1529" class="line none"> 1529 typedef void (*<a href="kernel.h.html#1529">k_timer_stop_t</a>)(struct <a href="kernel.h.html#1446">k_timer</a> *timer);</div><div id="1530" class="line none"> 1530 </div><div id="1531" class="line none"> 1531 /**</div><div id="1532" class="line none"> 1532  * @brief Statically define and initialize a timer.</div><div id="1533" class="line none"> 1533  *</div><div id="1534" class="line none"> 1534  * The timer can be accessed outside the module where it is defined using:</div><div id="1535" class="line none"> 1535  *</div><div id="1536" class="line none"> 1536  * @code extern struct k_timer &lt;name&gt;; @endcode</div><div id="1537" class="line none"> 1537  *</div><div id="1538" class="line none"> 1538  * @param name Name of the timer variable.</div><div id="1539" class="line none"> 1539  * @param expiry_fn Function to invoke each time the timer expires.</div><div id="1540" class="line none"> 1540  * @param stop_fn   Function to invoke if the timer is stopped while running.</div><div id="1541" class="line none"> 1541  */</div><div id="1542" class="line none"> 1542 #define <a href="kernel.h.html#1542">K_TIMER_DEFINE</a>(<a href="kernel.h.html#4006">name</a>, <a href="kernel.h.html#1458">expiry_fn</a>, <a href="kernel.h.html#1461">stop_fn</a>) \</div><div id="1543" class="line none"> 1543         STRUCT_SECTION_ITERABLE(<a href="kernel.h.html#1446">k_timer</a>, <a href="kernel.h.html#4006">name</a>) = \</div><div id="1544" class="line none"> 1544                 <a href="kernel.h.html#1479">Z_TIMER_INITIALIZER</a>(<a href="kernel.h.html#4006">name</a>, <a href="kernel.h.html#1458">expiry_fn</a>, <a href="kernel.h.html#1461">stop_fn</a>)</div><div id="1545" class="line none"> 1545 </div><div id="1546" class="line none"> 1546 /**</div><div id="1547" class="line none"> 1547  * @brief Initialize a timer.</div><div id="1548" class="line none"> 1548  *</div><div id="1549" class="line none"> 1549  * This routine initializes a timer, prior to its first use.</div><div id="1550" class="line none"> 1550  *</div><div id="1551" class="line none"> 1551  * @param timer     Address of timer.</div><div id="1552" class="line none"> 1552  * @param expiry_fn Function to invoke each time the timer expires.</div><div id="1553" class="line none"> 1553  * @param stop_fn   Function to invoke if the timer is stopped while running.</div><div id="1554" class="line none"> 1554  */</div><div id="1555" class="line none"> 1555 void k_timer_init(struct <a href="kernel.h.html#1446">k_timer</a> *timer,</div><div id="1556" class="line none"> 1556                          <a href="kernel.h.html#1513">k_timer_expiry_t</a> <a href="kernel.h.html#1458">expiry_fn</a>,</div><div id="1557" class="line none"> 1557                          <a href="kernel.h.html#1529">k_timer_stop_t</a> <a href="kernel.h.html#1461">stop_fn</a>);</div><div id="1558" class="line none"> 1558 </div><div id="1559" class="line none"> 1559 /**</div><div id="1560" class="line none"> 1560  * @brief Start a timer.</div><div id="1561" class="line none"> 1561  *</div><div id="1562" class="line none"> 1562  * This routine starts a timer, and resets its status to zero. The timer</div><div id="1563" class="line none"> 1563  * begins counting down using the specified duration and period values.</div><div id="1564" class="line none"> 1564  *</div><div id="1565" class="line none"> 1565  * Attempting to start a timer that is already running is permitted.</div><div id="1566" class="line none"> 1566  * The timer's status is reset to zero and the timer begins counting down</div><div id="1567" class="line none"> 1567  * using the new duration and period values.</div><div id="1568" class="line none"> 1568  *</div><div id="1569" class="line none"> 1569  * @param timer     Address of timer.</div><div id="1570" class="line none"> 1570  * @param duration  Initial timer duration.</div><div id="1571" class="line none"> 1571  * @param period    Timer period.</div><div id="1572" class="line none"> 1572  */</div><div id="1573" class="line none"> 1573 __syscall void k_timer_start(struct <a href="kernel.h.html#1446">k_timer</a> *timer,</div><div id="1574" class="line none"> 1574                              k_timeout_t duration, k_timeout_t <a href="kernel.h.html#1464">period</a>);</div><div id="1575" class="line none"> 1575 </div><div id="1576" class="line none"> 1576 /**</div><div id="1577" class="line none"> 1577  * @brief Stop a timer.</div><div id="1578" class="line none"> 1578  *</div><div id="1579" class="line none"> 1579  * This routine stops a running timer prematurely. The timer's stop function,</div><div id="1580" class="line none"> 1580  * if one exists, is invoked by the caller.</div><div id="1581" class="line none"> 1581  *</div><div id="1582" class="line none"> 1582  * Attempting to stop a timer that is not running is permitted, but has no</div><div id="1583" class="line none"> 1583  * effect on the timer.</div><div id="1584" class="line none"> 1584  *</div><div id="1585" class="line none"> 1585  * @note The stop handler has to be callable from ISRs if @a k_timer_stop is to</div><div id="1586" class="line none"> 1586  * be called from ISRs.</div><div id="1587" class="line none"> 1587  *</div><div id="1588" class="line none"> 1588  * @funcprops \isr_ok</div><div id="1589" class="line none"> 1589  *</div><div id="1590" class="line none"> 1590  * @param timer     Address of timer.</div><div id="1591" class="line none"> 1591  */</div><div id="1592" class="line none"> 1592 __syscall void k_timer_stop(struct <a href="kernel.h.html#1446">k_timer</a> *timer);</div><div id="1593" class="line none"> 1593 </div><div id="1594" class="line none"> 1594 /**</div><div id="1595" class="line none"> 1595  * @brief Read timer status.</div><div id="1596" class="line none"> 1596  *</div><div id="1597" class="line none"> 1597  * This routine reads the timer's status, which indicates the number of times</div><div id="1598" class="line none"> 1598  * it has expired since its status was last read.</div><div id="1599" class="line none"> 1599  *</div><div id="1600" class="line none"> 1600  * Calling this routine resets the timer's status to zero.</div><div id="1601" class="line none"> 1601  *</div><div id="1602" class="line none"> 1602  * @param timer     Address of timer.</div><div id="1603" class="line none"> 1603  *</div><div id="1604" class="line none"> 1604  * @return Timer status.</div><div id="1605" class="line none"> 1605  */</div><div id="1606" class="line none"> 1606 __syscall uint32_t k_timer_status_get(struct <a href="kernel.h.html#1446">k_timer</a> *timer);</div><div id="1607" class="line none"> 1607 </div><div id="1608" class="line none"> 1608 /**</div><div id="1609" class="line none"> 1609  * @brief Synchronize thread to timer expiration.</div><div id="1610" class="line none"> 1610  *</div><div id="1611" class="line none"> 1611  * This routine blocks the calling thread until the timer's status is non-zero</div><div id="1612" class="line none"> 1612  * (indicating that it has expired at least once since it was last examined)</div><div id="1613" class="line none"> 1613  * or the timer is stopped. If the timer status is already non-zero,</div><div id="1614" class="line none"> 1614  * or the timer is already stopped, the caller continues without waiting.</div><div id="1615" class="line none"> 1615  *</div><div id="1616" class="line none"> 1616  * Calling this routine resets the timer's status to zero.</div><div id="1617" class="line none"> 1617  *</div><div id="1618" class="line none"> 1618  * This routine must not be used by interrupt handlers, since they are not</div><div id="1619" class="line none"> 1619  * allowed to block.</div><div id="1620" class="line none"> 1620  *</div><div id="1621" class="line none"> 1621  * @param timer     Address of timer.</div><div id="1622" class="line none"> 1622  *</div><div id="1623" class="line none"> 1623  * @return Timer status.</div><div id="1624" class="line none"> 1624  */</div><div id="1625" class="line none"> 1625 __syscall uint32_t k_timer_status_sync(struct <a href="kernel.h.html#1446">k_timer</a> *timer);</div><div id="1626" class="line none"> 1626 </div><div id="1627" class="line none"> 1627 #ifdef CONFIG_SYS_CLOCK_EXISTS</div><div id="1628" class="line none"> 1628 </div><div id="1629" class="line none"> 1629 /**</div><div id="1630" class="line none"> 1630  * @brief Get next expiration time of a timer, in system ticks</div><div id="1631" class="line none"> 1631  *</div><div id="1632" class="line none"> 1632  * This routine returns the future system uptime reached at the next</div><div id="1633" class="line none"> 1633  * time of expiration of the timer, in units of system ticks.  If the</div><div id="1634" class="line none"> 1634  * timer is not running, current system time is returned.</div><div id="1635" class="line none"> 1635  *</div><div id="1636" class="line none"> 1636  * @param timer The timer object</div><div id="1637" class="line none"> 1637  * @return Uptime of expiration, in ticks</div><div id="1638" class="line none"> 1638  */</div><div id="1639" class="line none"> 1639 __syscall k_ticks_t k_timer_expires_ticks(const struct <a href="kernel.h.html#1446">k_timer</a> *timer);</div><div id="1640" class="line none"> 1640 </div><div id="1641" class="line none"> 1641 static inline k_ticks_t <a href="kernel.h.html#1641">z_impl_k_timer_expires_ticks</a>(</div><div id="1642" class="line none"> 1642                                        const struct <a href="kernel.h.html#1446">k_timer</a> *timer)</div><div id="1643" class="line none"> 1643 {</div><div id="1644" class="line none"> 1644         return z_timeout_expires(&amp;timer-&gt;<a href="kernel.h.html#1452">timeout</a>);</div><div id="1645" class="line none"> 1645 }</div><div id="1646" class="line none"> 1646 </div><div id="1647" class="line none"> 1647 /**</div><div id="1648" class="line none"> 1648  * @brief Get time remaining before a timer next expires, in system ticks</div><div id="1649" class="line none"> 1649  *</div><div id="1650" class="line none"> 1650  * This routine computes the time remaining before a running timer</div><div id="1651" class="line none"> 1651  * next expires, in units of system ticks.  If the timer is not</div><div id="1652" class="line none"> 1652  * running, it returns zero.</div><div id="1653" class="line none"> 1653  */</div><div id="1654" class="line none"> 1654 __syscall k_ticks_t k_timer_remaining_ticks(const struct <a href="kernel.h.html#1446">k_timer</a> *timer);</div><div id="1655" class="line none"> 1655 </div><div id="1656" class="line none"> 1656 static inline k_ticks_t <a href="kernel.h.html#1656">z_impl_k_timer_remaining_ticks</a>(</div><div id="1657" class="line none"> 1657                                        const struct <a href="kernel.h.html#1446">k_timer</a> *timer)</div><div id="1658" class="line none"> 1658 {</div><div id="1659" class="line none"> 1659         return z_timeout_remaining(&amp;timer-&gt;<a href="kernel.h.html#1452">timeout</a>);</div><div id="1660" class="line none"> 1660 }</div><div id="1661" class="line none"> 1661 </div><div id="1662" class="line none"> 1662 /**</div><div id="1663" class="line none"> 1663  * @brief Get time remaining before a timer next expires.</div><div id="1664" class="line none"> 1664  *</div><div id="1665" class="line none"> 1665  * This routine computes the (approximate) time remaining before a running</div><div id="1666" class="line none"> 1666  * timer next expires. If the timer is not running, it returns zero.</div><div id="1667" class="line none"> 1667  *</div><div id="1668" class="line none"> 1668  * @param timer     Address of timer.</div><div id="1669" class="line none"> 1669  *</div><div id="1670" class="line none"> 1670  * @return Remaining time (in milliseconds).</div><div id="1671" class="line none"> 1671  */</div><div id="1672" class="line none"> 1672 static inline uint32_t <a href="kernel.h.html#1672">k_timer_remaining_get</a>(struct <a href="kernel.h.html#1446">k_timer</a> *timer)</div><div id="1673" class="line none"> 1673 {</div><div id="1674" class="line none"> 1674         return k_ticks_to_ms_floor32(k_timer_remaining_ticks(timer));</div><div id="1675" class="line none"> 1675 }</div><div id="1676" class="line none"> 1676 </div><div id="1677" class="line none"> 1677 #endif /* CONFIG_SYS_CLOCK_EXISTS */</div><div id="1678" class="line none"> 1678 </div><div id="1679" class="line none"> 1679 /**</div><div id="1680" class="line none"> 1680  * @brief Associate user-specific data with a timer.</div><div id="1681" class="line none"> 1681  *</div><div id="1682" class="line none"> 1682  * This routine records the @a user_data with the @a timer, to be retrieved</div><div id="1683" class="line none"> 1683  * later.</div><div id="1684" class="line none"> 1684  *</div><div id="1685" class="line none"> 1685  * It can be used e.g. in a timer handler shared across multiple subsystems to</div><div id="1686" class="line none"> 1686  * retrieve data specific to the subsystem this timer is associated with.</div><div id="1687" class="line none"> 1687  *</div><div id="1688" class="line none"> 1688  * @param timer     Address of timer.</div><div id="1689" class="line none"> 1689  * @param user_data User data to associate with the timer.</div><div id="1690" class="line none"> 1690  */</div><div id="1691" class="line none"> 1691 __syscall void k_timer_user_data_set(struct <a href="kernel.h.html#1446">k_timer</a> *timer, void *<a href="kernel.h.html#1470">user_data</a>);</div><div id="1692" class="line none"> 1692 </div><div id="1693" class="line none"> 1693 /**</div><div id="1694" class="line none"> 1694  * @internal</div><div id="1695" class="line none"> 1695  */</div><div id="1696" class="line none"> 1696 static inline void <a href="kernel.h.html#1696">z_impl_k_timer_user_data_set</a>(struct <a href="kernel.h.html#1446">k_timer</a> *timer,</div><div id="1697" class="line none"> 1697                                                void *<a href="kernel.h.html#1470">user_data</a>)</div><div id="1698" class="line none"> 1698 {</div><div id="1699" class="line none"> 1699         timer-&gt;<a href="kernel.h.html#1470">user_data</a> = <a href="kernel.h.html#1470">user_data</a>;</div><div id="1700" class="line none"> 1700 }</div><div id="1701" class="line none"> 1701 </div><div id="1702" class="line none"> 1702 /**</div><div id="1703" class="line none"> 1703  * @brief Retrieve the user-specific data from a timer.</div><div id="1704" class="line none"> 1704  *</div><div id="1705" class="line none"> 1705  * @param timer     Address of timer.</div><div id="1706" class="line none"> 1706  *</div><div id="1707" class="line none"> 1707  * @return The user data.</div><div id="1708" class="line none"> 1708  */</div><div id="1709" class="line none"> 1709 __syscall void *k_timer_user_data_get(const struct <a href="kernel.h.html#1446">k_timer</a> *timer);</div><div id="1710" class="line none"> 1710 </div><div id="1711" class="line none"> 1711 static inline void *<a href="kernel.h.html#1711">z_impl_k_timer_user_data_get</a>(const struct <a href="kernel.h.html#1446">k_timer</a> *timer)</div><div id="1712" class="line none"> 1712 {</div><div id="1713" class="line none"> 1713         return timer-&gt;<a href="kernel.h.html#1470">user_data</a>;</div><div id="1714" class="line none"> 1714 }</div><div id="1715" class="line none"> 1715 </div><div id="1716" class="line none"> 1716 /** @} */</div><div id="1717" class="line none"> 1717 </div><div id="1718" class="line none"> 1718 /**</div><div id="1719" class="line none"> 1719  * @addtogroup clock_apis</div><div id="1720" class="line none"> 1720  * @ingroup kernel_apis</div><div id="1721" class="line none"> 1721  * @{</div><div id="1722" class="line none"> 1722  */</div><div id="1723" class="line none"> 1723 </div><div id="1724" class="line none"> 1724 /**</div><div id="1725" class="line none"> 1725  * @brief Get system uptime, in system ticks.</div><div id="1726" class="line none"> 1726  *</div><div id="1727" class="line none"> 1727  * This routine returns the elapsed time since the system booted, in</div><div id="1728" class="line none"> 1728  * ticks (c.f. @kconfig{CONFIG_SYS_CLOCK_TICKS_PER_SEC}), which is the</div><div id="1729" class="line none"> 1729  * fundamental unit of resolution of kernel timekeeping.</div><div id="1730" class="line none"> 1730  *</div><div id="1731" class="line none"> 1731  * @return Current uptime in ticks.</div><div id="1732" class="line none"> 1732  */</div><div id="1733" class="line none"> 1733 __syscall int64_t k_uptime_ticks(void);</div><div id="1734" class="line none"> 1734 </div><div id="1735" class="line none"> 1735 /**</div><div id="1736" class="line none"> 1736  * @brief Get system uptime.</div><div id="1737" class="line none"> 1737  *</div><div id="1738" class="line none"> 1738  * This routine returns the elapsed time since the system booted,</div><div id="1739" class="line none"> 1739  * in milliseconds.</div><div id="1740" class="line none"> 1740  *</div><div id="1741" class="line none"> 1741  * @note</div><div id="1742" class="line none"> 1742  *    While this function returns time in milliseconds, it does</div><div id="1743" class="line none"> 1743  *    not mean it has millisecond resolution. The actual resolution depends on</div><div id="1744" class="line none"> 1744  *    @kconfig{CONFIG_SYS_CLOCK_TICKS_PER_SEC} config option.</div><div id="1745" class="line none"> 1745  *</div><div id="1746" class="line none"> 1746  * @return Current uptime in milliseconds.</div><div id="1747" class="line none"> 1747  */</div><div id="1748" class="line none"> 1748 static inline int64_t <a href="kernel.h.html#1748">k_uptime_get</a>(void)</div><div id="1749" class="line none"> 1749 {</div><div id="1750" class="line none"> 1750         return k_ticks_to_ms_floor64(k_uptime_ticks());</div><div id="1751" class="line none"> 1751 }</div><div id="1752" class="line none"> 1752 </div><div id="1753" class="line none"> 1753 /**</div><div id="1754" class="line none"> 1754  * @brief Get system uptime (32-bit version).</div><div id="1755" class="line none"> 1755  *</div><div id="1756" class="line none"> 1756  * This routine returns the lower 32 bits of the system uptime in</div><div id="1757" class="line none"> 1757  * milliseconds.</div><div id="1758" class="line none"> 1758  *</div><div id="1759" class="line none"> 1759  * Because correct conversion requires full precision of the system</div><div id="1760" class="line none"> 1760  * clock there is no benefit to using this over k_uptime_get() unless</div><div id="1761" class="line none"> 1761  * you know the application will never run long enough for the system</div><div id="1762" class="line none"> 1762  * clock to approach 2^32 ticks.  Calls to this function may involve</div><div id="1763" class="line none"> 1763  * interrupt blocking and 64-bit math.</div><div id="1764" class="line none"> 1764  *</div><div id="1765" class="line none"> 1765  * @note</div><div id="1766" class="line none"> 1766  *    While this function returns time in milliseconds, it does</div><div id="1767" class="line none"> 1767  *    not mean it has millisecond resolution. The actual resolution depends on</div><div id="1768" class="line none"> 1768  *    @kconfig{CONFIG_SYS_CLOCK_TICKS_PER_SEC} config option</div><div id="1769" class="line none"> 1769  *</div><div id="1770" class="line none"> 1770  * @return The low 32 bits of the current uptime, in milliseconds.</div><div id="1771" class="line none"> 1771  */</div><div id="1772" class="line none"> 1772 static inline uint32_t <a href="kernel.h.html#1772">k_uptime_get_32</a>(void)</div><div id="1773" class="line none"> 1773 {</div><div id="1774" class="line none"> 1774         return (uint32_t)<a href="kernel.h.html#1748">k_uptime_get</a>();</div><div id="1775" class="line none"> 1775 }</div><div id="1776" class="line none"> 1776 </div><div id="1777" class="line none"> 1777 /**</div><div id="1778" class="line none"> 1778  * @brief Get system uptime in seconds.</div><div id="1779" class="line none"> 1779  *</div><div id="1780" class="line none"> 1780  * This routine returns the elapsed time since the system booted,</div><div id="1781" class="line none"> 1781  * in seconds.</div><div id="1782" class="line none"> 1782  *</div><div id="1783" class="line none"> 1783  * @return Current uptime in seconds.</div><div id="1784" class="line none"> 1784  */</div><div id="1785" class="line none"> 1785 static inline uint32_t <a href="kernel.h.html#1785">k_uptime_seconds</a>(void)</div><div id="1786" class="line none"> 1786 {</div><div id="1787" class="line none"> 1787         return k_ticks_to_sec_floor32(k_uptime_ticks());</div><div id="1788" class="line none"> 1788 }</div><div id="1789" class="line none"> 1789 </div><div id="1790" class="line none"> 1790 /**</div><div id="1791" class="line none"> 1791  * @brief Get elapsed time.</div><div id="1792" class="line none"> 1792  *</div><div id="1793" class="line none"> 1793  * This routine computes the elapsed time between the current system uptime</div><div id="1794" class="line none"> 1794  * and an earlier reference time, in milliseconds.</div><div id="1795" class="line none"> 1795  *</div><div id="1796" class="line none"> 1796  * @param reftime Pointer to a reference time, which is updated to the current</div><div id="1797" class="line none"> 1797  *                uptime upon return.</div><div id="1798" class="line none"> 1798  *</div><div id="1799" class="line none"> 1799  * @return Elapsed time.</div><div id="1800" class="line none"> 1800  */</div><div id="1801" class="line none"> 1801 static inline int64_t <a href="kernel.h.html#1801">k_uptime_delta</a>(int64_t *reftime)</div><div id="1802" class="line none"> 1802 {</div><div id="1803" class="line none"> 1803         int64_t uptime, <a href="kernel/thread.h.html#173">delta</a>;</div><div id="1804" class="line none"> 1804 </div><div id="1805" class="line none"> 1805         uptime = <a href="kernel.h.html#1748">k_uptime_get</a>();</div><div id="1806" class="line none"> 1806         <a href="kernel/thread.h.html#173">delta</a> = uptime - *reftime;</div><div id="1807" class="line none"> 1807         *reftime = uptime;</div><div id="1808" class="line none"> 1808 </div><div id="1809" class="line none"> 1809         return <a href="kernel/thread.h.html#173">delta</a>;</div><div id="1810" class="line none"> 1810 }</div><div id="1811" class="line none"> 1811 </div><div id="1812" class="line none"> 1812 /**</div><div id="1813" class="line none"> 1813  * @brief Read the hardware clock.</div><div id="1814" class="line none"> 1814  *</div><div id="1815" class="line none"> 1815  * This routine returns the current time, as measured by the system's hardware</div><div id="1816" class="line none"> 1816  * clock.</div><div id="1817" class="line none"> 1817  *</div><div id="1818" class="line none"> 1818  * @return Current hardware clock up-counter (in cycles).</div><div id="1819" class="line none"> 1819  */</div><div id="1820" class="line none"> 1820 static inline uint32_t <a href="kernel.h.html#1820">k_cycle_get_32</a>(void)</div><div id="1821" class="line none"> 1821 {</div><div id="1822" class="line none"> 1822         return arch_k_cycle_get_32();</div><div id="1823" class="line none"> 1823 }</div><div id="1824" class="line none"> 1824 </div><div id="1825" class="line none"> 1825 /**</div><div id="1826" class="line none"> 1826  * @brief Read the 64-bit hardware clock.</div><div id="1827" class="line none"> 1827  *</div><div id="1828" class="line none"> 1828  * This routine returns the current time in 64-bits, as measured by the</div><div id="1829" class="line none"> 1829  * system's hardware clock, if available.</div><div id="1830" class="line none"> 1830  *</div><div id="1831" class="line none"> 1831  * @see CONFIG_TIMER_HAS_64BIT_CYCLE_COUNTER</div><div id="1832" class="line none"> 1832  *</div><div id="1833" class="line none"> 1833  * @return Current hardware clock up-counter (in cycles).</div><div id="1834" class="line none"> 1834  */</div><div id="1835" class="line none"> 1835 static inline uint64_t <a href="kernel.h.html#1835">k_cycle_get_64</a>(void)</div><div id="1836" class="line none"> 1836 {</div><div id="1837" class="line none"> 1837         if (!IS_ENABLED(CONFIG_TIMER_HAS_64BIT_CYCLE_COUNTER)) {</div><div id="1838" class="line none"> 1838                 __ASSERT(0, "64-bit cycle counter not enabled on this platform. "</div><div id="1839" class="line none"> 1839                             "See CONFIG_TIMER_HAS_64BIT_CYCLE_COUNTER");</div><div id="1840" class="line none"> 1840                 return 0;</div><div id="1841" class="line none"> 1841         }</div><div id="1842" class="line none"> 1842 </div><div id="1843" class="line none"> 1843         return arch_k_cycle_get_64();</div><div id="1844" class="line none"> 1844 }</div><div id="1845" class="line none"> 1845 </div><div id="1846" class="line none"> 1846 /**</div><div id="1847" class="line none"> 1847  * @}</div><div id="1848" class="line none"> 1848  */</div><div id="1849" class="line none"> 1849 </div><div id="1850" class="line none"> 1850 struct <a href="kernel.h.html#1850">k_queue</a> {</div><div id="1851" class="line none"> 1851         sys_sflist_t <a href="kernel.h.html#1851">data_q</a>;</div><div id="1852" class="line none"> 1852         struct <a href="spinlock.h.html#45">k_spinlock</a> <a href="kernel.h.html#1852">lock</a>;</div><div id="1853" class="line none"> 1853         <a href="kernel_structs.h.html#286">_wait_q_t</a> <a href="kernel.h.html#1455">wait_q</a>;</div><div id="1854" class="line none"> 1854 </div><div id="1855" class="line none"> 1855         <a href="kernel.h.html#65">Z_DECL_POLL_EVENT</a></div><div id="1856" class="line none"> 1856 </div><div id="1857" class="line none"> 1857         SYS_PORT_TRACING_TRACKING_FIELD(<a href="kernel.h.html#1850">k_queue</a>)</div><div id="1858" class="line none"> 1858 };</div><div id="1859" class="line none"> 1859 </div><div id="1860" class="line none"> 1860 /**</div><div id="1861" class="line none"> 1861  * @cond INTERNAL_HIDDEN</div><div id="1862" class="line none"> 1862  */</div><div id="1863" class="line none"> 1863 </div><div id="1864" class="line none"> 1864 #define <a href="kernel.h.html#1864">Z_QUEUE_INITIALIZER</a>(<a href="kernel.h.html#5739">obj</a>) \</div><div id="1865" class="line none"> 1865         { \</div><div id="1866" class="line none"> 1866         .<a href="kernel.h.html#1851">data_q</a> = SYS_SFLIST_STATIC_INIT(&amp;<a href="kernel.h.html#5739">obj</a>.<a href="kernel.h.html#1851">data_q</a>), \</div><div id="1867" class="line none"> 1867         .<a href="kernel.h.html#1852">lock</a> = { }, \</div><div id="1868" class="line none"> 1868         .<a href="kernel.h.html#1455">wait_q</a> = <a href="kernel_structs.h.html#280">Z_WAIT_Q_INIT</a>(&amp;<a href="kernel.h.html#5739">obj</a>.<a href="kernel.h.html#1455">wait_q</a>),   \</div><div id="1869" class="line none"> 1869         <a href="kernel.h.html#63">Z_POLL_EVENT_OBJ_INIT</a>(<a href="kernel.h.html#5739">obj</a>)              \</div><div id="1870" class="line none"> 1870         }</div><div id="1871" class="line none"> 1871 </div><div id="1872" class="line none"> 1872 /**</div><div id="1873" class="line none"> 1873  * INTERNAL_HIDDEN @endcond</div><div id="1874" class="line none"> 1874  */</div><div id="1875" class="line none"> 1875 </div><div id="1876" class="line none"> 1876 /**</div><div id="1877" class="line none"> 1877  * @defgroup queue_apis Queue APIs</div><div id="1878" class="line none"> 1878  * @ingroup kernel_apis</div><div id="1879" class="line none"> 1879  * @{</div><div id="1880" class="line none"> 1880  */</div><div id="1881" class="line none"> 1881 </div><div id="1882" class="line none"> 1882 /**</div><div id="1883" class="line none"> 1883  * @brief Initialize a queue.</div><div id="1884" class="line none"> 1884  *</div><div id="1885" class="line none"> 1885  * This routine initializes a queue object, prior to its first use.</div><div id="1886" class="line none"> 1886  *</div><div id="1887" class="line none"> 1887  * @param queue Address of the queue.</div><div id="1888" class="line none"> 1888  */</div><div id="1889" class="line none"> 1889 __syscall void k_queue_init(struct <a href="kernel.h.html#1850">k_queue</a> *<a href="kernel.h.html#3889">queue</a>);</div><div id="1890" class="line none"> 1890 </div><div id="1891" class="line none"> 1891 /**</div><div id="1892" class="line none"> 1892  * @brief Cancel waiting on a queue.</div><div id="1893" class="line none"> 1893  *</div><div id="1894" class="line none"> 1894  * This routine causes first thread pending on @a queue, if any, to</div><div id="1895" class="line none"> 1895  * return from k_queue_get() call with NULL value (as if timeout expired).</div><div id="1896" class="line none"> 1896  * If the queue is being waited on by k_poll(), it will return with</div><div id="1897" class="line none"> 1897  * -EINTR and K_POLL_STATE_CANCELLED state (and per above, subsequent</div><div id="1898" class="line none"> 1898  * k_queue_get() will return NULL).</div><div id="1899" class="line none"> 1899  *</div><div id="1900" class="line none"> 1900  * @funcprops \isr_ok</div><div id="1901" class="line none"> 1901  *</div><div id="1902" class="line none"> 1902  * @param queue Address of the queue.</div><div id="1903" class="line none"> 1903  */</div><div id="1904" class="line none"> 1904 __syscall void k_queue_cancel_wait(struct <a href="kernel.h.html#1850">k_queue</a> *<a href="kernel.h.html#3889">queue</a>);</div><div id="1905" class="line none"> 1905 </div><div id="1906" class="line none"> 1906 /**</div><div id="1907" class="line none"> 1907  * @brief Append an element to the end of a queue.</div><div id="1908" class="line none"> 1908  *</div><div id="1909" class="line none"> 1909  * This routine appends a data item to @a queue. A queue data item must be</div><div id="1910" class="line none"> 1910  * aligned on a word boundary, and the first word of the item is reserved</div><div id="1911" class="line none"> 1911  * for the kernel's use.</div><div id="1912" class="line none"> 1912  *</div><div id="1913" class="line none"> 1913  * @funcprops \isr_ok</div><div id="1914" class="line none"> 1914  *</div><div id="1915" class="line none"> 1915  * @param queue Address of the queue.</div><div id="1916" class="line none"> 1916  * @param data Address of the data item.</div><div id="1917" class="line none"> 1917  */</div><div id="1918" class="line none"> 1918 void k_queue_append(struct <a href="kernel.h.html#1850">k_queue</a> *<a href="kernel.h.html#3889">queue</a>, void *<a href="logging/log_msg.h.html#100">data</a>);</div><div id="1919" class="line none"> 1919 </div><div id="1920" class="line none"> 1920 /**</div><div id="1921" class="line none"> 1921  * @brief Append an element to a queue.</div><div id="1922" class="line none"> 1922  *</div><div id="1923" class="line none"> 1923  * This routine appends a data item to @a queue. There is an implicit memory</div><div id="1924" class="line none"> 1924  * allocation to create an additional temporary bookkeeping data structure from</div><div id="1925" class="line none"> 1925  * the calling thread's resource pool, which is automatically freed when the</div><div id="1926" class="line none"> 1926  * item is removed. The data itself is not copied.</div><div id="1927" class="line none"> 1927  *</div><div id="1928" class="line none"> 1928  * @funcprops \isr_ok</div><div id="1929" class="line none"> 1929  *</div><div id="1930" class="line none"> 1930  * @param queue Address of the queue.</div><div id="1931" class="line none"> 1931  * @param data Address of the data item.</div><div id="1932" class="line none"> 1932  *</div><div id="1933" class="line none"> 1933  * @retval 0 on success</div><div id="1934" class="line none"> 1934  * @retval -ENOMEM if there isn't sufficient RAM in the caller's resource pool</div><div id="1935" class="line none"> 1935  */</div><div id="1936" class="line none"> 1936 __syscall int32_t k_queue_alloc_append(struct <a href="kernel.h.html#1850">k_queue</a> *<a href="kernel.h.html#3889">queue</a>, void *<a href="logging/log_msg.h.html#100">data</a>);</div><div id="1937" class="line none"> 1937 </div><div id="1938" class="line none"> 1938 /**</div><div id="1939" class="line none"> 1939  * @brief Prepend an element to a queue.</div><div id="1940" class="line none"> 1940  *</div><div id="1941" class="line none"> 1941  * This routine prepends a data item to @a queue. A queue data item must be</div><div id="1942" class="line none"> 1942  * aligned on a word boundary, and the first word of the item is reserved</div><div id="1943" class="line none"> 1943  * for the kernel's use.</div><div id="1944" class="line none"> 1944  *</div><div id="1945" class="line none"> 1945  * @funcprops \isr_ok</div><div id="1946" class="line none"> 1946  *</div><div id="1947" class="line none"> 1947  * @param queue Address of the queue.</div><div id="1948" class="line none"> 1948  * @param data Address of the data item.</div><div id="1949" class="line none"> 1949  */</div><div id="1950" class="line none"> 1950 void k_queue_prepend(struct <a href="kernel.h.html#1850">k_queue</a> *<a href="kernel.h.html#3889">queue</a>, void *<a href="logging/log_msg.h.html#100">data</a>);</div><div id="1951" class="line none"> 1951 </div><div id="1952" class="line none"> 1952 /**</div><div id="1953" class="line none"> 1953  * @brief Prepend an element to a queue.</div><div id="1954" class="line none"> 1954  *</div><div id="1955" class="line none"> 1955  * This routine prepends a data item to @a queue. There is an implicit memory</div><div id="1956" class="line none"> 1956  * allocation to create an additional temporary bookkeeping data structure from</div><div id="1957" class="line none"> 1957  * the calling thread's resource pool, which is automatically freed when the</div><div id="1958" class="line none"> 1958  * item is removed. The data itself is not copied.</div><div id="1959" class="line none"> 1959  *</div><div id="1960" class="line none"> 1960  * @funcprops \isr_ok</div><div id="1961" class="line none"> 1961  *</div><div id="1962" class="line none"> 1962  * @param queue Address of the queue.</div><div id="1963" class="line none"> 1963  * @param data Address of the data item.</div><div id="1964" class="line none"> 1964  *</div><div id="1965" class="line none"> 1965  * @retval 0 on success</div><div id="1966" class="line none"> 1966  * @retval -ENOMEM if there isn't sufficient RAM in the caller's resource pool</div><div id="1967" class="line none"> 1967  */</div><div id="1968" class="line none"> 1968 __syscall int32_t k_queue_alloc_prepend(struct <a href="kernel.h.html#1850">k_queue</a> *<a href="kernel.h.html#3889">queue</a>, void *<a href="logging/log_msg.h.html#100">data</a>);</div><div id="1969" class="line none"> 1969 </div><div id="1970" class="line none"> 1970 /**</div><div id="1971" class="line none"> 1971  * @brief Inserts an element to a queue.</div><div id="1972" class="line none"> 1972  *</div><div id="1973" class="line none"> 1973  * This routine inserts a data item to @a queue after previous item. A queue</div><div id="1974" class="line none"> 1974  * data item must be aligned on a word boundary, and the first word of</div><div id="1975" class="line none"> 1975  * the item is reserved for the kernel's use.</div><div id="1976" class="line none"> 1976  *</div><div id="1977" class="line none"> 1977  * @funcprops \isr_ok</div><div id="1978" class="line none"> 1978  *</div><div id="1979" class="line none"> 1979  * @param queue Address of the queue.</div><div id="1980" class="line none"> 1980  * @param prev Address of the previous data item.</div><div id="1981" class="line none"> 1981  * @param data Address of the data item.</div><div id="1982" class="line none"> 1982  */</div><div id="1983" class="line none"> 1983 void k_queue_insert(struct <a href="kernel.h.html#1850">k_queue</a> *<a href="kernel.h.html#3889">queue</a>, void *<a href="sys/dlist.h.html#43">prev</a>, void *<a href="logging/log_msg.h.html#100">data</a>);</div><div id="1984" class="line none"> 1984 </div><div id="1985" class="line none"> 1985 /**</div><div id="1986" class="line none"> 1986  * @brief Atomically append a list of elements to a queue.</div><div id="1987" class="line none"> 1987  *</div><div id="1988" class="line none"> 1988  * This routine adds a list of data items to @a queue in one operation.</div><div id="1989" class="line none"> 1989  * The data items must be in a singly-linked list, with the first word</div><div id="1990" class="line none"> 1990  * in each data item pointing to the next data item; the list must be</div><div id="1991" class="line none"> 1991  * NULL-terminated.</div><div id="1992" class="line none"> 1992  *</div><div id="1993" class="line none"> 1993  * @funcprops \isr_ok</div><div id="1994" class="line none"> 1994  *</div><div id="1995" class="line none"> 1995  * @param queue Address of the queue.</div><div id="1996" class="line none"> 1996  * @param head Pointer to first node in singly-linked list.</div><div id="1997" class="line none"> 1997  * @param tail Pointer to last node in singly-linked list.</div><div id="1998" class="line none"> 1998  *</div><div id="1999" class="line none"> 1999  * @retval 0 on success</div><div id="2000" class="line none"> 2000  * @retval -EINVAL on invalid supplied data</div><div id="2001" class="line none"> 2001  *</div><div id="2002" class="line none"> 2002  */</div><div id="2003" class="line none"> 2003 int k_queue_append_list(struct <a href="kernel.h.html#1850">k_queue</a> *<a href="kernel.h.html#3889">queue</a>, void *<a href="sys/dlist.h.html#38">head</a>, void *<a href="spinlock.h.html#63">tail</a>);</div><div id="2004" class="line none"> 2004 </div><div id="2005" class="line none"> 2005 /**</div><div id="2006" class="line none"> 2006  * @brief Atomically add a list of elements to a queue.</div><div id="2007" class="line none"> 2007  *</div><div id="2008" class="line none"> 2008  * This routine adds a list of data items to @a queue in one operation.</div><div id="2009" class="line none"> 2009  * The data items must be in a singly-linked list implemented using a</div><div id="2010" class="line none"> 2010  * sys_slist_t object. Upon completion, the original list is empty.</div><div id="2011" class="line none"> 2011  *</div><div id="2012" class="line none"> 2012  * @funcprops \isr_ok</div><div id="2013" class="line none"> 2013  *</div><div id="2014" class="line none"> 2014  * @param queue Address of the queue.</div><div id="2015" class="line none"> 2015  * @param list Pointer to sys_slist_t object.</div><div id="2016" class="line none"> 2016  *</div><div id="2017" class="line none"> 2017  * @retval 0 on success</div><div id="2018" class="line none"> 2018  * @retval -EINVAL on invalid data</div><div id="2019" class="line none"> 2019  */</div><div id="2020" class="line none"> 2020 int k_queue_merge_slist(struct <a href="kernel.h.html#1850">k_queue</a> *<a href="kernel.h.html#3889">queue</a>, sys_slist_t *<a href="net/mqtt.h.html#272">list</a>);</div><div id="2021" class="line none"> 2021 </div><div id="2022" class="line none"> 2022 /**</div><div id="2023" class="line none"> 2023  * @brief Get an element from a queue.</div><div id="2024" class="line none"> 2024  *</div><div id="2025" class="line none"> 2025  * This routine removes first data item from @a queue. The first word of the</div><div id="2026" class="line none"> 2026  * data item is reserved for the kernel's use.</div><div id="2027" class="line none"> 2027  *</div><div id="2028" class="line none"> 2028  * @note @a timeout must be set to K_NO_WAIT if called from ISR.</div><div id="2029" class="line none"> 2029  *</div><div id="2030" class="line none"> 2030  * @funcprops \isr_ok</div><div id="2031" class="line none"> 2031  *</div><div id="2032" class="line none"> 2032  * @param queue Address of the queue.</div><div id="2033" class="line none"> 2033  * @param timeout Waiting period to obtain a data item, or one of the special</div><div id="2034" class="line none"> 2034  *                values K_NO_WAIT and K_FOREVER.</div><div id="2035" class="line none"> 2035  *</div><div id="2036" class="line none"> 2036  * @return Address of the data item if successful; NULL if returned</div><div id="2037" class="line none"> 2037  * without waiting, or waiting period timed out.</div><div id="2038" class="line none"> 2038  */</div><div id="2039" class="line none"> 2039 __syscall void *k_queue_get(struct <a href="kernel.h.html#1850">k_queue</a> *<a href="kernel.h.html#3889">queue</a>, k_timeout_t <a href="kernel.h.html#1452">timeout</a>);</div><div id="2040" class="line none"> 2040 </div><div id="2041" class="line none"> 2041 /**</div><div id="2042" class="line none"> 2042  * @brief Remove an element from a queue.</div><div id="2043" class="line none"> 2043  *</div><div id="2044" class="line none"> 2044  * This routine removes data item from @a queue. The first word of the</div><div id="2045" class="line none"> 2045  * data item is reserved for the kernel's use. Removing elements from k_queue</div><div id="2046" class="line none"> 2046  * rely on sys_slist_find_and_remove which is not a constant time operation.</div><div id="2047" class="line none"> 2047  *</div><div id="2048" class="line none"> 2048  * @note @a timeout must be set to K_NO_WAIT if called from ISR.</div><div id="2049" class="line none"> 2049  *</div><div id="2050" class="line none"> 2050  * @funcprops \isr_ok</div><div id="2051" class="line none"> 2051  *</div><div id="2052" class="line none"> 2052  * @param queue Address of the queue.</div><div id="2053" class="line none"> 2053  * @param data Address of the data item.</div><div id="2054" class="line none"> 2054  *</div><div id="2055" class="line none"> 2055  * @return true if data item was removed</div><div id="2056" class="line none"> 2056  */</div><div id="2057" class="line none"> 2057 bool k_queue_remove(struct <a href="kernel.h.html#1850">k_queue</a> *<a href="kernel.h.html#3889">queue</a>, void *<a href="logging/log_msg.h.html#100">data</a>);</div><div id="2058" class="line none"> 2058 </div><div id="2059" class="line none"> 2059 /**</div><div id="2060" class="line none"> 2060  * @brief Append an element to a queue only if it's not present already.</div><div id="2061" class="line none"> 2061  *</div><div id="2062" class="line none"> 2062  * This routine appends data item to @a queue. The first word of the data</div><div id="2063" class="line none"> 2063  * item is reserved for the kernel's use. Appending elements to k_queue</div><div id="2064" class="line none"> 2064  * relies on sys_slist_is_node_in_list which is not a constant time operation.</div><div id="2065" class="line none"> 2065  *</div><div id="2066" class="line none"> 2066  * @funcprops \isr_ok</div><div id="2067" class="line none"> 2067  *</div><div id="2068" class="line none"> 2068  * @param queue Address of the queue.</div><div id="2069" class="line none"> 2069  * @param data Address of the data item.</div><div id="2070" class="line none"> 2070  *</div><div id="2071" class="line none"> 2071  * @return true if data item was added, false if not</div><div id="2072" class="line none"> 2072  */</div><div id="2073" class="line none"> 2073 bool k_queue_unique_append(struct <a href="kernel.h.html#1850">k_queue</a> *<a href="kernel.h.html#3889">queue</a>, void *<a href="logging/log_msg.h.html#100">data</a>);</div><div id="2074" class="line none"> 2074 </div><div id="2075" class="line none"> 2075 /**</div><div id="2076" class="line none"> 2076  * @brief Query a queue to see if it has data available.</div><div id="2077" class="line none"> 2077  *</div><div id="2078" class="line none"> 2078  * Note that the data might be already gone by the time this function returns</div><div id="2079" class="line none"> 2079  * if other threads are also trying to read from the queue.</div><div id="2080" class="line none"> 2080  *</div><div id="2081" class="line none"> 2081  * @funcprops \isr_ok</div><div id="2082" class="line none"> 2082  *</div><div id="2083" class="line none"> 2083  * @param queue Address of the queue.</div><div id="2084" class="line none"> 2084  *</div><div id="2085" class="line none"> 2085  * @return Non-zero if the queue is empty.</div><div id="2086" class="line none"> 2086  * @return 0 if data is available.</div><div id="2087" class="line none"> 2087  */</div><div id="2088" class="line none"> 2088 __syscall int k_queue_is_empty(struct <a href="kernel.h.html#1850">k_queue</a> *<a href="kernel.h.html#3889">queue</a>);</div><div id="2089" class="line none"> 2089 </div><div id="2090" class="line none"> 2090 static inline int <a href="kernel.h.html#2090">z_impl_k_queue_is_empty</a>(struct <a href="kernel.h.html#1850">k_queue</a> *<a href="kernel.h.html#3889">queue</a>)</div><div id="2091" class="line none"> 2091 {</div><div id="2092" class="line none"> 2092         return sys_sflist_is_empty(&amp;<a href="kernel.h.html#3889">queue</a>-&gt;<a href="kernel.h.html#1851">data_q</a>) ? 1 : 0;</div><div id="2093" class="line none"> 2093 }</div><div id="2094" class="line none"> 2094 </div><div id="2095" class="line none"> 2095 /**</div><div id="2096" class="line none"> 2096  * @brief Peek element at the head of queue.</div><div id="2097" class="line none"> 2097  *</div><div id="2098" class="line none"> 2098  * Return element from the head of queue without removing it.</div><div id="2099" class="line none"> 2099  *</div><div id="2100" class="line none"> 2100  * @param queue Address of the queue.</div><div id="2101" class="line none"> 2101  *</div><div id="2102" class="line none"> 2102  * @return Head element, or NULL if queue is empty.</div><div id="2103" class="line none"> 2103  */</div><div id="2104" class="line none"> 2104 __syscall void *k_queue_peek_head(struct <a href="kernel.h.html#1850">k_queue</a> *<a href="kernel.h.html#3889">queue</a>);</div><div id="2105" class="line none"> 2105 </div><div id="2106" class="line none"> 2106 /**</div><div id="2107" class="line none"> 2107  * @brief Peek element at the tail of queue.</div><div id="2108" class="line none"> 2108  *</div><div id="2109" class="line none"> 2109  * Return element from the tail of queue without removing it.</div><div id="2110" class="line none"> 2110  *</div><div id="2111" class="line none"> 2111  * @param queue Address of the queue.</div><div id="2112" class="line none"> 2112  *</div><div id="2113" class="line none"> 2113  * @return Tail element, or NULL if queue is empty.</div><div id="2114" class="line none"> 2114  */</div><div id="2115" class="line none"> 2115 __syscall void *k_queue_peek_tail(struct <a href="kernel.h.html#1850">k_queue</a> *<a href="kernel.h.html#3889">queue</a>);</div><div id="2116" class="line none"> 2116 </div><div id="2117" class="line none"> 2117 /**</div><div id="2118" class="line none"> 2118  * @brief Statically define and initialize a queue.</div><div id="2119" class="line none"> 2119  *</div><div id="2120" class="line none"> 2120  * The queue can be accessed outside the module where it is defined using:</div><div id="2121" class="line none"> 2121  *</div><div id="2122" class="line none"> 2122  * @code extern struct k_queue &lt;name&gt;; @endcode</div><div id="2123" class="line none"> 2123  *</div><div id="2124" class="line none"> 2124  * @param name Name of the queue.</div><div id="2125" class="line none"> 2125  */</div><div id="2126" class="line none"> 2126 #define <a href="kernel.h.html#2126">K_QUEUE_DEFINE</a>(<a href="kernel.h.html#4006">name</a>) \</div><div id="2127" class="line none"> 2127         STRUCT_SECTION_ITERABLE(<a href="kernel.h.html#1850">k_queue</a>, <a href="kernel.h.html#4006">name</a>) = \</div><div id="2128" class="line none"> 2128                 <a href="kernel.h.html#1864">Z_QUEUE_INITIALIZER</a>(<a href="kernel.h.html#4006">name</a>)</div><div id="2129" class="line none"> 2129 </div><div id="2130" class="line none"> 2130 /** @} */</div><div id="2131" class="line none"> 2131 </div><div id="2132" class="line none"> 2132 #ifdef CONFIG_USERSPACE</div><div id="2133" class="line none"> 2133 /**</div><div id="2134" class="line none"> 2134  * @brief futex structure</div><div id="2135" class="line none"> 2135  *</div><div id="2136" class="line none"> 2136  * A k_futex is a lightweight mutual exclusion primitive designed</div><div id="2137" class="line none"> 2137  * to minimize kernel involvement. Uncontended operation relies</div><div id="2138" class="line none"> 2138  * only on atomic access to shared memory. k_futex are tracked as</div><div id="2139" class="line none"> 2139  * kernel objects and can live in user memory so that any access</div><div id="2140" class="line none"> 2140  * bypasses the kernel object permission management mechanism.</div><div id="2141" class="line none"> 2141  */</div><div id="2142" class="line none"> 2142 struct <a href="kernel.h.html#2142">k_futex</a> {</div><div id="2143" class="line none"> 2143         <a href="sys/atomic_types.h.html#15">atomic_t</a> <a href="kernel.h.html#2143">val</a>;</div><div id="2144" class="line none"> 2144 };</div><div id="2145" class="line none"> 2145 </div><div id="2146" class="line none"> 2146 /**</div><div id="2147" class="line none"> 2147  * @brief futex kernel data structure</div><div id="2148" class="line none"> 2148  *</div><div id="2149" class="line none"> 2149  * z_futex_data are the helper data structure for k_futex to complete</div><div id="2150" class="line none"> 2150  * futex contended operation on kernel side, structure z_futex_data</div><div id="2151" class="line none"> 2151  * of every futex object is invisible in user mode.</div><div id="2152" class="line none"> 2152  */</div><div id="2153" class="line none"> 2153 struct <a href="kernel.h.html#2153">z_futex_data</a> {</div><div id="2154" class="line none"> 2154         <a href="kernel_structs.h.html#286">_wait_q_t</a> <a href="kernel.h.html#1455">wait_q</a>;</div><div id="2155" class="line none"> 2155         struct <a href="spinlock.h.html#45">k_spinlock</a> <a href="kernel.h.html#1852">lock</a>;</div><div id="2156" class="line none"> 2156 };</div><div id="2157" class="line none"> 2157 </div><div id="2158" class="line none"> 2158 #define <a href="kernel.h.html#2158">Z_FUTEX_DATA_INITIALIZER</a>(<a href="kernel.h.html#5739">obj</a>) \</div><div id="2159" class="line none"> 2159         { \</div><div id="2160" class="line none"> 2160         .<a href="kernel.h.html#1455">wait_q</a> = <a href="kernel_structs.h.html#280">Z_WAIT_Q_INIT</a>(&amp;<a href="kernel.h.html#5739">obj</a>.<a href="kernel.h.html#1455">wait_q</a>) \</div><div id="2161" class="line none"> 2161         }</div><div id="2162" class="line none"> 2162 </div><div id="2163" class="line none"> 2163 /**</div><div id="2164" class="line none"> 2164  * @defgroup futex_apis FUTEX APIs</div><div id="2165" class="line none"> 2165  * @ingroup kernel_apis</div><div id="2166" class="line none"> 2166  * @{</div><div id="2167" class="line none"> 2167  */</div><div id="2168" class="line none"> 2168 </div><div id="2169" class="line none"> 2169 /**</div><div id="2170" class="line none"> 2170  * @brief Pend the current thread on a futex</div><div id="2171" class="line none"> 2171  *</div><div id="2172" class="line none"> 2172  * Tests that the supplied futex contains the expected value, and if so,</div><div id="2173" class="line none"> 2173  * goes to sleep until some other thread calls k_futex_wake() on it.</div><div id="2174" class="line none"> 2174  *</div><div id="2175" class="line none"> 2175  * @param futex Address of the futex.</div><div id="2176" class="line none"> 2176  * @param expected Expected value of the futex, if it is different the caller</div><div id="2177" class="line none"> 2177  *                 will not wait on it.</div><div id="2178" class="line none"> 2178  * @param timeout Waiting period on the futex, or one of the special values</div><div id="2179" class="line none"> 2179  *                K_NO_WAIT or K_FOREVER.</div><div id="2180" class="line none"> 2180  * @retval -EACCES Caller does not have read access to futex address.</div><div id="2181" class="line none"> 2181  * @retval -EAGAIN If the futex value did not match the expected parameter.</div><div id="2182" class="line none"> 2182  * @retval -EINVAL Futex parameter address not recognized by the kernel.</div><div id="2183" class="line none"> 2183  * @retval -ETIMEDOUT Thread woke up due to timeout and not a futex wakeup.</div><div id="2184" class="line none"> 2184  * @retval 0 if the caller went to sleep and was woken up. The caller</div><div id="2185" class="line none"> 2185  *           should check the futex's value on wakeup to determine if it needs</div><div id="2186" class="line none"> 2186  *           to block again.</div><div id="2187" class="line none"> 2187  */</div><div id="2188" class="line none"> 2188 __syscall int k_futex_wait(struct <a href="kernel.h.html#2142">k_futex</a> *futex, int expected,</div><div id="2189" class="line none"> 2189                            k_timeout_t <a href="kernel.h.html#1452">timeout</a>);</div><div id="2190" class="line none"> 2190 </div><div id="2191" class="line none"> 2191 /**</div><div id="2192" class="line none"> 2192  * @brief Wake one/all threads pending on a futex</div><div id="2193" class="line none"> 2193  *</div><div id="2194" class="line none"> 2194  * Wake up the highest priority thread pending on the supplied futex, or</div><div id="2195" class="line none"> 2195  * wakeup all the threads pending on the supplied futex, and the behavior</div><div id="2196" class="line none"> 2196  * depends on wake_all.</div><div id="2197" class="line none"> 2197  *</div><div id="2198" class="line none"> 2198  * @param futex Futex to wake up pending threads.</div><div id="2199" class="line none"> 2199  * @param wake_all If true, wake up all pending threads; If false,</div><div id="2200" class="line none"> 2200  *                 wakeup the highest priority thread.</div><div id="2201" class="line none"> 2201  * @retval -EACCES Caller does not have access to the futex address.</div><div id="2202" class="line none"> 2202  * @retval -EINVAL Futex parameter address not recognized by the kernel.</div><div id="2203" class="line none"> 2203  * @retval Number of threads that were woken up.</div><div id="2204" class="line none"> 2204  */</div><div id="2205" class="line none"> 2205 __syscall int k_futex_wake(struct <a href="kernel.h.html#2142">k_futex</a> *futex, bool wake_all);</div><div id="2206" class="line none"> 2206 </div><div id="2207" class="line none"> 2207 /** @} */</div><div id="2208" class="line none"> 2208 #endif</div><div id="2209" class="line none"> 2209 </div><div id="2210" class="line none"> 2210 /**</div><div id="2211" class="line none"> 2211  * @defgroup event_apis Event APIs</div><div id="2212" class="line none"> 2212  * @ingroup kernel_apis</div><div id="2213" class="line none"> 2213  * @{</div><div id="2214" class="line none"> 2214  */</div><div id="2215" class="line none"> 2215 </div><div id="2216" class="line none"> 2216 /**</div><div id="2217" class="line none"> 2217  * Event Structure</div><div id="2218" class="line none"> 2218  * @ingroup event_apis</div><div id="2219" class="line none"> 2219  */</div><div id="2220" class="line none"> 2220 </div><div id="2221" class="line none"> 2221 struct <a href="kernel.h.html#2221">k_event</a> {</div><div id="2222" class="line none"> 2222         <a href="kernel_structs.h.html#286">_wait_q_t</a>         <a href="kernel.h.html#1455">wait_q</a>;</div><div id="2223" class="line none"> 2223         uint32_t          <a href="kernel.h.html#2223">events</a>;</div><div id="2224" class="line none"> 2224         struct <a href="spinlock.h.html#45">k_spinlock</a> <a href="kernel.h.html#1852">lock</a>;</div><div id="2225" class="line none"> 2225 </div><div id="2226" class="line none"> 2226         SYS_PORT_TRACING_TRACKING_FIELD(<a href="kernel.h.html#2221">k_event</a>)</div><div id="2227" class="line none"> 2227 </div><div id="2228" class="line none"> 2228 #ifdef CONFIG_OBJ_CORE_EVENT</div><div id="2229" class="line none"> 2229         struct k_obj_core <a href="kernel.h.html#1475">obj_core</a>;</div><div id="2230" class="line none"> 2230 #endif</div><div id="2231" class="line none"> 2231 </div><div id="2232" class="line none"> 2232 };</div><div id="2233" class="line none"> 2233 </div><div id="2234" class="line none"> 2234 #define <a href="kernel.h.html#2234">Z_EVENT_INITIALIZER</a>(<a href="kernel.h.html#5739">obj</a>) \</div><div id="2235" class="line none"> 2235         { \</div><div id="2236" class="line none"> 2236         .<a href="kernel.h.html#1455">wait_q</a> = <a href="kernel_structs.h.html#280">Z_WAIT_Q_INIT</a>(&amp;<a href="kernel.h.html#5739">obj</a>.<a href="kernel.h.html#1455">wait_q</a>), \</div><div id="2237" class="line none"> 2237         .<a href="kernel.h.html#2223">events</a> = 0 \</div><div id="2238" class="line none"> 2238         }</div><div id="2239" class="line none"> 2239 </div><div id="2240" class="line none"> 2240 /**</div><div id="2241" class="line none"> 2241  * @brief Initialize an event object</div><div id="2242" class="line none"> 2242  *</div><div id="2243" class="line none"> 2243  * This routine initializes an event object, prior to its first use.</div><div id="2244" class="line none"> 2244  *</div><div id="2245" class="line none"> 2245  * @param event Address of the event object.</div><div id="2246" class="line none"> 2246  */</div><div id="2247" class="line none"> 2247 __syscall void k_event_init(struct <a href="kernel.h.html#2221">k_event</a> *event);</div><div id="2248" class="line none"> 2248 </div><div id="2249" class="line none"> 2249 /**</div><div id="2250" class="line none"> 2250  * @brief Post one or more events to an event object</div><div id="2251" class="line none"> 2251  *</div><div id="2252" class="line none"> 2252  * This routine posts one or more events to an event object. All tasks waiting</div><div id="2253" class="line none"> 2253  * on the event object @a event whose waiting conditions become met by this</div><div id="2254" class="line none"> 2254  * posting immediately unpend.</div><div id="2255" class="line none"> 2255  *</div><div id="2256" class="line none"> 2256  * Posting differs from setting in that posted events are merged together with</div><div id="2257" class="line none"> 2257  * the current set of events tracked by the event object.</div><div id="2258" class="line none"> 2258  *</div><div id="2259" class="line none"> 2259  * @param event Address of the event object</div><div id="2260" class="line none"> 2260  * @param events Set of events to post to @a event</div><div id="2261" class="line none"> 2261  *</div><div id="2262" class="line none"> 2262  * @retval Previous value of the events in @a event</div><div id="2263" class="line none"> 2263  */</div><div id="2264" class="line none"> 2264 __syscall uint32_t k_event_post(struct <a href="kernel.h.html#2221">k_event</a> *event, uint32_t <a href="kernel.h.html#2223">events</a>);</div><div id="2265" class="line none"> 2265 </div><div id="2266" class="line none"> 2266 /**</div><div id="2267" class="line none"> 2267  * @brief Set the events in an event object</div><div id="2268" class="line none"> 2268  *</div><div id="2269" class="line none"> 2269  * This routine sets the events stored in event object to the specified value.</div><div id="2270" class="line none"> 2270  * All tasks waiting on the event object @a event whose waiting conditions</div><div id="2271" class="line none"> 2271  * become met by this immediately unpend.</div><div id="2272" class="line none"> 2272  *</div><div id="2273" class="line none"> 2273  * Setting differs from posting in that set events replace the current set of</div><div id="2274" class="line none"> 2274  * events tracked by the event object.</div><div id="2275" class="line none"> 2275  *</div><div id="2276" class="line none"> 2276  * @param event Address of the event object</div><div id="2277" class="line none"> 2277  * @param events Set of events to set in @a event</div><div id="2278" class="line none"> 2278  *</div><div id="2279" class="line none"> 2279  * @retval Previous value of the events in @a event</div><div id="2280" class="line none"> 2280  */</div><div id="2281" class="line none"> 2281 __syscall uint32_t k_event_set(struct <a href="kernel.h.html#2221">k_event</a> *event, uint32_t <a href="kernel.h.html#2223">events</a>);</div><div id="2282" class="line none"> 2282 </div><div id="2283" class="line none"> 2283 /**</div><div id="2284" class="line none"> 2284  * @brief Set or clear the events in an event object</div><div id="2285" class="line none"> 2285  *</div><div id="2286" class="line none"> 2286  * This routine sets the events stored in event object to the specified value.</div><div id="2287" class="line none"> 2287  * All tasks waiting on the event object @a event whose waiting conditions</div><div id="2288" class="line none"> 2288  * become met by this immediately unpend. Unlike @ref k_event_set, this routine</div><div id="2289" class="line none"> 2289  * allows specific event bits to be set and cleared as determined by the mask.</div><div id="2290" class="line none"> 2290  *</div><div id="2291" class="line none"> 2291  * @param event Address of the event object</div><div id="2292" class="line none"> 2292  * @param events Set of events to set/clear in @a event</div><div id="2293" class="line none"> 2293  * @param events_mask Mask to be applied to @a events</div><div id="2294" class="line none"> 2294  *</div><div id="2295" class="line none"> 2295  * @retval Previous value of the events in @a events_mask</div><div id="2296" class="line none"> 2296  */</div><div id="2297" class="line none"> 2297 __syscall uint32_t k_event_set_masked(struct <a href="kernel.h.html#2221">k_event</a> *event, uint32_t <a href="kernel.h.html#2223">events</a>,</div><div id="2298" class="line none"> 2298                                   uint32_t events_mask);</div><div id="2299" class="line none"> 2299 </div><div id="2300" class="line none"> 2300 /**</div><div id="2301" class="line none"> 2301  * @brief Clear the events in an event object</div><div id="2302" class="line none"> 2302  *</div><div id="2303" class="line none"> 2303  * This routine clears (resets) the specified events stored in an event object.</div><div id="2304" class="line none"> 2304  *</div><div id="2305" class="line none"> 2305  * @param event Address of the event object</div><div id="2306" class="line none"> 2306  * @param events Set of events to clear in @a event</div><div id="2307" class="line none"> 2307  *</div><div id="2308" class="line none"> 2308  * @retval Previous value of the events in @a event</div><div id="2309" class="line none"> 2309  */</div><div id="2310" class="line none"> 2310 __syscall uint32_t k_event_clear(struct <a href="kernel.h.html#2221">k_event</a> *event, uint32_t <a href="kernel.h.html#2223">events</a>);</div><div id="2311" class="line none"> 2311 </div><div id="2312" class="line none"> 2312 /**</div><div id="2313" class="line none"> 2313  * @brief Wait for any of the specified events</div><div id="2314" class="line none"> 2314  *</div><div id="2315" class="line none"> 2315  * This routine waits on event object @a event until any of the specified</div><div id="2316" class="line none"> 2316  * events have been delivered to the event object, or the maximum wait time</div><div id="2317" class="line none"> 2317  * @a timeout has expired. A thread may wait on up to 32 distinctly numbered</div><div id="2318" class="line none"> 2318  * events that are expressed as bits in a single 32-bit word.</div><div id="2319" class="line none"> 2319  *</div><div id="2320" class="line none"> 2320  * @note The caller must be careful when resetting if there are multiple threads</div><div id="2321" class="line none"> 2321  * waiting for the event object @a event.</div><div id="2322" class="line none"> 2322  *</div><div id="2323" class="line none"> 2323  * @param event Address of the event object</div><div id="2324" class="line none"> 2324  * @param events Set of desired events on which to wait</div><div id="2325" class="line none"> 2325  * @param reset If true, clear the set of events tracked by the event object</div><div id="2326" class="line none"> 2326  *              before waiting. If false, do not clear the events.</div><div id="2327" class="line none"> 2327  * @param timeout Waiting period for the desired set of events or one of the</div><div id="2328" class="line none"> 2328  *                special values K_NO_WAIT and K_FOREVER.</div><div id="2329" class="line none"> 2329  *</div><div id="2330" class="line none"> 2330  * @retval set of matching events upon success</div><div id="2331" class="line none"> 2331  * @retval 0 if matching events were not received within the specified time</div><div id="2332" class="line none"> 2332  */</div><div id="2333" class="line none"> 2333 __syscall uint32_t k_event_wait(struct <a href="kernel.h.html#2221">k_event</a> *event, uint32_t <a href="kernel.h.html#2223">events</a>,</div><div id="2334" class="line none"> 2334                                 bool reset, k_timeout_t <a href="kernel.h.html#1452">timeout</a>);</div><div id="2335" class="line none"> 2335 </div><div id="2336" class="line none"> 2336 /**</div><div id="2337" class="line none"> 2337  * @brief Wait for all of the specified events</div><div id="2338" class="line none"> 2338  *</div><div id="2339" class="line none"> 2339  * This routine waits on event object @a event until all of the specified</div><div id="2340" class="line none"> 2340  * events have been delivered to the event object, or the maximum wait time</div><div id="2341" class="line none"> 2341  * @a timeout has expired. A thread may wait on up to 32 distinctly numbered</div><div id="2342" class="line none"> 2342  * events that are expressed as bits in a single 32-bit word.</div><div id="2343" class="line none"> 2343  *</div><div id="2344" class="line none"> 2344  * @note The caller must be careful when resetting if there are multiple threads</div><div id="2345" class="line none"> 2345  * waiting for the event object @a event.</div><div id="2346" class="line none"> 2346  *</div><div id="2347" class="line none"> 2347  * @param event Address of the event object</div><div id="2348" class="line none"> 2348  * @param events Set of desired events on which to wait</div><div id="2349" class="line none"> 2349  * @param reset If true, clear the set of events tracked by the event object</div><div id="2350" class="line none"> 2350  *              before waiting. If false, do not clear the events.</div><div id="2351" class="line none"> 2351  * @param timeout Waiting period for the desired set of events or one of the</div><div id="2352" class="line none"> 2352  *                special values K_NO_WAIT and K_FOREVER.</div><div id="2353" class="line none"> 2353  *</div><div id="2354" class="line none"> 2354  * @retval set of matching events upon success</div><div id="2355" class="line none"> 2355  * @retval 0 if matching events were not received within the specified time</div><div id="2356" class="line none"> 2356  */</div><div id="2357" class="line none"> 2357 __syscall uint32_t k_event_wait_all(struct <a href="kernel.h.html#2221">k_event</a> *event, uint32_t <a href="kernel.h.html#2223">events</a>,</div><div id="2358" class="line none"> 2358                                     bool reset, k_timeout_t <a href="kernel.h.html#1452">timeout</a>);</div><div id="2359" class="line none"> 2359 </div><div id="2360" class="line none"> 2360 /**</div><div id="2361" class="line none"> 2361  * @brief Test the events currently tracked in the event object</div><div id="2362" class="line none"> 2362  *</div><div id="2363" class="line none"> 2363  * @param event Address of the event object</div><div id="2364" class="line none"> 2364  * @param events_mask Set of desired events to test</div><div id="2365" class="line none"> 2365  *</div><div id="2366" class="line none"> 2366  * @retval Current value of events in @a events_mask</div><div id="2367" class="line none"> 2367  */</div><div id="2368" class="line none"> 2368 static inline uint32_t <a href="kernel.h.html#2368">k_event_test</a>(struct <a href="kernel.h.html#2221">k_event</a> *event, uint32_t events_mask)</div><div id="2369" class="line none"> 2369 {</div><div id="2370" class="line none"> 2370         return k_event_wait(event, events_mask, false, <a href="kernel.h.html#1253">K_NO_WAIT</a>);</div><div id="2371" class="line none"> 2371 }</div><div id="2372" class="line none"> 2372 </div><div id="2373" class="line none"> 2373 /**</div><div id="2374" class="line none"> 2374  * @brief Statically define and initialize an event object</div><div id="2375" class="line none"> 2375  *</div><div id="2376" class="line none"> 2376  * The event can be accessed outside the module where it is defined using:</div><div id="2377" class="line none"> 2377  *</div><div id="2378" class="line none"> 2378  * @code extern struct k_event &lt;name&gt;; @endcode</div><div id="2379" class="line none"> 2379  *</div><div id="2380" class="line none"> 2380  * @param name Name of the event object.</div><div id="2381" class="line none"> 2381  */</div><div id="2382" class="line none"> 2382 #define <a href="kernel.h.html#2382">K_EVENT_DEFINE</a>(<a href="kernel.h.html#4006">name</a>)                                   \</div><div id="2383" class="line none"> 2383         STRUCT_SECTION_ITERABLE(<a href="kernel.h.html#2221">k_event</a>, <a href="kernel.h.html#4006">name</a>) =               \</div><div id="2384" class="line none"> 2384                 <a href="kernel.h.html#2234">Z_EVENT_INITIALIZER</a>(<a href="kernel.h.html#4006">name</a>);</div><div id="2385" class="line none"> 2385 </div><div id="2386" class="line none"> 2386 /** @} */</div><div id="2387" class="line none"> 2387 </div><div id="2388" class="line none"> 2388 struct <a href="kernel.h.html#2388">k_fifo</a> {</div><div id="2389" class="line none"> 2389         struct <a href="kernel.h.html#1850">k_queue</a> <a href="kernel.h.html#2389">_queue</a>;</div><div id="2390" class="line none"> 2390 #ifdef CONFIG_OBJ_CORE_FIFO</div><div id="2391" class="line none"> 2391         struct k_obj_core  <a href="kernel.h.html#1475">obj_core</a>;</div><div id="2392" class="line none"> 2392 #endif</div><div id="2393" class="line none"> 2393 };</div><div id="2394" class="line none"> 2394 </div><div id="2395" class="line none"> 2395 /**</div><div id="2396" class="line none"> 2396  * @cond INTERNAL_HIDDEN</div><div id="2397" class="line none"> 2397  */</div><div id="2398" class="line none"> 2398 #define <a href="kernel.h.html#2398">Z_FIFO_INITIALIZER</a>(<a href="kernel.h.html#5739">obj</a>) \</div><div id="2399" class="line none"> 2399         { \</div><div id="2400" class="line none"> 2400         .<a href="kernel.h.html#2389">_queue</a> = <a href="kernel.h.html#1864">Z_QUEUE_INITIALIZER</a>(<a href="kernel.h.html#5739">obj</a>.<a href="kernel.h.html#2389">_queue</a>) \</div><div id="2401" class="line none"> 2401         }</div><div id="2402" class="line none"> 2402 </div><div id="2403" class="line none"> 2403 /**</div><div id="2404" class="line none"> 2404  * INTERNAL_HIDDEN @endcond</div><div id="2405" class="line none"> 2405  */</div><div id="2406" class="line none"> 2406 </div><div id="2407" class="line none"> 2407 /**</div><div id="2408" class="line none"> 2408  * @defgroup fifo_apis FIFO APIs</div><div id="2409" class="line none"> 2409  * @ingroup kernel_apis</div><div id="2410" class="line none"> 2410  * @{</div><div id="2411" class="line none"> 2411  */</div><div id="2412" class="line none"> 2412 </div><div id="2413" class="line none"> 2413 /**</div><div id="2414" class="line none"> 2414  * @brief Initialize a FIFO queue.</div><div id="2415" class="line none"> 2415  *</div><div id="2416" class="line none"> 2416  * This routine initializes a FIFO queue, prior to its first use.</div><div id="2417" class="line none"> 2417  *</div><div id="2418" class="line none"> 2418  * @param fifo Address of the FIFO queue.</div><div id="2419" class="line none"> 2419  */</div><div id="2420" class="line none"> 2420 #define <a href="kernel.h.html#2420">k_fifo_init</a>(<a href="kernel.h.html#5742">fifo</a>)                                    \</div><div id="2421" class="line none"> 2421         ({                                                   \</div><div id="2422" class="line none"> 2422         SYS_PORT_TRACING_OBJ_FUNC_ENTER(<a href="kernel.h.html#2388">k_fifo</a>, init, <a href="kernel.h.html#5742">fifo</a>); \</div><div id="2423" class="line none"> 2423         k_queue_init(&amp;(<a href="kernel.h.html#5742">fifo</a>)-&gt;<a href="kernel.h.html#2389">_queue</a>);                       \</div><div id="2424" class="line none"> 2424         K_OBJ_CORE_INIT(K_OBJ_CORE(<a href="kernel.h.html#5742">fifo</a>), _obj_type_fifo);   \</div><div id="2425" class="line none"> 2425         K_OBJ_CORE_LINK(K_OBJ_CORE(<a href="kernel.h.html#5742">fifo</a>));                   \</div><div id="2426" class="line none"> 2426         SYS_PORT_TRACING_OBJ_FUNC_EXIT(<a href="kernel.h.html#2388">k_fifo</a>, init, <a href="kernel.h.html#5742">fifo</a>);  \</div><div id="2427" class="line none"> 2427         })</div><div id="2428" class="line none"> 2428 </div><div id="2429" class="line none"> 2429 /**</div><div id="2430" class="line none"> 2430  * @brief Cancel waiting on a FIFO queue.</div><div id="2431" class="line none"> 2431  *</div><div id="2432" class="line none"> 2432  * This routine causes first thread pending on @a fifo, if any, to</div><div id="2433" class="line none"> 2433  * return from k_fifo_get() call with NULL value (as if timeout</div><div id="2434" class="line none"> 2434  * expired).</div><div id="2435" class="line none"> 2435  *</div><div id="2436" class="line none"> 2436  * @funcprops \isr_ok</div><div id="2437" class="line none"> 2437  *</div><div id="2438" class="line none"> 2438  * @param fifo Address of the FIFO queue.</div><div id="2439" class="line none"> 2439  */</div><div id="2440" class="line none"> 2440 #define <a href="kernel.h.html#2440">k_fifo_cancel_wait</a>(<a href="kernel.h.html#5742">fifo</a>) \</div><div id="2441" class="line none"> 2441         ({ \</div><div id="2442" class="line none"> 2442         SYS_PORT_TRACING_OBJ_FUNC_ENTER(<a href="kernel.h.html#2388">k_fifo</a>, cancel_wait, <a href="kernel.h.html#5742">fifo</a>); \</div><div id="2443" class="line none"> 2443         k_queue_cancel_wait(&amp;(<a href="kernel.h.html#5742">fifo</a>)-&gt;<a href="kernel.h.html#2389">_queue</a>); \</div><div id="2444" class="line none"> 2444         SYS_PORT_TRACING_OBJ_FUNC_EXIT(<a href="kernel.h.html#2388">k_fifo</a>, cancel_wait, <a href="kernel.h.html#5742">fifo</a>); \</div><div id="2445" class="line none"> 2445         })</div><div id="2446" class="line none"> 2446 </div><div id="2447" class="line none"> 2447 /**</div><div id="2448" class="line none"> 2448  * @brief Add an element to a FIFO queue.</div><div id="2449" class="line none"> 2449  *</div><div id="2450" class="line none"> 2450  * This routine adds a data item to @a fifo. A FIFO data item must be</div><div id="2451" class="line none"> 2451  * aligned on a word boundary, and the first word of the item is reserved</div><div id="2452" class="line none"> 2452  * for the kernel's use.</div><div id="2453" class="line none"> 2453  *</div><div id="2454" class="line none"> 2454  * @funcprops \isr_ok</div><div id="2455" class="line none"> 2455  *</div><div id="2456" class="line none"> 2456  * @param fifo Address of the FIFO.</div><div id="2457" class="line none"> 2457  * @param data Address of the data item.</div><div id="2458" class="line none"> 2458  */</div><div id="2459" class="line none"> 2459 #define <a href="kernel.h.html#2459">k_fifo_put</a>(<a href="kernel.h.html#5742">fifo</a>, <a href="logging/log_msg.h.html#100">data</a>) \</div><div id="2460" class="line none"> 2460         ({ \</div><div id="2461" class="line none"> 2461         SYS_PORT_TRACING_OBJ_FUNC_ENTER(<a href="kernel.h.html#2388">k_fifo</a>, put, <a href="kernel.h.html#5742">fifo</a>, <a href="logging/log_msg.h.html#100">data</a>); \</div><div id="2462" class="line none"> 2462         k_queue_append(&amp;(<a href="kernel.h.html#5742">fifo</a>)-&gt;<a href="kernel.h.html#2389">_queue</a>, <a href="logging/log_msg.h.html#100">data</a>); \</div><div id="2463" class="line none"> 2463         SYS_PORT_TRACING_OBJ_FUNC_EXIT(<a href="kernel.h.html#2388">k_fifo</a>, put, <a href="kernel.h.html#5742">fifo</a>, <a href="logging/log_msg.h.html#100">data</a>); \</div><div id="2464" class="line none"> 2464         })</div><div id="2465" class="line none"> 2465 </div><div id="2466" class="line none"> 2466 /**</div><div id="2467" class="line none"> 2467  * @brief Add an element to a FIFO queue.</div><div id="2468" class="line none"> 2468  *</div><div id="2469" class="line none"> 2469  * This routine adds a data item to @a fifo. There is an implicit memory</div><div id="2470" class="line none"> 2470  * allocation to create an additional temporary bookkeeping data structure from</div><div id="2471" class="line none"> 2471  * the calling thread's resource pool, which is automatically freed when the</div><div id="2472" class="line none"> 2472  * item is removed. The data itself is not copied.</div><div id="2473" class="line none"> 2473  *</div><div id="2474" class="line none"> 2474  * @funcprops \isr_ok</div><div id="2475" class="line none"> 2475  *</div><div id="2476" class="line none"> 2476  * @param fifo Address of the FIFO.</div><div id="2477" class="line none"> 2477  * @param data Address of the data item.</div><div id="2478" class="line none"> 2478  *</div><div id="2479" class="line none"> 2479  * @retval 0 on success</div><div id="2480" class="line none"> 2480  * @retval -ENOMEM if there isn't sufficient RAM in the caller's resource pool</div><div id="2481" class="line none"> 2481  */</div><div id="2482" class="line none"> 2482 #define <a href="kernel.h.html#2482">k_fifo_alloc_put</a>(<a href="kernel.h.html#5742">fifo</a>, <a href="logging/log_msg.h.html#100">data</a>) \</div><div id="2483" class="line none"> 2483         ({ \</div><div id="2484" class="line none"> 2484         SYS_PORT_TRACING_OBJ_FUNC_ENTER(<a href="kernel.h.html#2388">k_fifo</a>, alloc_put, <a href="kernel.h.html#5742">fifo</a>, <a href="logging/log_msg.h.html#100">data</a>); \</div><div id="2485" class="line none"> 2485         int fap_ret = k_queue_alloc_append(&amp;(<a href="kernel.h.html#5742">fifo</a>)-&gt;<a href="kernel.h.html#2389">_queue</a>, <a href="logging/log_msg.h.html#100">data</a>); \</div><div id="2486" class="line none"> 2486         SYS_PORT_TRACING_OBJ_FUNC_EXIT(<a href="kernel.h.html#2388">k_fifo</a>, alloc_put, <a href="kernel.h.html#5742">fifo</a>, <a href="logging/log_msg.h.html#100">data</a>, fap_ret); \</div><div id="2487" class="line none"> 2487         fap_ret; \</div><div id="2488" class="line none"> 2488         })</div><div id="2489" class="line none"> 2489 </div><div id="2490" class="line none"> 2490 /**</div><div id="2491" class="line none"> 2491  * @brief Atomically add a list of elements to a FIFO.</div><div id="2492" class="line none"> 2492  *</div><div id="2493" class="line none"> 2493  * This routine adds a list of data items to @a fifo in one operation.</div><div id="2494" class="line none"> 2494  * The data items must be in a singly-linked list, with the first word of</div><div id="2495" class="line none"> 2495  * each data item pointing to the next data item; the list must be</div><div id="2496" class="line none"> 2496  * NULL-terminated.</div><div id="2497" class="line none"> 2497  *</div><div id="2498" class="line none"> 2498  * @funcprops \isr_ok</div><div id="2499" class="line none"> 2499  *</div><div id="2500" class="line none"> 2500  * @param fifo Address of the FIFO queue.</div><div id="2501" class="line none"> 2501  * @param head Pointer to first node in singly-linked list.</div><div id="2502" class="line none"> 2502  * @param tail Pointer to last node in singly-linked list.</div><div id="2503" class="line none"> 2503  */</div><div id="2504" class="line none"> 2504 #define <a href="kernel.h.html#2504">k_fifo_put_list</a>(<a href="kernel.h.html#5742">fifo</a>, <a href="sys/dlist.h.html#38">head</a>, <a href="spinlock.h.html#63">tail</a>) \</div><div id="2505" class="line none"> 2505         ({ \</div><div id="2506" class="line none"> 2506         SYS_PORT_TRACING_OBJ_FUNC_ENTER(<a href="kernel.h.html#2388">k_fifo</a>, put_list, <a href="kernel.h.html#5742">fifo</a>, <a href="sys/dlist.h.html#38">head</a>, <a href="spinlock.h.html#63">tail</a>); \</div><div id="2507" class="line none"> 2507         k_queue_append_list(&amp;(<a href="kernel.h.html#5742">fifo</a>)-&gt;<a href="kernel.h.html#2389">_queue</a>, <a href="sys/dlist.h.html#38">head</a>, <a href="spinlock.h.html#63">tail</a>); \</div><div id="2508" class="line none"> 2508         SYS_PORT_TRACING_OBJ_FUNC_EXIT(<a href="kernel.h.html#2388">k_fifo</a>, put_list, <a href="kernel.h.html#5742">fifo</a>, <a href="sys/dlist.h.html#38">head</a>, <a href="spinlock.h.html#63">tail</a>); \</div><div id="2509" class="line none"> 2509         })</div><div id="2510" class="line none"> 2510 </div><div id="2511" class="line none"> 2511 /**</div><div id="2512" class="line none"> 2512  * @brief Atomically add a list of elements to a FIFO queue.</div><div id="2513" class="line none"> 2513  *</div><div id="2514" class="line none"> 2514  * This routine adds a list of data items to @a fifo in one operation.</div><div id="2515" class="line none"> 2515  * The data items must be in a singly-linked list implemented using a</div><div id="2516" class="line none"> 2516  * sys_slist_t object. Upon completion, the sys_slist_t object is invalid</div><div id="2517" class="line none"> 2517  * and must be re-initialized via sys_slist_init().</div><div id="2518" class="line none"> 2518  *</div><div id="2519" class="line none"> 2519  * @funcprops \isr_ok</div><div id="2520" class="line none"> 2520  *</div><div id="2521" class="line none"> 2521  * @param fifo Address of the FIFO queue.</div><div id="2522" class="line none"> 2522  * @param list Pointer to sys_slist_t object.</div><div id="2523" class="line none"> 2523  */</div><div id="2524" class="line none"> 2524 #define <a href="kernel.h.html#2524">k_fifo_put_slist</a>(<a href="kernel.h.html#5742">fifo</a>, <a href="net/mqtt.h.html#272">list</a>) \</div><div id="2525" class="line none"> 2525         ({ \</div><div id="2526" class="line none"> 2526         SYS_PORT_TRACING_OBJ_FUNC_ENTER(<a href="kernel.h.html#2388">k_fifo</a>, put_slist, <a href="kernel.h.html#5742">fifo</a>, <a href="net/mqtt.h.html#272">list</a>); \</div><div id="2527" class="line none"> 2527         k_queue_merge_slist(&amp;(<a href="kernel.h.html#5742">fifo</a>)-&gt;<a href="kernel.h.html#2389">_queue</a>, <a href="net/mqtt.h.html#272">list</a>); \</div><div id="2528" class="line none"> 2528         SYS_PORT_TRACING_OBJ_FUNC_EXIT(<a href="kernel.h.html#2388">k_fifo</a>, put_slist, <a href="kernel.h.html#5742">fifo</a>, <a href="net/mqtt.h.html#272">list</a>); \</div><div id="2529" class="line none"> 2529         })</div><div id="2530" class="line none"> 2530 </div><div id="2531" class="line none"> 2531 /**</div><div id="2532" class="line none"> 2532  * @brief Get an element from a FIFO queue.</div><div id="2533" class="line none"> 2533  *</div><div id="2534" class="line none"> 2534  * This routine removes a data item from @a fifo in a "first in, first out"</div><div id="2535" class="line none"> 2535  * manner. The first word of the data item is reserved for the kernel's use.</div><div id="2536" class="line none"> 2536  *</div><div id="2537" class="line none"> 2537  * @note @a timeout must be set to K_NO_WAIT if called from ISR.</div><div id="2538" class="line none"> 2538  *</div><div id="2539" class="line none"> 2539  * @funcprops \isr_ok</div><div id="2540" class="line none"> 2540  *</div><div id="2541" class="line none"> 2541  * @param fifo Address of the FIFO queue.</div><div id="2542" class="line none"> 2542  * @param timeout Waiting period to obtain a data item,</div><div id="2543" class="line none"> 2543  *                or one of the special values K_NO_WAIT and K_FOREVER.</div><div id="2544" class="line none"> 2544  *</div><div id="2545" class="line none"> 2545  * @return Address of the data item if successful; NULL if returned</div><div id="2546" class="line none"> 2546  * without waiting, or waiting period timed out.</div><div id="2547" class="line none"> 2547  */</div><div id="2548" class="line none"> 2548 #define <a href="kernel.h.html#2548">k_fifo_get</a>(<a href="kernel.h.html#5742">fifo</a>, <a href="kernel.h.html#1452">timeout</a>) \</div><div id="2549" class="line none"> 2549         ({ \</div><div id="2550" class="line none"> 2550         SYS_PORT_TRACING_OBJ_FUNC_ENTER(<a href="kernel.h.html#2388">k_fifo</a>, get, <a href="kernel.h.html#5742">fifo</a>, <a href="kernel.h.html#1452">timeout</a>); \</div><div id="2551" class="line none"> 2551         void *fg_ret = k_queue_get(&amp;(<a href="kernel.h.html#5742">fifo</a>)-&gt;<a href="kernel.h.html#2389">_queue</a>, <a href="kernel.h.html#1452">timeout</a>); \</div><div id="2552" class="line none"> 2552         SYS_PORT_TRACING_OBJ_FUNC_EXIT(<a href="kernel.h.html#2388">k_fifo</a>, get, <a href="kernel.h.html#5742">fifo</a>, <a href="kernel.h.html#1452">timeout</a>, fg_ret); \</div><div id="2553" class="line none"> 2553         fg_ret; \</div><div id="2554" class="line none"> 2554         })</div><div id="2555" class="line none"> 2555 </div><div id="2556" class="line none"> 2556 /**</div><div id="2557" class="line none"> 2557  * @brief Query a FIFO queue to see if it has data available.</div><div id="2558" class="line none"> 2558  *</div><div id="2559" class="line none"> 2559  * Note that the data might be already gone by the time this function returns</div><div id="2560" class="line none"> 2560  * if other threads is also trying to read from the FIFO.</div><div id="2561" class="line none"> 2561  *</div><div id="2562" class="line none"> 2562  * @funcprops \isr_ok</div><div id="2563" class="line none"> 2563  *</div><div id="2564" class="line none"> 2564  * @param fifo Address of the FIFO queue.</div><div id="2565" class="line none"> 2565  *</div><div id="2566" class="line none"> 2566  * @return Non-zero if the FIFO queue is empty.</div><div id="2567" class="line none"> 2567  * @return 0 if data is available.</div><div id="2568" class="line none"> 2568  */</div><div id="2569" class="line none"> 2569 #define <a href="kernel.h.html#2569">k_fifo_is_empty</a>(<a href="kernel.h.html#5742">fifo</a>) \</div><div id="2570" class="line none"> 2570         k_queue_is_empty(&amp;(<a href="kernel.h.html#5742">fifo</a>)-&gt;<a href="kernel.h.html#2389">_queue</a>)</div><div id="2571" class="line none"> 2571 </div><div id="2572" class="line none"> 2572 /**</div><div id="2573" class="line none"> 2573  * @brief Peek element at the head of a FIFO queue.</div><div id="2574" class="line none"> 2574  *</div><div id="2575" class="line none"> 2575  * Return element from the head of FIFO queue without removing it. A usecase</div><div id="2576" class="line none"> 2576  * for this is if elements of the FIFO object are themselves containers. Then</div><div id="2577" class="line none"> 2577  * on each iteration of processing, a head container will be peeked,</div><div id="2578" class="line none"> 2578  * and some data processed out of it, and only if the container is empty,</div><div id="2579" class="line none"> 2579  * it will be completely remove from the FIFO queue.</div><div id="2580" class="line none"> 2580  *</div><div id="2581" class="line none"> 2581  * @param fifo Address of the FIFO queue.</div><div id="2582" class="line none"> 2582  *</div><div id="2583" class="line none"> 2583  * @return Head element, or NULL if the FIFO queue is empty.</div><div id="2584" class="line none"> 2584  */</div><div id="2585" class="line none"> 2585 #define <a href="kernel.h.html#2585">k_fifo_peek_head</a>(<a href="kernel.h.html#5742">fifo</a>) \</div><div id="2586" class="line none"> 2586         ({ \</div><div id="2587" class="line none"> 2587         SYS_PORT_TRACING_OBJ_FUNC_ENTER(<a href="kernel.h.html#2388">k_fifo</a>, peek_head, <a href="kernel.h.html#5742">fifo</a>); \</div><div id="2588" class="line none"> 2588         void *fph_ret = k_queue_peek_head(&amp;(<a href="kernel.h.html#5742">fifo</a>)-&gt;<a href="kernel.h.html#2389">_queue</a>); \</div><div id="2589" class="line none"> 2589         SYS_PORT_TRACING_OBJ_FUNC_EXIT(<a href="kernel.h.html#2388">k_fifo</a>, peek_head, <a href="kernel.h.html#5742">fifo</a>, fph_ret); \</div><div id="2590" class="line none"> 2590         fph_ret; \</div><div id="2591" class="line none"> 2591         })</div><div id="2592" class="line none"> 2592 </div><div id="2593" class="line none"> 2593 /**</div><div id="2594" class="line none"> 2594  * @brief Peek element at the tail of FIFO queue.</div><div id="2595" class="line none"> 2595  *</div><div id="2596" class="line none"> 2596  * Return element from the tail of FIFO queue (without removing it). A usecase</div><div id="2597" class="line none"> 2597  * for this is if elements of the FIFO queue are themselves containers. Then</div><div id="2598" class="line none"> 2598  * it may be useful to add more data to the last container in a FIFO queue.</div><div id="2599" class="line none"> 2599  *</div><div id="2600" class="line none"> 2600  * @param fifo Address of the FIFO queue.</div><div id="2601" class="line none"> 2601  *</div><div id="2602" class="line none"> 2602  * @return Tail element, or NULL if a FIFO queue is empty.</div><div id="2603" class="line none"> 2603  */</div><div id="2604" class="line none"> 2604 #define <a href="kernel.h.html#2604">k_fifo_peek_tail</a>(<a href="kernel.h.html#5742">fifo</a>) \</div><div id="2605" class="line none"> 2605         ({ \</div><div id="2606" class="line none"> 2606         SYS_PORT_TRACING_OBJ_FUNC_ENTER(<a href="kernel.h.html#2388">k_fifo</a>, peek_tail, <a href="kernel.h.html#5742">fifo</a>); \</div><div id="2607" class="line none"> 2607         void *fpt_ret = k_queue_peek_tail(&amp;(<a href="kernel.h.html#5742">fifo</a>)-&gt;<a href="kernel.h.html#2389">_queue</a>); \</div><div id="2608" class="line none"> 2608         SYS_PORT_TRACING_OBJ_FUNC_EXIT(<a href="kernel.h.html#2388">k_fifo</a>, peek_tail, <a href="kernel.h.html#5742">fifo</a>, fpt_ret); \</div><div id="2609" class="line none"> 2609         fpt_ret; \</div><div id="2610" class="line none"> 2610         })</div><div id="2611" class="line none"> 2611 </div><div id="2612" class="line none"> 2612 /**</div><div id="2613" class="line none"> 2613  * @brief Statically define and initialize a FIFO queue.</div><div id="2614" class="line none"> 2614  *</div><div id="2615" class="line none"> 2615  * The FIFO queue can be accessed outside the module where it is defined using:</div><div id="2616" class="line none"> 2616  *</div><div id="2617" class="line none"> 2617  * @code extern struct k_fifo &lt;name&gt;; @endcode</div><div id="2618" class="line none"> 2618  *</div><div id="2619" class="line none"> 2619  * @param name Name of the FIFO queue.</div><div id="2620" class="line none"> 2620  */</div><div id="2621" class="line none"> 2621 #define <a href="kernel.h.html#2621">K_FIFO_DEFINE</a>(<a href="kernel.h.html#4006">name</a>) \</div><div id="2622" class="line none"> 2622         STRUCT_SECTION_ITERABLE(<a href="kernel.h.html#2388">k_fifo</a>, <a href="kernel.h.html#4006">name</a>) = \</div><div id="2623" class="line none"> 2623                 <a href="kernel.h.html#2398">Z_FIFO_INITIALIZER</a>(<a href="kernel.h.html#4006">name</a>)</div><div id="2624" class="line none"> 2624 </div><div id="2625" class="line none"> 2625 /** @} */</div><div id="2626" class="line none"> 2626 </div><div id="2627" class="line none"> 2627 struct <a href="kernel.h.html#2627">k_lifo</a> {</div><div id="2628" class="line none"> 2628         struct <a href="kernel.h.html#1850">k_queue</a> <a href="kernel.h.html#2389">_queue</a>;</div><div id="2629" class="line none"> 2629 #ifdef CONFIG_OBJ_CORE_LIFO</div><div id="2630" class="line none"> 2630         struct k_obj_core  <a href="kernel.h.html#1475">obj_core</a>;</div><div id="2631" class="line none"> 2631 #endif</div><div id="2632" class="line none"> 2632 };</div><div id="2633" class="line none"> 2633 </div><div id="2634" class="line none"> 2634 /**</div><div id="2635" class="line none"> 2635  * @cond INTERNAL_HIDDEN</div><div id="2636" class="line none"> 2636  */</div><div id="2637" class="line none"> 2637 </div><div id="2638" class="line none"> 2638 #define <a href="kernel.h.html#2638">Z_LIFO_INITIALIZER</a>(<a href="kernel.h.html#5739">obj</a>) \</div><div id="2639" class="line none"> 2639         { \</div><div id="2640" class="line none"> 2640         .<a href="kernel.h.html#2389">_queue</a> = <a href="kernel.h.html#1864">Z_QUEUE_INITIALIZER</a>(<a href="kernel.h.html#5739">obj</a>.<a href="kernel.h.html#2389">_queue</a>) \</div><div id="2641" class="line none"> 2641         }</div><div id="2642" class="line none"> 2642 </div><div id="2643" class="line none"> 2643 /**</div><div id="2644" class="line none"> 2644  * INTERNAL_HIDDEN @endcond</div><div id="2645" class="line none"> 2645  */</div><div id="2646" class="line none"> 2646 </div><div id="2647" class="line none"> 2647 /**</div><div id="2648" class="line none"> 2648  * @defgroup lifo_apis LIFO APIs</div><div id="2649" class="line none"> 2649  * @ingroup kernel_apis</div><div id="2650" class="line none"> 2650  * @{</div><div id="2651" class="line none"> 2651  */</div><div id="2652" class="line none"> 2652 </div><div id="2653" class="line none"> 2653 /**</div><div id="2654" class="line none"> 2654  * @brief Initialize a LIFO queue.</div><div id="2655" class="line none"> 2655  *</div><div id="2656" class="line none"> 2656  * This routine initializes a LIFO queue object, prior to its first use.</div><div id="2657" class="line none"> 2657  *</div><div id="2658" class="line none"> 2658  * @param lifo Address of the LIFO queue.</div><div id="2659" class="line none"> 2659  */</div><div id="2660" class="line none"> 2660 #define <a href="kernel.h.html#2660">k_lifo_init</a>(lifo)                                    \</div><div id="2661" class="line none"> 2661         ({                                                   \</div><div id="2662" class="line none"> 2662         SYS_PORT_TRACING_OBJ_FUNC_ENTER(<a href="kernel.h.html#2627">k_lifo</a>, init, lifo); \</div><div id="2663" class="line none"> 2663         k_queue_init(&amp;(lifo)-&gt;<a href="kernel.h.html#2389">_queue</a>);                       \</div><div id="2664" class="line none"> 2664         K_OBJ_CORE_INIT(K_OBJ_CORE(lifo), _obj_type_lifo);   \</div><div id="2665" class="line none"> 2665         K_OBJ_CORE_LINK(K_OBJ_CORE(lifo));                   \</div><div id="2666" class="line none"> 2666         SYS_PORT_TRACING_OBJ_FUNC_EXIT(<a href="kernel.h.html#2627">k_lifo</a>, init, lifo);  \</div><div id="2667" class="line none"> 2667         })</div><div id="2668" class="line none"> 2668 </div><div id="2669" class="line none"> 2669 /**</div><div id="2670" class="line none"> 2670  * @brief Add an element to a LIFO queue.</div><div id="2671" class="line none"> 2671  *</div><div id="2672" class="line none"> 2672  * This routine adds a data item to @a lifo. A LIFO queue data item must be</div><div id="2673" class="line none"> 2673  * aligned on a word boundary, and the first word of the item is</div><div id="2674" class="line none"> 2674  * reserved for the kernel's use.</div><div id="2675" class="line none"> 2675  *</div><div id="2676" class="line none"> 2676  * @funcprops \isr_ok</div><div id="2677" class="line none"> 2677  *</div><div id="2678" class="line none"> 2678  * @param lifo Address of the LIFO queue.</div><div id="2679" class="line none"> 2679  * @param data Address of the data item.</div><div id="2680" class="line none"> 2680  */</div><div id="2681" class="line none"> 2681 #define <a href="kernel.h.html#2681">k_lifo_put</a>(lifo, <a href="logging/log_msg.h.html#100">data</a>) \</div><div id="2682" class="line none"> 2682         ({ \</div><div id="2683" class="line none"> 2683         SYS_PORT_TRACING_OBJ_FUNC_ENTER(<a href="kernel.h.html#2627">k_lifo</a>, put, lifo, <a href="logging/log_msg.h.html#100">data</a>); \</div><div id="2684" class="line none"> 2684         k_queue_prepend(&amp;(lifo)-&gt;<a href="kernel.h.html#2389">_queue</a>, <a href="logging/log_msg.h.html#100">data</a>); \</div><div id="2685" class="line none"> 2685         SYS_PORT_TRACING_OBJ_FUNC_EXIT(<a href="kernel.h.html#2627">k_lifo</a>, put, lifo, <a href="logging/log_msg.h.html#100">data</a>); \</div><div id="2686" class="line none"> 2686         })</div><div id="2687" class="line none"> 2687 </div><div id="2688" class="line none"> 2688 /**</div><div id="2689" class="line none"> 2689  * @brief Add an element to a LIFO queue.</div><div id="2690" class="line none"> 2690  *</div><div id="2691" class="line none"> 2691  * This routine adds a data item to @a lifo. There is an implicit memory</div><div id="2692" class="line none"> 2692  * allocation to create an additional temporary bookkeeping data structure from</div><div id="2693" class="line none"> 2693  * the calling thread's resource pool, which is automatically freed when the</div><div id="2694" class="line none"> 2694  * item is removed. The data itself is not copied.</div><div id="2695" class="line none"> 2695  *</div><div id="2696" class="line none"> 2696  * @funcprops \isr_ok</div><div id="2697" class="line none"> 2697  *</div><div id="2698" class="line none"> 2698  * @param lifo Address of the LIFO.</div><div id="2699" class="line none"> 2699  * @param data Address of the data item.</div><div id="2700" class="line none"> 2700  *</div><div id="2701" class="line none"> 2701  * @retval 0 on success</div><div id="2702" class="line none"> 2702  * @retval -ENOMEM if there isn't sufficient RAM in the caller's resource pool</div><div id="2703" class="line none"> 2703  */</div><div id="2704" class="line none"> 2704 #define <a href="kernel.h.html#2704">k_lifo_alloc_put</a>(lifo, <a href="logging/log_msg.h.html#100">data</a>) \</div><div id="2705" class="line none"> 2705         ({ \</div><div id="2706" class="line none"> 2706         SYS_PORT_TRACING_OBJ_FUNC_ENTER(<a href="kernel.h.html#2627">k_lifo</a>, alloc_put, lifo, <a href="logging/log_msg.h.html#100">data</a>); \</div><div id="2707" class="line none"> 2707         int lap_ret = k_queue_alloc_prepend(&amp;(lifo)-&gt;<a href="kernel.h.html#2389">_queue</a>, <a href="logging/log_msg.h.html#100">data</a>); \</div><div id="2708" class="line none"> 2708         SYS_PORT_TRACING_OBJ_FUNC_EXIT(<a href="kernel.h.html#2627">k_lifo</a>, alloc_put, lifo, <a href="logging/log_msg.h.html#100">data</a>, lap_ret); \</div><div id="2709" class="line none"> 2709         lap_ret; \</div><div id="2710" class="line none"> 2710         })</div><div id="2711" class="line none"> 2711 </div><div id="2712" class="line none"> 2712 /**</div><div id="2713" class="line none"> 2713  * @brief Get an element from a LIFO queue.</div><div id="2714" class="line none"> 2714  *</div><div id="2715" class="line none"> 2715  * This routine removes a data item from @a LIFO in a "last in, first out"</div><div id="2716" class="line none"> 2716  * manner. The first word of the data item is reserved for the kernel's use.</div><div id="2717" class="line none"> 2717  *</div><div id="2718" class="line none"> 2718  * @note @a timeout must be set to K_NO_WAIT if called from ISR.</div><div id="2719" class="line none"> 2719  *</div><div id="2720" class="line none"> 2720  * @funcprops \isr_ok</div><div id="2721" class="line none"> 2721  *</div><div id="2722" class="line none"> 2722  * @param lifo Address of the LIFO queue.</div><div id="2723" class="line none"> 2723  * @param timeout Waiting period to obtain a data item,</div><div id="2724" class="line none"> 2724  *                or one of the special values K_NO_WAIT and K_FOREVER.</div><div id="2725" class="line none"> 2725  *</div><div id="2726" class="line none"> 2726  * @return Address of the data item if successful; NULL if returned</div><div id="2727" class="line none"> 2727  * without waiting, or waiting period timed out.</div><div id="2728" class="line none"> 2728  */</div><div id="2729" class="line none"> 2729 #define <a href="kernel.h.html#2729">k_lifo_get</a>(lifo, <a href="kernel.h.html#1452">timeout</a>) \</div><div id="2730" class="line none"> 2730         ({ \</div><div id="2731" class="line none"> 2731         SYS_PORT_TRACING_OBJ_FUNC_ENTER(<a href="kernel.h.html#2627">k_lifo</a>, get, lifo, <a href="kernel.h.html#1452">timeout</a>); \</div><div id="2732" class="line none"> 2732         void *lg_ret = k_queue_get(&amp;(lifo)-&gt;<a href="kernel.h.html#2389">_queue</a>, <a href="kernel.h.html#1452">timeout</a>); \</div><div id="2733" class="line none"> 2733         SYS_PORT_TRACING_OBJ_FUNC_EXIT(<a href="kernel.h.html#2627">k_lifo</a>, get, lifo, <a href="kernel.h.html#1452">timeout</a>, lg_ret); \</div><div id="2734" class="line none"> 2734         lg_ret; \</div><div id="2735" class="line none"> 2735         })</div><div id="2736" class="line none"> 2736 </div><div id="2737" class="line none"> 2737 /**</div><div id="2738" class="line none"> 2738  * @brief Statically define and initialize a LIFO queue.</div><div id="2739" class="line none"> 2739  *</div><div id="2740" class="line none"> 2740  * The LIFO queue can be accessed outside the module where it is defined using:</div><div id="2741" class="line none"> 2741  *</div><div id="2742" class="line none"> 2742  * @code extern struct k_lifo &lt;name&gt;; @endcode</div><div id="2743" class="line none"> 2743  *</div><div id="2744" class="line none"> 2744  * @param name Name of the fifo.</div><div id="2745" class="line none"> 2745  */</div><div id="2746" class="line none"> 2746 #define <a href="kernel.h.html#2746">K_LIFO_DEFINE</a>(<a href="kernel.h.html#4006">name</a>) \</div><div id="2747" class="line none"> 2747         STRUCT_SECTION_ITERABLE(<a href="kernel.h.html#2627">k_lifo</a>, <a href="kernel.h.html#4006">name</a>) = \</div><div id="2748" class="line none"> 2748                 <a href="kernel.h.html#2638">Z_LIFO_INITIALIZER</a>(<a href="kernel.h.html#4006">name</a>)</div><div id="2749" class="line none"> 2749 </div><div id="2750" class="line none"> 2750 /** @} */</div><div id="2751" class="line none"> 2751 </div><div id="2752" class="line none"> 2752 /**</div><div id="2753" class="line none"> 2753  * @cond INTERNAL_HIDDEN</div><div id="2754" class="line none"> 2754  */</div><div id="2755" class="line none"> 2755 #define <a href="kernel.h.html#2755">K_STACK_FLAG_ALLOC</a>      ((uint8_t)1)    /* Buffer was allocated */</div><div id="2756" class="line none"> 2756 </div><div id="2757" class="line none"> 2757 typedef uintptr_t <a href="kernel.h.html#2757">stack_data_t</a>;</div><div id="2758" class="line none"> 2758 </div><div id="2759" class="line none"> 2759 struct <a href="kernel.h.html#2759">k_stack</a> {</div><div id="2760" class="line none"> 2760         <a href="kernel_structs.h.html#286">_wait_q_t</a> <a href="kernel.h.html#1455">wait_q</a>;</div><div id="2761" class="line none"> 2761         struct <a href="spinlock.h.html#45">k_spinlock</a> <a href="kernel.h.html#1852">lock</a>;</div><div id="2762" class="line none"> 2762         <a href="kernel.h.html#2757">stack_data_t</a> *<a href="kernel.h.html#2762">base</a>, *<a href="kernel.h.html#2762">next</a>, *<a href="kernel.h.html#2762">top</a>;</div><div id="2763" class="line none"> 2763 </div><div id="2764" class="line none"> 2764         uint8_t <a href="kernel.h.html#2764">flags</a>;</div><div id="2765" class="line none"> 2765 </div><div id="2766" class="line none"> 2766         SYS_PORT_TRACING_TRACKING_FIELD(<a href="kernel.h.html#2759">k_stack</a>)</div><div id="2767" class="line none"> 2767 </div><div id="2768" class="line none"> 2768 #ifdef CONFIG_OBJ_CORE_STACK</div><div id="2769" class="line none"> 2769         struct k_obj_core  <a href="kernel.h.html#1475">obj_core</a>;</div><div id="2770" class="line none"> 2770 #endif</div><div id="2771" class="line none"> 2771 };</div><div id="2772" class="line none"> 2772 </div><div id="2773" class="line none"> 2773 #define <a href="kernel.h.html#2773">Z_STACK_INITIALIZER</a>(<a href="kernel.h.html#5739">obj</a>, stack_buffer, stack_num_entries) \</div><div id="2774" class="line none"> 2774         { \</div><div id="2775" class="line none"> 2775         .<a href="kernel.h.html#1455">wait_q</a> = <a href="kernel_structs.h.html#280">Z_WAIT_Q_INIT</a>(&amp;(<a href="kernel.h.html#5739">obj</a>).<a href="kernel.h.html#1455">wait_q</a>), \</div><div id="2776" class="line none"> 2776         .<a href="kernel.h.html#2762">base</a> = (stack_buffer), \</div><div id="2777" class="line none"> 2777         .<a href="kernel.h.html#2762">next</a> = (stack_buffer), \</div><div id="2778" class="line none"> 2778         .<a href="kernel.h.html#2762">top</a> = (stack_buffer) + (stack_num_entries), \</div><div id="2779" class="line none"> 2779         }</div><div id="2780" class="line none"> 2780 </div><div id="2781" class="line none"> 2781 /**</div><div id="2782" class="line none"> 2782  * INTERNAL_HIDDEN @endcond</div><div id="2783" class="line none"> 2783  */</div><div id="2784" class="line none"> 2784 </div><div id="2785" class="line none"> 2785 /**</div><div id="2786" class="line none"> 2786  * @defgroup stack_apis Stack APIs</div><div id="2787" class="line none"> 2787  * @ingroup kernel_apis</div><div id="2788" class="line none"> 2788  * @{</div><div id="2789" class="line none"> 2789  */</div><div id="2790" class="line none"> 2790 </div><div id="2791" class="line none"> 2791 /**</div><div id="2792" class="line none"> 2792  * @brief Initialize a stack.</div><div id="2793" class="line none"> 2793  *</div><div id="2794" class="line none"> 2794  * This routine initializes a stack object, prior to its first use.</div><div id="2795" class="line none"> 2795  *</div><div id="2796" class="line none"> 2796  * @param stack Address of the stack.</div><div id="2797" class="line none"> 2797  * @param buffer Address of array used to hold stacked values.</div><div id="2798" class="line none"> 2798  * @param num_entries Maximum number of values that can be stacked.</div><div id="2799" class="line none"> 2799  */</div><div id="2800" class="line none"> 2800 void k_stack_init(struct <a href="kernel.h.html#2759">k_stack</a> *<a href="sys/rb.h.html#173">stack</a>,</div><div id="2801" class="line none"> 2801                   <a href="kernel.h.html#2757">stack_data_t</a> *<a href="kernel.h.html#4868">buffer</a>, uint32_t num_entries);</div><div id="2802" class="line none"> 2802 </div><div id="2803" class="line none"> 2803 </div><div id="2804" class="line none"> 2804 /**</div><div id="2805" class="line none"> 2805  * @brief Initialize a stack.</div><div id="2806" class="line none"> 2806  *</div><div id="2807" class="line none"> 2807  * This routine initializes a stack object, prior to its first use. Internal</div><div id="2808" class="line none"> 2808  * buffers will be allocated from the calling thread's resource pool.</div><div id="2809" class="line none"> 2809  * This memory will be released if k_stack_cleanup() is called, or</div><div id="2810" class="line none"> 2810  * userspace is enabled and the stack object loses all references to it.</div><div id="2811" class="line none"> 2811  *</div><div id="2812" class="line none"> 2812  * @param stack Address of the stack.</div><div id="2813" class="line none"> 2813  * @param num_entries Maximum number of values that can be stacked.</div><div id="2814" class="line none"> 2814  *</div><div id="2815" class="line none"> 2815  * @return -ENOMEM if memory couldn't be allocated</div><div id="2816" class="line none"> 2816  */</div><div id="2817" class="line none"> 2817 </div><div id="2818" class="line none"> 2818 __syscall int32_t k_stack_alloc_init(struct <a href="kernel.h.html#2759">k_stack</a> *<a href="sys/rb.h.html#173">stack</a>,</div><div id="2819" class="line none"> 2819                                    uint32_t num_entries);</div><div id="2820" class="line none"> 2820 </div><div id="2821" class="line none"> 2821 /**</div><div id="2822" class="line none"> 2822  * @brief Release a stack's allocated buffer</div><div id="2823" class="line none"> 2823  *</div><div id="2824" class="line none"> 2824  * If a stack object was given a dynamically allocated buffer via</div><div id="2825" class="line none"> 2825  * k_stack_alloc_init(), this will free it. This function does nothing</div><div id="2826" class="line none"> 2826  * if the buffer wasn't dynamically allocated.</div><div id="2827" class="line none"> 2827  *</div><div id="2828" class="line none"> 2828  * @param stack Address of the stack.</div><div id="2829" class="line none"> 2829  * @retval 0 on success</div><div id="2830" class="line none"> 2830  * @retval -EAGAIN when object is still in use</div><div id="2831" class="line none"> 2831  */</div><div id="2832" class="line none"> 2832 int k_stack_cleanup(struct <a href="kernel.h.html#2759">k_stack</a> *<a href="sys/rb.h.html#173">stack</a>);</div><div id="2833" class="line none"> 2833 </div><div id="2834" class="line none"> 2834 /**</div><div id="2835" class="line none"> 2835  * @brief Push an element onto a stack.</div><div id="2836" class="line none"> 2836  *</div><div id="2837" class="line none"> 2837  * This routine adds a stack_data_t value @a data to @a stack.</div><div id="2838" class="line none"> 2838  *</div><div id="2839" class="line none"> 2839  * @funcprops \isr_ok</div><div id="2840" class="line none"> 2840  *</div><div id="2841" class="line none"> 2841  * @param stack Address of the stack.</div><div id="2842" class="line none"> 2842  * @param data Value to push onto the stack.</div><div id="2843" class="line none"> 2843  *</div><div id="2844" class="line none"> 2844  * @retval 0 on success</div><div id="2845" class="line none"> 2845  * @retval -ENOMEM if stack is full</div><div id="2846" class="line none"> 2846  */</div><div id="2847" class="line none"> 2847 __syscall int k_stack_push(struct <a href="kernel.h.html#2759">k_stack</a> *<a href="sys/rb.h.html#173">stack</a>, <a href="kernel.h.html#2757">stack_data_t</a> <a href="logging/log_msg.h.html#100">data</a>);</div><div id="2848" class="line none"> 2848 </div><div id="2849" class="line none"> 2849 /**</div><div id="2850" class="line none"> 2850  * @brief Pop an element from a stack.</div><div id="2851" class="line none"> 2851  *</div><div id="2852" class="line none"> 2852  * This routine removes a stack_data_t value from @a stack in a "last in,</div><div id="2853" class="line none"> 2853  * first out" manner and stores the value in @a data.</div><div id="2854" class="line none"> 2854  *</div><div id="2855" class="line none"> 2855  * @note @a timeout must be set to K_NO_WAIT if called from ISR.</div><div id="2856" class="line none"> 2856  *</div><div id="2857" class="line none"> 2857  * @funcprops \isr_ok</div><div id="2858" class="line none"> 2858  *</div><div id="2859" class="line none"> 2859  * @param stack Address of the stack.</div><div id="2860" class="line none"> 2860  * @param data Address of area to hold the value popped from the stack.</div><div id="2861" class="line none"> 2861  * @param timeout Waiting period to obtain a value,</div><div id="2862" class="line none"> 2862  *                or one of the special values K_NO_WAIT and</div><div id="2863" class="line none"> 2863  *                K_FOREVER.</div><div id="2864" class="line none"> 2864  *</div><div id="2865" class="line none"> 2865  * @retval 0 Element popped from stack.</div><div id="2866" class="line none"> 2866  * @retval -EBUSY Returned without waiting.</div><div id="2867" class="line none"> 2867  * @retval -EAGAIN Waiting period timed out.</div><div id="2868" class="line none"> 2868  */</div><div id="2869" class="line none"> 2869 __syscall int k_stack_pop(struct <a href="kernel.h.html#2759">k_stack</a> *<a href="sys/rb.h.html#173">stack</a>, <a href="kernel.h.html#2757">stack_data_t</a> *<a href="logging/log_msg.h.html#100">data</a>,</div><div id="2870" class="line none"> 2870                           k_timeout_t <a href="kernel.h.html#1452">timeout</a>);</div><div id="2871" class="line none"> 2871 </div><div id="2872" class="line none"> 2872 /**</div><div id="2873" class="line none"> 2873  * @brief Statically define and initialize a stack</div><div id="2874" class="line none"> 2874  *</div><div id="2875" class="line none"> 2875  * The stack can be accessed outside the module where it is defined using:</div><div id="2876" class="line none"> 2876  *</div><div id="2877" class="line none"> 2877  * @code extern struct k_stack &lt;name&gt;; @endcode</div><div id="2878" class="line none"> 2878  *</div><div id="2879" class="line none"> 2879  * @param name Name of the stack.</div><div id="2880" class="line none"> 2880  * @param stack_num_entries Maximum number of values that can be stacked.</div><div id="2881" class="line none"> 2881  */</div><div id="2882" class="line none"> 2882 #define <a href="kernel.h.html#2882">K_STACK_DEFINE</a>(<a href="kernel.h.html#4006">name</a>, stack_num_entries)                \</div><div id="2883" class="line none"> 2883         <a href="kernel.h.html#2757">stack_data_t</a> __noinit                                  \</div><div id="2884" class="line none"> 2884                 _k_stack_buf_##<a href="kernel.h.html#4006">name</a>[stack_num_entries];        \</div><div id="2885" class="line none"> 2885         STRUCT_SECTION_ITERABLE(<a href="kernel.h.html#2759">k_stack</a>, <a href="kernel.h.html#4006">name</a>) =               \</div><div id="2886" class="line none"> 2886                 <a href="kernel.h.html#2773">Z_STACK_INITIALIZER</a>(<a href="kernel.h.html#4006">name</a>, _k_stack_buf_##<a href="kernel.h.html#4006">name</a>, \</div><div id="2887" class="line none"> 2887                                     stack_num_entries)</div><div id="2888" class="line none"> 2888 </div><div id="2889" class="line none"> 2889 /** @} */</div><div id="2890" class="line none"> 2890 </div><div id="2891" class="line none"> 2891 /**</div><div id="2892" class="line none"> 2892  * @cond INTERNAL_HIDDEN</div><div id="2893" class="line none"> 2893  */</div><div id="2894" class="line none"> 2894 </div><div id="2895" class="line none"> 2895 struct <a href="kernel.h.html#3877">k_work</a>;</div><div id="2896" class="line none"> 2896 struct <a href="kernel.h.html#4029">k_work_q</a>;</div><div id="2897" class="line none"> 2897 struct <a href="kernel.h.html#4001">k_work_queue_config</a>;</div><div id="2898" class="line none"> 2898 extern struct <a href="kernel.h.html#4029">k_work_q</a> k_sys_work_q;</div><div id="2899" class="line none"> 2899 </div><div id="2900" class="line none"> 2900 /**</div><div id="2901" class="line none"> 2901  * INTERNAL_HIDDEN @endcond</div><div id="2902" class="line none"> 2902  */</div><div id="2903" class="line none"> 2903 </div><div id="2904" class="line none"> 2904 /**</div><div id="2905" class="line none"> 2905  * @defgroup mutex_apis Mutex APIs</div><div id="2906" class="line none"> 2906  * @ingroup kernel_apis</div><div id="2907" class="line none"> 2907  * @{</div><div id="2908" class="line none"> 2908  */</div><div id="2909" class="line none"> 2909 </div><div id="2910" class="line none"> 2910 /**</div><div id="2911" class="line none"> 2911  * Mutex Structure</div><div id="2912" class="line none"> 2912  * @ingroup mutex_apis</div><div id="2913" class="line none"> 2913  */</div><div id="2914" class="line none"> 2914 struct <a href="sys/kobject.h.html#20">k_mutex</a> {</div><div id="2915" class="line none"> 2915         /** Mutex wait queue */</div><div id="2916" class="line none"> 2916         <a href="kernel_structs.h.html#286">_wait_q_t</a> <a href="kernel.h.html#1455">wait_q</a>;</div><div id="2917" class="line none"> 2917         /** Mutex owner */</div><div id="2918" class="line none"> 2918         struct <a href="arch/arch_interface.h.html#43">k_thread</a> *<a href="kernel.h.html#2918">owner</a>;</div><div id="2919" class="line none"> 2919 </div><div id="2920" class="line none"> 2920         /** Current lock count */</div><div id="2921" class="line none"> 2921         uint32_t <a href="kernel.h.html#2921">lock_count</a>;</div><div id="2922" class="line none"> 2922 </div><div id="2923" class="line none"> 2923         /** Original thread priority */</div><div id="2924" class="line none"> 2924         int <a href="kernel.h.html#2924">owner_orig_prio</a>;</div><div id="2925" class="line none"> 2925 </div><div id="2926" class="line none"> 2926         SYS_PORT_TRACING_TRACKING_FIELD(<a href="sys/kobject.h.html#20">k_mutex</a>)</div><div id="2927" class="line none"> 2927 </div><div id="2928" class="line none"> 2928 #ifdef CONFIG_OBJ_CORE_MUTEX</div><div id="2929" class="line none"> 2929         struct k_obj_core <a href="kernel.h.html#1475">obj_core</a>;</div><div id="2930" class="line none"> 2930 #endif</div><div id="2931" class="line none"> 2931 };</div><div id="2932" class="line none"> 2932 </div><div id="2933" class="line none"> 2933 /**</div><div id="2934" class="line none"> 2934  * @cond INTERNAL_HIDDEN</div><div id="2935" class="line none"> 2935  */</div><div id="2936" class="line none"> 2936 #define <a href="kernel.h.html#2936">Z_MUTEX_INITIALIZER</a>(<a href="kernel.h.html#5739">obj</a>) \</div><div id="2937" class="line none"> 2937         { \</div><div id="2938" class="line none"> 2938         .<a href="kernel.h.html#1455">wait_q</a> = <a href="kernel_structs.h.html#280">Z_WAIT_Q_INIT</a>(&amp;(<a href="kernel.h.html#5739">obj</a>).<a href="kernel.h.html#1455">wait_q</a>), \</div><div id="2939" class="line none"> 2939         .<a href="kernel.h.html#2918">owner</a> = NULL, \</div><div id="2940" class="line none"> 2940         .<a href="kernel.h.html#2921">lock_count</a> = 0, \</div><div id="2941" class="line none"> 2941         .<a href="kernel.h.html#2924">owner_orig_prio</a> = <a href="kernel.h.html#60">K_LOWEST_APPLICATION_THREAD_PRIO</a>, \</div><div id="2942" class="line none"> 2942         }</div><div id="2943" class="line none"> 2943 </div><div id="2944" class="line none"> 2944 /**</div><div id="2945" class="line none"> 2945  * INTERNAL_HIDDEN @endcond</div><div id="2946" class="line none"> 2946  */</div><div id="2947" class="line none"> 2947 </div><div id="2948" class="line none"> 2948 /**</div><div id="2949" class="line none"> 2949  * @brief Statically define and initialize a mutex.</div><div id="2950" class="line none"> 2950  *</div><div id="2951" class="line none"> 2951  * The mutex can be accessed outside the module where it is defined using:</div><div id="2952" class="line none"> 2952  *</div><div id="2953" class="line none"> 2953  * @code extern struct k_mutex &lt;name&gt;; @endcode</div><div id="2954" class="line none"> 2954  *</div><div id="2955" class="line none"> 2955  * @param name Name of the mutex.</div><div id="2956" class="line none"> 2956  */</div><div id="2957" class="line none"> 2957 #define <a href="kernel.h.html#2957">K_MUTEX_DEFINE</a>(<a href="kernel.h.html#4006">name</a>) \</div><div id="2958" class="line none"> 2958         STRUCT_SECTION_ITERABLE(<a href="sys/kobject.h.html#20">k_mutex</a>, <a href="kernel.h.html#4006">name</a>) = \</div><div id="2959" class="line none"> 2959                 <a href="kernel.h.html#2936">Z_MUTEX_INITIALIZER</a>(<a href="kernel.h.html#4006">name</a>)</div><div id="2960" class="line none"> 2960 </div><div id="2961" class="line none"> 2961 /**</div><div id="2962" class="line none"> 2962  * @brief Initialize a mutex.</div><div id="2963" class="line none"> 2963  *</div><div id="2964" class="line none"> 2964  * This routine initializes a mutex object, prior to its first use.</div><div id="2965" class="line none"> 2965  *</div><div id="2966" class="line none"> 2966  * Upon completion, the mutex is available and does not have an owner.</div><div id="2967" class="line none"> 2967  *</div><div id="2968" class="line none"> 2968  * @param mutex Address of the mutex.</div><div id="2969" class="line none"> 2969  *</div><div id="2970" class="line none"> 2970  * @retval 0 Mutex object created</div><div id="2971" class="line none"> 2971  *</div><div id="2972" class="line none"> 2972  */</div><div id="2973" class="line none"> 2973 __syscall int k_mutex_init(struct <a href="sys/kobject.h.html#20">k_mutex</a> *<a href="net/mqtt.h.html#473">mutex</a>);</div><div id="2974" class="line none"> 2974 </div><div id="2975" class="line none"> 2975 </div><div id="2976" class="line none"> 2976 /**</div><div id="2977" class="line none"> 2977  * @brief Lock a mutex.</div><div id="2978" class="line none"> 2978  *</div><div id="2979" class="line none"> 2979  * This routine locks @a mutex. If the mutex is locked by another thread,</div><div id="2980" class="line none"> 2980  * the calling thread waits until the mutex becomes available or until</div><div id="2981" class="line none"> 2981  * a timeout occurs.</div><div id="2982" class="line none"> 2982  *</div><div id="2983" class="line none"> 2983  * A thread is permitted to lock a mutex it has already locked. The operation</div><div id="2984" class="line none"> 2984  * completes immediately and the lock count is increased by 1.</div><div id="2985" class="line none"> 2985  *</div><div id="2986" class="line none"> 2986  * Mutexes may not be locked in ISRs.</div><div id="2987" class="line none"> 2987  *</div><div id="2988" class="line none"> 2988  * @param mutex Address of the mutex.</div><div id="2989" class="line none"> 2989  * @param timeout Waiting period to lock the mutex,</div><div id="2990" class="line none"> 2990  *                or one of the special values K_NO_WAIT and</div><div id="2991" class="line none"> 2991  *                K_FOREVER.</div><div id="2992" class="line none"> 2992  *</div><div id="2993" class="line none"> 2993  * @retval 0 Mutex locked.</div><div id="2994" class="line none"> 2994  * @retval -EBUSY Returned without waiting.</div><div id="2995" class="line none"> 2995  * @retval -EAGAIN Waiting period timed out.</div><div id="2996" class="line none"> 2996  */</div><div id="2997" class="line none"> 2997 __syscall int k_mutex_lock(struct <a href="sys/kobject.h.html#20">k_mutex</a> *<a href="net/mqtt.h.html#473">mutex</a>, k_timeout_t <a href="kernel.h.html#1452">timeout</a>);</div><div id="2998" class="line none"> 2998 </div><div id="2999" class="line none"> 2999 /**</div><div id="3000" class="line none"> 3000  * @brief Unlock a mutex.</div><div id="3001" class="line none"> 3001  *</div><div id="3002" class="line none"> 3002  * This routine unlocks @a mutex. The mutex must already be locked by the</div><div id="3003" class="line none"> 3003  * calling thread.</div><div id="3004" class="line none"> 3004  *</div><div id="3005" class="line none"> 3005  * The mutex cannot be claimed by another thread until it has been unlocked by</div><div id="3006" class="line none"> 3006  * the calling thread as many times as it was previously locked by that</div><div id="3007" class="line none"> 3007  * thread.</div><div id="3008" class="line none"> 3008  *</div><div id="3009" class="line none"> 3009  * Mutexes may not be unlocked in ISRs, as mutexes must only be manipulated</div><div id="3010" class="line none"> 3010  * in thread context due to ownership and priority inheritance semantics.</div><div id="3011" class="line none"> 3011  *</div><div id="3012" class="line none"> 3012  * @param mutex Address of the mutex.</div><div id="3013" class="line none"> 3013  *</div><div id="3014" class="line none"> 3014  * @retval 0 Mutex unlocked.</div><div id="3015" class="line none"> 3015  * @retval -EPERM The current thread does not own the mutex</div><div id="3016" class="line none"> 3016  * @retval -EINVAL The mutex is not locked</div><div id="3017" class="line none"> 3017  *</div><div id="3018" class="line none"> 3018  */</div><div id="3019" class="line none"> 3019 __syscall int k_mutex_unlock(struct <a href="sys/kobject.h.html#20">k_mutex</a> *<a href="net/mqtt.h.html#473">mutex</a>);</div><div id="3020" class="line none"> 3020 </div><div id="3021" class="line none"> 3021 /**</div><div id="3022" class="line none"> 3022  * @}</div><div id="3023" class="line none"> 3023  */</div><div id="3024" class="line none"> 3024 </div><div id="3025" class="line none"> 3025 </div><div id="3026" class="line none"> 3026 struct <a href="kernel.h.html#3026">k_condvar</a> {</div><div id="3027" class="line none"> 3027         <a href="kernel_structs.h.html#286">_wait_q_t</a> <a href="kernel.h.html#1455">wait_q</a>;</div><div id="3028" class="line none"> 3028 </div><div id="3029" class="line none"> 3029 #ifdef CONFIG_OBJ_CORE_CONDVAR</div><div id="3030" class="line none"> 3030         struct k_obj_core  <a href="kernel.h.html#1475">obj_core</a>;</div><div id="3031" class="line none"> 3031 #endif</div><div id="3032" class="line none"> 3032 };</div><div id="3033" class="line none"> 3033 </div><div id="3034" class="line none"> 3034 #define <a href="kernel.h.html#3034">Z_CONDVAR_INITIALIZER</a>(<a href="kernel.h.html#5739">obj</a>)                                             \</div><div id="3035" class="line none"> 3035         {                                                                      \</div><div id="3036" class="line none"> 3036                 .<a href="kernel.h.html#1455">wait_q</a> = <a href="kernel_structs.h.html#280">Z_WAIT_Q_INIT</a>(&amp;<a href="kernel.h.html#5739">obj</a>.<a href="kernel.h.html#1455">wait_q</a>),                          \</div><div id="3037" class="line none"> 3037         }</div><div id="3038" class="line none"> 3038 </div><div id="3039" class="line none"> 3039 /**</div><div id="3040" class="line none"> 3040  * @defgroup condvar_apis Condition Variables APIs</div><div id="3041" class="line none"> 3041  * @ingroup kernel_apis</div><div id="3042" class="line none"> 3042  * @{</div><div id="3043" class="line none"> 3043  */</div><div id="3044" class="line none"> 3044 </div><div id="3045" class="line none"> 3045 /**</div><div id="3046" class="line none"> 3046  * @brief Initialize a condition variable</div><div id="3047" class="line none"> 3047  *</div><div id="3048" class="line none"> 3048  * @param condvar pointer to a @p k_condvar structure</div><div id="3049" class="line none"> 3049  * @retval 0 Condition variable created successfully</div><div id="3050" class="line none"> 3050  */</div><div id="3051" class="line none"> 3051 __syscall int k_condvar_init(struct <a href="kernel.h.html#3026">k_condvar</a> *condvar);</div><div id="3052" class="line none"> 3052 </div><div id="3053" class="line none"> 3053 /**</div><div id="3054" class="line none"> 3054  * @brief Signals one thread that is pending on the condition variable</div><div id="3055" class="line none"> 3055  *</div><div id="3056" class="line none"> 3056  * @param condvar pointer to a @p k_condvar structure</div><div id="3057" class="line none"> 3057  * @retval 0 On success</div><div id="3058" class="line none"> 3058  */</div><div id="3059" class="line none"> 3059 __syscall int k_condvar_signal(struct <a href="kernel.h.html#3026">k_condvar</a> *condvar);</div><div id="3060" class="line none"> 3060 </div><div id="3061" class="line none"> 3061 /**</div><div id="3062" class="line none"> 3062  * @brief Unblock all threads that are pending on the condition</div><div id="3063" class="line none"> 3063  * variable</div><div id="3064" class="line none"> 3064  *</div><div id="3065" class="line none"> 3065  * @param condvar pointer to a @p k_condvar structure</div><div id="3066" class="line none"> 3066  * @return An integer with number of woken threads on success</div><div id="3067" class="line none"> 3067  */</div><div id="3068" class="line none"> 3068 __syscall int k_condvar_broadcast(struct <a href="kernel.h.html#3026">k_condvar</a> *condvar);</div><div id="3069" class="line none"> 3069 </div><div id="3070" class="line none"> 3070 /**</div><div id="3071" class="line none"> 3071  * @brief Waits on the condition variable releasing the mutex lock</div><div id="3072" class="line none"> 3072  *</div><div id="3073" class="line none"> 3073  * Atomically releases the currently owned mutex, blocks the current thread</div><div id="3074" class="line none"> 3074  * waiting on the condition variable specified by @a condvar,</div><div id="3075" class="line none"> 3075  * and finally acquires the mutex again.</div><div id="3076" class="line none"> 3076  *</div><div id="3077" class="line none"> 3077  * The waiting thread unblocks only after another thread calls</div><div id="3078" class="line none"> 3078  * k_condvar_signal, or k_condvar_broadcast with the same condition variable.</div><div id="3079" class="line none"> 3079  *</div><div id="3080" class="line none"> 3080  * @param condvar pointer to a @p k_condvar structure</div><div id="3081" class="line none"> 3081  * @param mutex Address of the mutex.</div><div id="3082" class="line none"> 3082  * @param timeout Waiting period for the condition variable</div><div id="3083" class="line none"> 3083  *                or one of the special values K_NO_WAIT and K_FOREVER.</div><div id="3084" class="line none"> 3084  * @retval 0 On success</div><div id="3085" class="line none"> 3085  * @retval -EAGAIN Waiting period timed out.</div><div id="3086" class="line none"> 3086  */</div><div id="3087" class="line none"> 3087 __syscall int k_condvar_wait(struct <a href="kernel.h.html#3026">k_condvar</a> *condvar, struct <a href="sys/kobject.h.html#20">k_mutex</a> *<a href="net/mqtt.h.html#473">mutex</a>,</div><div id="3088" class="line none"> 3088                              k_timeout_t <a href="kernel.h.html#1452">timeout</a>);</div><div id="3089" class="line none"> 3089 </div><div id="3090" class="line none"> 3090 /**</div><div id="3091" class="line none"> 3091  * @brief Statically define and initialize a condition variable.</div><div id="3092" class="line none"> 3092  *</div><div id="3093" class="line none"> 3093  * The condition variable can be accessed outside the module where it is</div><div id="3094" class="line none"> 3094  * defined using:</div><div id="3095" class="line none"> 3095  *</div><div id="3096" class="line none"> 3096  * @code extern struct k_condvar &lt;name&gt;; @endcode</div><div id="3097" class="line none"> 3097  *</div><div id="3098" class="line none"> 3098  * @param name Name of the condition variable.</div><div id="3099" class="line none"> 3099  */</div><div id="3100" class="line none"> 3100 #define <a href="kernel.h.html#3100">K_CONDVAR_DEFINE</a>(<a href="kernel.h.html#4006">name</a>)                                                 \</div><div id="3101" class="line none"> 3101         STRUCT_SECTION_ITERABLE(<a href="kernel.h.html#3026">k_condvar</a>, <a href="kernel.h.html#4006">name</a>) =                             \</div><div id="3102" class="line none"> 3102                 <a href="kernel.h.html#3034">Z_CONDVAR_INITIALIZER</a>(<a href="kernel.h.html#4006">name</a>)</div><div id="3103" class="line none"> 3103 /**</div><div id="3104" class="line none"> 3104  * @}</div><div id="3105" class="line none"> 3105  */</div><div id="3106" class="line none"> 3106 </div><div id="3107" class="line none"> 3107 /**</div><div id="3108" class="line none"> 3108  * @cond INTERNAL_HIDDEN</div><div id="3109" class="line none"> 3109  */</div><div id="3110" class="line none"> 3110 </div><div id="3111" class="line none"> 3111 struct <a href="kernel.h.html#3111">k_sem</a> {</div><div id="3112" class="line none"> 3112         <a href="kernel_structs.h.html#286">_wait_q_t</a> <a href="kernel.h.html#1455">wait_q</a>;</div><div id="3113" class="line none"> 3113         unsigned int <a href="kernel.h.html#3113">count</a>;</div><div id="3114" class="line none"> 3114         unsigned int <a href="kernel.h.html#3114">limit</a>;</div><div id="3115" class="line none"> 3115 </div><div id="3116" class="line none"> 3116         <a href="kernel.h.html#65">Z_DECL_POLL_EVENT</a></div><div id="3117" class="line none"> 3117 </div><div id="3118" class="line none"> 3118         SYS_PORT_TRACING_TRACKING_FIELD(<a href="kernel.h.html#3111">k_sem</a>)</div><div id="3119" class="line none"> 3119 </div><div id="3120" class="line none"> 3120 #ifdef CONFIG_OBJ_CORE_SEM</div><div id="3121" class="line none"> 3121         struct k_obj_core  <a href="kernel.h.html#1475">obj_core</a>;</div><div id="3122" class="line none"> 3122 #endif</div><div id="3123" class="line none"> 3123 };</div><div id="3124" class="line none"> 3124 </div><div id="3125" class="line none"> 3125 #define <a href="kernel.h.html#3125">Z_SEM_INITIALIZER</a>(<a href="kernel.h.html#5739">obj</a>, initial_count, count_limit) \</div><div id="3126" class="line none"> 3126         { \</div><div id="3127" class="line none"> 3127         .<a href="kernel.h.html#1455">wait_q</a> = <a href="kernel_structs.h.html#280">Z_WAIT_Q_INIT</a>(&amp;(<a href="kernel.h.html#5739">obj</a>).<a href="kernel.h.html#1455">wait_q</a>), \</div><div id="3128" class="line none"> 3128         .<a href="kernel.h.html#3113">count</a> = (initial_count), \</div><div id="3129" class="line none"> 3129         .<a href="kernel.h.html#3114">limit</a> = (count_limit), \</div><div id="3130" class="line none"> 3130         <a href="kernel.h.html#63">Z_POLL_EVENT_OBJ_INIT</a>(<a href="kernel.h.html#5739">obj</a>) \</div><div id="3131" class="line none"> 3131         }</div><div id="3132" class="line none"> 3132 </div><div id="3133" class="line none"> 3133 /**</div><div id="3134" class="line none"> 3134  * INTERNAL_HIDDEN @endcond</div><div id="3135" class="line none"> 3135  */</div><div id="3136" class="line none"> 3136 </div><div id="3137" class="line none"> 3137 /**</div><div id="3138" class="line none"> 3138  * @defgroup semaphore_apis Semaphore APIs</div><div id="3139" class="line none"> 3139  * @ingroup kernel_apis</div><div id="3140" class="line none"> 3140  * @{</div><div id="3141" class="line none"> 3141  */</div><div id="3142" class="line none"> 3142 </div><div id="3143" class="line none"> 3143 /**</div><div id="3144" class="line none"> 3144  * @brief Maximum limit value allowed for a semaphore.</div><div id="3145" class="line none"> 3145  *</div><div id="3146" class="line none"> 3146  * This is intended for use when a semaphore does not have</div><div id="3147" class="line none"> 3147  * an explicit maximum limit, and instead is just used for</div><div id="3148" class="line none"> 3148  * counting purposes.</div><div id="3149" class="line none"> 3149  *</div><div id="3150" class="line none"> 3150  */</div><div id="3151" class="line none"> 3151 #define <a href="kernel.h.html#3151">K_SEM_MAX_LIMIT</a> UINT_MAX</div><div id="3152" class="line none"> 3152 </div><div id="3153" class="line none"> 3153 /**</div><div id="3154" class="line none"> 3154  * @brief Initialize a semaphore.</div><div id="3155" class="line none"> 3155  *</div><div id="3156" class="line none"> 3156  * This routine initializes a semaphore object, prior to its first use.</div><div id="3157" class="line none"> 3157  *</div><div id="3158" class="line none"> 3158  * @param sem Address of the semaphore.</div><div id="3159" class="line none"> 3159  * @param initial_count Initial semaphore count.</div><div id="3160" class="line none"> 3160  * @param limit Maximum permitted semaphore count.</div><div id="3161" class="line none"> 3161  *</div><div id="3162" class="line none"> 3162  * @see K_SEM_MAX_LIMIT</div><div id="3163" class="line none"> 3163  *</div><div id="3164" class="line none"> 3164  * @retval 0 Semaphore created successfully</div><div id="3165" class="line none"> 3165  * @retval -EINVAL Invalid values</div><div id="3166" class="line none"> 3166  *</div><div id="3167" class="line none"> 3167  */</div><div id="3168" class="line none"> 3168 __syscall int k_sem_init(struct <a href="kernel.h.html#3111">k_sem</a> *<a href="kernel.h.html#3956">sem</a>, unsigned int initial_count,</div><div id="3169" class="line none"> 3169                           unsigned int <a href="kernel.h.html#3114">limit</a>);</div><div id="3170" class="line none"> 3170 </div><div id="3171" class="line none"> 3171 /**</div><div id="3172" class="line none"> 3172  * @brief Take a semaphore.</div><div id="3173" class="line none"> 3173  *</div><div id="3174" class="line none"> 3174  * This routine takes @a sem.</div><div id="3175" class="line none"> 3175  *</div><div id="3176" class="line none"> 3176  * @note @a timeout must be set to K_NO_WAIT if called from ISR.</div><div id="3177" class="line none"> 3177  *</div><div id="3178" class="line none"> 3178  * @funcprops \isr_ok</div><div id="3179" class="line none"> 3179  *</div><div id="3180" class="line none"> 3180  * @param sem Address of the semaphore.</div><div id="3181" class="line none"> 3181  * @param timeout Waiting period to take the semaphore,</div><div id="3182" class="line none"> 3182  *                or one of the special values K_NO_WAIT and K_FOREVER.</div><div id="3183" class="line none"> 3183  *</div><div id="3184" class="line none"> 3184  * @retval 0 Semaphore taken.</div><div id="3185" class="line none"> 3185  * @retval -EBUSY Returned without waiting.</div><div id="3186" class="line none"> 3186  * @retval -EAGAIN Waiting period timed out,</div><div id="3187" class="line none"> 3187  *                      or the semaphore was reset during the waiting period.</div><div id="3188" class="line none"> 3188  */</div><div id="3189" class="line none"> 3189 __syscall int k_sem_take(struct <a href="kernel.h.html#3111">k_sem</a> *<a href="kernel.h.html#3956">sem</a>, k_timeout_t <a href="kernel.h.html#1452">timeout</a>);</div><div id="3190" class="line none"> 3190 </div><div id="3191" class="line none"> 3191 /**</div><div id="3192" class="line none"> 3192  * @brief Give a semaphore.</div><div id="3193" class="line none"> 3193  *</div><div id="3194" class="line none"> 3194  * This routine gives @a sem, unless the semaphore is already at its maximum</div><div id="3195" class="line none"> 3195  * permitted count.</div><div id="3196" class="line none"> 3196  *</div><div id="3197" class="line none"> 3197  * @funcprops \isr_ok</div><div id="3198" class="line none"> 3198  *</div><div id="3199" class="line none"> 3199  * @param sem Address of the semaphore.</div><div id="3200" class="line none"> 3200  */</div><div id="3201" class="line none"> 3201 __syscall void k_sem_give(struct <a href="kernel.h.html#3111">k_sem</a> *<a href="kernel.h.html#3956">sem</a>);</div><div id="3202" class="line none"> 3202 </div><div id="3203" class="line none"> 3203 /**</div><div id="3204" class="line none"> 3204  * @brief Resets a semaphore's count to zero.</div><div id="3205" class="line none"> 3205  *</div><div id="3206" class="line none"> 3206  * This routine sets the count of @a sem to zero.</div><div id="3207" class="line none"> 3207  * Any outstanding semaphore takes will be aborted</div><div id="3208" class="line none"> 3208  * with -EAGAIN.</div><div id="3209" class="line none"> 3209  *</div><div id="3210" class="line none"> 3210  * @param sem Address of the semaphore.</div><div id="3211" class="line none"> 3211  */</div><div id="3212" class="line none"> 3212 __syscall void k_sem_reset(struct <a href="kernel.h.html#3111">k_sem</a> *<a href="kernel.h.html#3956">sem</a>);</div><div id="3213" class="line none"> 3213 </div><div id="3214" class="line none"> 3214 /**</div><div id="3215" class="line none"> 3215  * @brief Get a semaphore's count.</div><div id="3216" class="line none"> 3216  *</div><div id="3217" class="line none"> 3217  * This routine returns the current count of @a sem.</div><div id="3218" class="line none"> 3218  *</div><div id="3219" class="line none"> 3219  * @param sem Address of the semaphore.</div><div id="3220" class="line none"> 3220  *</div><div id="3221" class="line none"> 3221  * @return Current semaphore count.</div><div id="3222" class="line none"> 3222  */</div><div id="3223" class="line none"> 3223 __syscall unsigned int k_sem_count_get(struct <a href="kernel.h.html#3111">k_sem</a> *<a href="kernel.h.html#3956">sem</a>);</div><div id="3224" class="line none"> 3224 </div><div id="3225" class="line none"> 3225 /**</div><div id="3226" class="line none"> 3226  * @internal</div><div id="3227" class="line none"> 3227  */</div><div id="3228" class="line none"> 3228 static inline unsigned int <a href="kernel.h.html#3228">z_impl_k_sem_count_get</a>(struct <a href="kernel.h.html#3111">k_sem</a> *<a href="kernel.h.html#3956">sem</a>)</div><div id="3229" class="line none"> 3229 {</div><div id="3230" class="line none"> 3230         return <a href="kernel.h.html#3956">sem</a>-&gt;<a href="kernel.h.html#3113">count</a>;</div><div id="3231" class="line none"> 3231 }</div><div id="3232" class="line none"> 3232 </div><div id="3233" class="line none"> 3233 /**</div><div id="3234" class="line none"> 3234  * @brief Statically define and initialize a semaphore.</div><div id="3235" class="line none"> 3235  *</div><div id="3236" class="line none"> 3236  * The semaphore can be accessed outside the module where it is defined using:</div><div id="3237" class="line none"> 3237  *</div><div id="3238" class="line none"> 3238  * @code extern struct k_sem &lt;name&gt;; @endcode</div><div id="3239" class="line none"> 3239  *</div><div id="3240" class="line none"> 3240  * @param name Name of the semaphore.</div><div id="3241" class="line none"> 3241  * @param initial_count Initial semaphore count.</div><div id="3242" class="line none"> 3242  * @param count_limit Maximum permitted semaphore count.</div><div id="3243" class="line none"> 3243  */</div><div id="3244" class="line none"> 3244 #define <a href="kernel.h.html#3244">K_SEM_DEFINE</a>(<a href="kernel.h.html#4006">name</a>, initial_count, count_limit) \</div><div id="3245" class="line none"> 3245         STRUCT_SECTION_ITERABLE(<a href="kernel.h.html#3111">k_sem</a>, <a href="kernel.h.html#4006">name</a>) = \</div><div id="3246" class="line none"> 3246                 <a href="kernel.h.html#3125">Z_SEM_INITIALIZER</a>(<a href="kernel.h.html#4006">name</a>, initial_count, count_limit); \</div><div id="3247" class="line none"> 3247         BUILD_ASSERT(((count_limit) != 0) &amp;&amp; \</div><div id="3248" class="line none"> 3248                      ((initial_count) &lt;= (count_limit)) &amp;&amp; \</div><div id="3249" class="line none"> 3249                          ((count_limit) &lt;= <a href="kernel.h.html#3151">K_SEM_MAX_LIMIT</a>));</div><div id="3250" class="line none"> 3250 </div><div id="3251" class="line none"> 3251 /** @} */</div><div id="3252" class="line none"> 3252 </div><div id="3253" class="line none"> 3253 /**</div><div id="3254" class="line none"> 3254  * @cond INTERNAL_HIDDEN</div><div id="3255" class="line none"> 3255  */</div><div id="3256" class="line none"> 3256 </div><div id="3257" class="line none"> 3257 struct <a href="kernel.h.html#3905">k_work_delayable</a>;</div><div id="3258" class="line none"> 3258 struct <a href="kernel.h.html#3988">k_work_sync</a>;</div><div id="3259" class="line none"> 3259 </div><div id="3260" class="line none"> 3260 /**</div><div id="3261" class="line none"> 3261  * INTERNAL_HIDDEN @endcond</div><div id="3262" class="line none"> 3262  */</div><div id="3263" class="line none"> 3263 </div><div id="3264" class="line none"> 3264 /**</div><div id="3265" class="line none"> 3265  * @defgroup workqueue_apis Work Queue APIs</div><div id="3266" class="line none"> 3266  * @ingroup kernel_apis</div><div id="3267" class="line none"> 3267  * @{</div><div id="3268" class="line none"> 3268  */</div><div id="3269" class="line none"> 3269 </div><div id="3270" class="line none"> 3270 /** @brief The signature for a work item handler function.</div><div id="3271" class="line none"> 3271  *</div><div id="3272" class="line none"> 3272  * The function will be invoked by the thread animating a work queue.</div><div id="3273" class="line none"> 3273  *</div><div id="3274" class="line none"> 3274  * @param work the work item that provided the handler.</div><div id="3275" class="line none"> 3275  */</div><div id="3276" class="line none"> 3276 typedef void (*<a href="kernel.h.html#3276">k_work_handler_t</a>)(struct <a href="kernel.h.html#3877">k_work</a> *<a href="kernel.h.html#3907">work</a>);</div><div id="3277" class="line none"> 3277 </div><div id="3278" class="line none"> 3278 /** @brief Initialize a (non-delayable) work structure.</div><div id="3279" class="line none"> 3279  *</div><div id="3280" class="line none"> 3280  * This must be invoked before submitting a work structure for the first time.</div><div id="3281" class="line none"> 3281  * It need not be invoked again on the same work structure.  It can be</div><div id="3282" class="line none"> 3282  * re-invoked to change the associated handler, but this must be done when the</div><div id="3283" class="line none"> 3283  * work item is idle.</div><div id="3284" class="line none"> 3284  *</div><div id="3285" class="line none"> 3285  * @funcprops \isr_ok</div><div id="3286" class="line none"> 3286  *</div><div id="3287" class="line none"> 3287  * @param work the work structure to be initialized.</div><div id="3288" class="line none"> 3288  *</div><div id="3289" class="line none"> 3289  * @param handler the handler to be invoked by the work item.</div><div id="3290" class="line none"> 3290  */</div><div id="3291" class="line none"> 3291 void k_work_init(struct <a href="kernel.h.html#3877">k_work</a> *<a href="kernel.h.html#3907">work</a>,</div><div id="3292" class="line none"> 3292                   <a href="kernel.h.html#3276">k_work_handler_t</a> <a href="kernel.h.html#3886">handler</a>);</div><div id="3293" class="line none"> 3293 </div><div id="3294" class="line none"> 3294 /** @brief Busy state flags from the work item.</div><div id="3295" class="line none"> 3295  *</div><div id="3296" class="line none"> 3296  * A zero return value indicates the work item appears to be idle.</div><div id="3297" class="line none"> 3297  *</div><div id="3298" class="line none"> 3298  * @note This is a live snapshot of state, which may change before the result</div><div id="3299" class="line none"> 3299  * is checked.  Use locks where appropriate.</div><div id="3300" class="line none"> 3300  *</div><div id="3301" class="line none"> 3301  * @funcprops \isr_ok</div><div id="3302" class="line none"> 3302  *</div><div id="3303" class="line none"> 3303  * @param work pointer to the work item.</div><div id="3304" class="line none"> 3304  *</div><div id="3305" class="line none"> 3305  * @return a mask of flags K_WORK_DELAYED, K_WORK_QUEUED,</div><div id="3306" class="line none"> 3306  * K_WORK_RUNNING, K_WORK_CANCELING, and K_WORK_FLUSHING.</div><div id="3307" class="line none"> 3307  */</div><div id="3308" class="line none"> 3308 int k_work_busy_get(const struct <a href="kernel.h.html#3877">k_work</a> *<a href="kernel.h.html#3907">work</a>);</div><div id="3309" class="line none"> 3309 </div><div id="3310" class="line none"> 3310 /** @brief Test whether a work item is currently pending.</div><div id="3311" class="line none"> 3311  *</div><div id="3312" class="line none"> 3312  * Wrapper to determine whether a work item is in a non-idle dstate.</div><div id="3313" class="line none"> 3313  *</div><div id="3314" class="line none"> 3314  * @note This is a live snapshot of state, which may change before the result</div><div id="3315" class="line none"> 3315  * is checked.  Use locks where appropriate.</div><div id="3316" class="line none"> 3316  *</div><div id="3317" class="line none"> 3317  * @funcprops \isr_ok</div><div id="3318" class="line none"> 3318  *</div><div id="3319" class="line none"> 3319  * @param work pointer to the work item.</div><div id="3320" class="line none"> 3320  *</div><div id="3321" class="line none"> 3321  * @return true if and only if k_work_busy_get() returns a non-zero value.</div><div id="3322" class="line none"> 3322  */</div><div id="3323" class="line none"> 3323 static inline bool <a href="kernel.h.html#4052">k_work_is_pending</a>(const struct <a href="kernel.h.html#3877">k_work</a> *<a href="kernel.h.html#3907">work</a>);</div><div id="3324" class="line none"> 3324 </div><div id="3325" class="line none"> 3325 /** @brief Submit a work item to a queue.</div><div id="3326" class="line none"> 3326  *</div><div id="3327" class="line none"> 3327  * @param queue pointer to the work queue on which the item should run.  If</div><div id="3328" class="line none"> 3328  * NULL the queue from the most recent submission will be used.</div><div id="3329" class="line none"> 3329  *</div><div id="3330" class="line none"> 3330  * @funcprops \isr_ok</div><div id="3331" class="line none"> 3331  *</div><div id="3332" class="line none"> 3332  * @param work pointer to the work item.</div><div id="3333" class="line none"> 3333  *</div><div id="3334" class="line none"> 3334  * @retval 0 if work was already submitted to a queue</div><div id="3335" class="line none"> 3335  * @retval 1 if work was not submitted and has been queued to @p queue</div><div id="3336" class="line none"> 3336  * @retval 2 if work was running and has been queued to the queue that was</div><div id="3337" class="line none"> 3337  * running it</div><div id="3338" class="line none"> 3338  * @retval -EBUSY</div><div id="3339" class="line none"> 3339  * * if work submission was rejected because the work item is cancelling; or</div><div id="3340" class="line none"> 3340  * * @p queue is draining; or</div><div id="3341" class="line none"> 3341  * * @p queue is plugged.</div><div id="3342" class="line none"> 3342  * @retval -EINVAL if @p queue is null and the work item has never been run.</div><div id="3343" class="line none"> 3343  * @retval -ENODEV if @p queue has not been started.</div><div id="3344" class="line none"> 3344  */</div><div id="3345" class="line none"> 3345 int k_work_submit_to_queue(struct <a href="kernel.h.html#4029">k_work_q</a> *<a href="kernel.h.html#3889">queue</a>,</div><div id="3346" class="line none"> 3346                            struct <a href="kernel.h.html#3877">k_work</a> *<a href="kernel.h.html#3907">work</a>);</div><div id="3347" class="line none"> 3347 </div><div id="3348" class="line none"> 3348 /** @brief Submit a work item to the system queue.</div><div id="3349" class="line none"> 3349  *</div><div id="3350" class="line none"> 3350  * @funcprops \isr_ok</div><div id="3351" class="line none"> 3351  *</div><div id="3352" class="line none"> 3352  * @param work pointer to the work item.</div><div id="3353" class="line none"> 3353  *</div><div id="3354" class="line none"> 3354  * @return as with k_work_submit_to_queue().</div><div id="3355" class="line none"> 3355  */</div><div id="3356" class="line none"> 3356 int k_work_submit(struct <a href="kernel.h.html#3877">k_work</a> *<a href="kernel.h.html#3907">work</a>);</div><div id="3357" class="line none"> 3357 </div><div id="3358" class="line none"> 3358 /** @brief Wait for last-submitted instance to complete.</div><div id="3359" class="line none"> 3359  *</div><div id="3360" class="line none"> 3360  * Resubmissions may occur while waiting, including chained submissions (from</div><div id="3361" class="line none"> 3361  * within the handler).</div><div id="3362" class="line none"> 3362  *</div><div id="3363" class="line none"> 3363  * @note Be careful of caller and work queue thread relative priority.  If</div><div id="3364" class="line none"> 3364  * this function sleeps it will not return until the work queue thread</div><div id="3365" class="line none"> 3365  * completes the tasks that allow this thread to resume.</div><div id="3366" class="line none"> 3366  *</div><div id="3367" class="line none"> 3367  * @note Behavior is undefined if this function is invoked on @p work from a</div><div id="3368" class="line none"> 3368  * work queue running @p work.</div><div id="3369" class="line none"> 3369  *</div><div id="3370" class="line none"> 3370  * @param work pointer to the work item.</div><div id="3371" class="line none"> 3371  *</div><div id="3372" class="line none"> 3372  * @param sync pointer to an opaque item containing state related to the</div><div id="3373" class="line none"> 3373  * pending cancellation.  The object must persist until the call returns, and</div><div id="3374" class="line none"> 3374  * be accessible from both the caller thread and the work queue thread.  The</div><div id="3375" class="line none"> 3375  * object must not be used for any other flush or cancel operation until this</div><div id="3376" class="line none"> 3376  * one completes.  On architectures with CONFIG_KERNEL_COHERENCE the object</div><div id="3377" class="line none"> 3377  * must be allocated in coherent memory.</div><div id="3378" class="line none"> 3378  *</div><div id="3379" class="line none"> 3379  * @retval true if call had to wait for completion</div><div id="3380" class="line none"> 3380  * @retval false if work was already idle</div><div id="3381" class="line none"> 3381  */</div><div id="3382" class="line none"> 3382 bool k_work_flush(struct <a href="kernel.h.html#3877">k_work</a> *<a href="kernel.h.html#3907">work</a>,</div><div id="3383" class="line none"> 3383                   struct <a href="kernel.h.html#3988">k_work_sync</a> *sync);</div><div id="3384" class="line none"> 3384 </div><div id="3385" class="line none"> 3385 /** @brief Cancel a work item.</div><div id="3386" class="line none"> 3386  *</div><div id="3387" class="line none"> 3387  * This attempts to prevent a pending (non-delayable) work item from being</div><div id="3388" class="line none"> 3388  * processed by removing it from the work queue.  If the item is being</div><div id="3389" class="line none"> 3389  * processed, the work item will continue to be processed, but resubmissions</div><div id="3390" class="line none"> 3390  * are rejected until cancellation completes.</div><div id="3391" class="line none"> 3391  *</div><div id="3392" class="line none"> 3392  * If this returns zero cancellation is complete, otherwise something</div><div id="3393" class="line none"> 3393  * (probably a work queue thread) is still referencing the item.</div><div id="3394" class="line none"> 3394  *</div><div id="3395" class="line none"> 3395  * See also k_work_cancel_sync().</div><div id="3396" class="line none"> 3396  *</div><div id="3397" class="line none"> 3397  * @funcprops \isr_ok</div><div id="3398" class="line none"> 3398  *</div><div id="3399" class="line none"> 3399  * @param work pointer to the work item.</div><div id="3400" class="line none"> 3400  *</div><div id="3401" class="line none"> 3401  * @return the k_work_busy_get() status indicating the state of the item after all</div><div id="3402" class="line none"> 3402  * cancellation steps performed by this call are completed.</div><div id="3403" class="line none"> 3403  */</div><div id="3404" class="line none"> 3404 int k_work_cancel(struct <a href="kernel.h.html#3877">k_work</a> *<a href="kernel.h.html#3907">work</a>);</div><div id="3405" class="line none"> 3405 </div><div id="3406" class="line none"> 3406 /** @brief Cancel a work item and wait for it to complete.</div><div id="3407" class="line none"> 3407  *</div><div id="3408" class="line none"> 3408  * Same as k_work_cancel() but does not return until cancellation is complete.</div><div id="3409" class="line none"> 3409  * This can be invoked by a thread after k_work_cancel() to synchronize with a</div><div id="3410" class="line none"> 3410  * previous cancellation.</div><div id="3411" class="line none"> 3411  *</div><div id="3412" class="line none"> 3412  * On return the work structure will be idle unless something submits it after</div><div id="3413" class="line none"> 3413  * the cancellation was complete.</div><div id="3414" class="line none"> 3414  *</div><div id="3415" class="line none"> 3415  * @note Be careful of caller and work queue thread relative priority.  If</div><div id="3416" class="line none"> 3416  * this function sleeps it will not return until the work queue thread</div><div id="3417" class="line none"> 3417  * completes the tasks that allow this thread to resume.</div><div id="3418" class="line none"> 3418  *</div><div id="3419" class="line none"> 3419  * @note Behavior is undefined if this function is invoked on @p work from a</div><div id="3420" class="line none"> 3420  * work queue running @p work.</div><div id="3421" class="line none"> 3421  *</div><div id="3422" class="line none"> 3422  * @param work pointer to the work item.</div><div id="3423" class="line none"> 3423  *</div><div id="3424" class="line none"> 3424  * @param sync pointer to an opaque item containing state related to the</div><div id="3425" class="line none"> 3425  * pending cancellation.  The object must persist until the call returns, and</div><div id="3426" class="line none"> 3426  * be accessible from both the caller thread and the work queue thread.  The</div><div id="3427" class="line none"> 3427  * object must not be used for any other flush or cancel operation until this</div><div id="3428" class="line none"> 3428  * one completes.  On architectures with CONFIG_KERNEL_COHERENCE the object</div><div id="3429" class="line none"> 3429  * must be allocated in coherent memory.</div><div id="3430" class="line none"> 3430  *</div><div id="3431" class="line none"> 3431  * @retval true if work was pending (call had to wait for cancellation of a</div><div id="3432" class="line none"> 3432  * running handler to complete, or scheduled or submitted operations were</div><div id="3433" class="line none"> 3433  * cancelled);</div><div id="3434" class="line none"> 3434  * @retval false otherwise</div><div id="3435" class="line none"> 3435  */</div><div id="3436" class="line none"> 3436 bool k_work_cancel_sync(struct <a href="kernel.h.html#3877">k_work</a> *<a href="kernel.h.html#3907">work</a>, struct <a href="kernel.h.html#3988">k_work_sync</a> *sync);</div><div id="3437" class="line none"> 3437 </div><div id="3438" class="line none"> 3438 /** @brief Initialize a work queue structure.</div><div id="3439" class="line none"> 3439  *</div><div id="3440" class="line none"> 3440  * This must be invoked before starting a work queue structure for the first time.</div><div id="3441" class="line none"> 3441  * It need not be invoked again on the same work queue structure.</div><div id="3442" class="line none"> 3442  *</div><div id="3443" class="line none"> 3443  * @funcprops \isr_ok</div><div id="3444" class="line none"> 3444  *</div><div id="3445" class="line none"> 3445  * @param queue the queue structure to be initialized.</div><div id="3446" class="line none"> 3446  */</div><div id="3447" class="line none"> 3447 void k_work_queue_init(struct <a href="kernel.h.html#4029">k_work_q</a> *<a href="kernel.h.html#3889">queue</a>);</div><div id="3448" class="line none"> 3448 </div><div id="3449" class="line none"> 3449 /** @brief Initialize a work queue.</div><div id="3450" class="line none"> 3450  *</div><div id="3451" class="line none"> 3451  * This configures the work queue thread and starts it running.  The function</div><div id="3452" class="line none"> 3452  * should not be re-invoked on a queue.</div><div id="3453" class="line none"> 3453  *</div><div id="3454" class="line none"> 3454  * @param queue pointer to the queue structure. It must be initialized</div><div id="3455" class="line none"> 3455  *        in zeroed/bss memory or with @ref k_work_queue_init before</div><div id="3456" class="line none"> 3456  *        use.</div><div id="3457" class="line none"> 3457  *</div><div id="3458" class="line none"> 3458  * @param stack pointer to the work thread stack area.</div><div id="3459" class="line none"> 3459  *</div><div id="3460" class="line none"> 3460  * @param stack_size size of the work thread stack area, in bytes.</div><div id="3461" class="line none"> 3461  *</div><div id="3462" class="line none"> 3462  * @param prio initial thread priority</div><div id="3463" class="line none"> 3463  *</div><div id="3464" class="line none"> 3464  * @param cfg optional additional configuration parameters.  Pass @c</div><div id="3465" class="line none"> 3465  * NULL if not required, to use the defaults documented in</div><div id="3466" class="line none"> 3466  * k_work_queue_config.</div><div id="3467" class="line none"> 3467  */</div><div id="3468" class="line none"> 3468 void k_work_queue_start(struct <a href="kernel.h.html#4029">k_work_q</a> *<a href="kernel.h.html#3889">queue</a>,</div><div id="3469" class="line none"> 3469                         <a href="arch/arch_interface.h.html#46">k_thread_stack_t</a> *<a href="sys/rb.h.html#173">stack</a>, size_t stack_size,</div><div id="3470" class="line none"> 3470                         int <a href="kernel/thread.h.html#95">prio</a>, const struct <a href="kernel.h.html#4001">k_work_queue_config</a> *cfg);</div><div id="3471" class="line none"> 3471 </div><div id="3472" class="line none"> 3472 /** @brief Access the thread that animates a work queue.</div><div id="3473" class="line none"> 3473  *</div><div id="3474" class="line none"> 3474  * This is necessary to grant a work queue thread access to things the work</div><div id="3475" class="line none"> 3475  * items it will process are expected to use.</div><div id="3476" class="line none"> 3476  *</div><div id="3477" class="line none"> 3477  * @param queue pointer to the queue structure.</div><div id="3478" class="line none"> 3478  *</div><div id="3479" class="line none"> 3479  * @return the thread associated with the work queue.</div><div id="3480" class="line none"> 3480  */</div><div id="3481" class="line none"> 3481 static inline <a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4081">k_work_queue_thread_get</a>(struct <a href="kernel.h.html#4029">k_work_q</a> *<a href="kernel.h.html#3889">queue</a>);</div><div id="3482" class="line none"> 3482 </div><div id="3483" class="line none"> 3483 /** @brief Wait until the work queue has drained, optionally plugging it.</div><div id="3484" class="line none"> 3484  *</div><div id="3485" class="line none"> 3485  * This blocks submission to the work queue except when coming from queue</div><div id="3486" class="line none"> 3486  * thread, and blocks the caller until no more work items are available in the</div><div id="3487" class="line none"> 3487  * queue.</div><div id="3488" class="line none"> 3488  *</div><div id="3489" class="line none"> 3489  * If @p plug is true then submission will continue to be blocked after the</div><div id="3490" class="line none"> 3490  * drain operation completes until k_work_queue_unplug() is invoked.</div><div id="3491" class="line none"> 3491  *</div><div id="3492" class="line none"> 3492  * Note that work items that are delayed are not yet associated with their</div><div id="3493" class="line none"> 3493  * work queue.  They must be cancelled externally if a goal is to ensure the</div><div id="3494" class="line none"> 3494  * work queue remains empty.  The @p plug feature can be used to prevent</div><div id="3495" class="line none"> 3495  * delayed items from being submitted after the drain completes.</div><div id="3496" class="line none"> 3496  *</div><div id="3497" class="line none"> 3497  * @param queue pointer to the queue structure.</div><div id="3498" class="line none"> 3498  *</div><div id="3499" class="line none"> 3499  * @param plug if true the work queue will continue to block new submissions</div><div id="3500" class="line none"> 3500  * after all items have drained.</div><div id="3501" class="line none"> 3501  *</div><div id="3502" class="line none"> 3502  * @retval 1 if call had to wait for the drain to complete</div><div id="3503" class="line none"> 3503  * @retval 0 if call did not have to wait</div><div id="3504" class="line none"> 3504  * @retval negative if wait was interrupted or failed</div><div id="3505" class="line none"> 3505  */</div><div id="3506" class="line none"> 3506 int k_work_queue_drain(struct <a href="kernel.h.html#4029">k_work_q</a> *<a href="kernel.h.html#3889">queue</a>, bool plug);</div><div id="3507" class="line none"> 3507 </div><div id="3508" class="line none"> 3508 /** @brief Release a work queue to accept new submissions.</div><div id="3509" class="line none"> 3509  *</div><div id="3510" class="line none"> 3510  * This releases the block on new submissions placed when k_work_queue_drain()</div><div id="3511" class="line none"> 3511  * is invoked with the @p plug option enabled.  If this is invoked before the</div><div id="3512" class="line none"> 3512  * drain completes new items may be submitted as soon as the drain completes.</div><div id="3513" class="line none"> 3513  *</div><div id="3514" class="line none"> 3514  * @funcprops \isr_ok</div><div id="3515" class="line none"> 3515  *</div><div id="3516" class="line none"> 3516  * @param queue pointer to the queue structure.</div><div id="3517" class="line none"> 3517  *</div><div id="3518" class="line none"> 3518  * @retval 0 if successfully unplugged</div><div id="3519" class="line none"> 3519  * @retval -EALREADY if the work queue was not plugged.</div><div id="3520" class="line none"> 3520  */</div><div id="3521" class="line none"> 3521 int k_work_queue_unplug(struct <a href="kernel.h.html#4029">k_work_q</a> *<a href="kernel.h.html#3889">queue</a>);</div><div id="3522" class="line none"> 3522 </div><div id="3523" class="line none"> 3523 /** @brief Initialize a delayable work structure.</div><div id="3524" class="line none"> 3524  *</div><div id="3525" class="line none"> 3525  * This must be invoked before scheduling a delayable work structure for the</div><div id="3526" class="line none"> 3526  * first time.  It need not be invoked again on the same work structure.  It</div><div id="3527" class="line none"> 3527  * can be re-invoked to change the associated handler, but this must be done</div><div id="3528" class="line none"> 3528  * when the work item is idle.</div><div id="3529" class="line none"> 3529  *</div><div id="3530" class="line none"> 3530  * @funcprops \isr_ok</div><div id="3531" class="line none"> 3531  *</div><div id="3532" class="line none"> 3532  * @param dwork the delayable work structure to be initialized.</div><div id="3533" class="line none"> 3533  *</div><div id="3534" class="line none"> 3534  * @param handler the handler to be invoked by the work item.</div><div id="3535" class="line none"> 3535  */</div><div id="3536" class="line none"> 3536 void k_work_init_delayable(struct <a href="kernel.h.html#3905">k_work_delayable</a> *dwork,</div><div id="3537" class="line none"> 3537                            <a href="kernel.h.html#3276">k_work_handler_t</a> <a href="kernel.h.html#3886">handler</a>);</div><div id="3538" class="line none"> 3538 </div><div id="3539" class="line none"> 3539 /**</div><div id="3540" class="line none"> 3540  * @brief Get the parent delayable work structure from a work pointer.</div><div id="3541" class="line none"> 3541  *</div><div id="3542" class="line none"> 3542  * This function is necessary when a @c k_work_handler_t function is passed to</div><div id="3543" class="line none"> 3543  * k_work_schedule_for_queue() and the handler needs to access data from the</div><div id="3544" class="line none"> 3544  * container of the containing `k_work_delayable`.</div><div id="3545" class="line none"> 3545  *</div><div id="3546" class="line none"> 3546  * @param work Address passed to the work handler</div><div id="3547" class="line none"> 3547  *</div><div id="3548" class="line none"> 3548  * @return Address of the containing @c k_work_delayable structure.</div><div id="3549" class="line none"> 3549  */</div><div id="3550" class="line none"> 3550 static inline struct <a href="kernel.h.html#3905">k_work_delayable</a> *</div><div id="3551" class="line none"> 3551 <a href="kernel.h.html#4058">k_work_delayable_from_work</a>(struct <a href="kernel.h.html#3877">k_work</a> *<a href="kernel.h.html#3907">work</a>);</div><div id="3552" class="line none"> 3552 </div><div id="3553" class="line none"> 3553 /** @brief Busy state flags from the delayable work item.</div><div id="3554" class="line none"> 3554  *</div><div id="3555" class="line none"> 3555  * @funcprops \isr_ok</div><div id="3556" class="line none"> 3556  *</div><div id="3557" class="line none"> 3557  * @note This is a live snapshot of state, which may change before the result</div><div id="3558" class="line none"> 3558  * can be inspected.  Use locks where appropriate.</div><div id="3559" class="line none"> 3559  *</div><div id="3560" class="line none"> 3560  * @param dwork pointer to the delayable work item.</div><div id="3561" class="line none"> 3561  *</div><div id="3562" class="line none"> 3562  * @return a mask of flags K_WORK_DELAYED, K_WORK_QUEUED, K_WORK_RUNNING,</div><div id="3563" class="line none"> 3563  * K_WORK_CANCELING, and K_WORK_FLUSHING.  A zero return value indicates the</div><div id="3564" class="line none"> 3564  * work item appears to be idle.</div><div id="3565" class="line none"> 3565  */</div><div id="3566" class="line none"> 3566 int k_work_delayable_busy_get(const struct <a href="kernel.h.html#3905">k_work_delayable</a> *dwork);</div><div id="3567" class="line none"> 3567 </div><div id="3568" class="line none"> 3568 /** @brief Test whether a delayed work item is currently pending.</div><div id="3569" class="line none"> 3569  *</div><div id="3570" class="line none"> 3570  * Wrapper to determine whether a delayed work item is in a non-idle state.</div><div id="3571" class="line none"> 3571  *</div><div id="3572" class="line none"> 3572  * @note This is a live snapshot of state, which may change before the result</div><div id="3573" class="line none"> 3573  * can be inspected.  Use locks where appropriate.</div><div id="3574" class="line none"> 3574  *</div><div id="3575" class="line none"> 3575  * @funcprops \isr_ok</div><div id="3576" class="line none"> 3576  *</div><div id="3577" class="line none"> 3577  * @param dwork pointer to the delayable work item.</div><div id="3578" class="line none"> 3578  *</div><div id="3579" class="line none"> 3579  * @return true if and only if k_work_delayable_busy_get() returns a non-zero</div><div id="3580" class="line none"> 3580  * value.</div><div id="3581" class="line none"> 3581  */</div><div id="3582" class="line none"> 3582 static inline bool <a href="kernel.h.html#4063">k_work_delayable_is_pending</a>(</div><div id="3583" class="line none"> 3583         const struct <a href="kernel.h.html#3905">k_work_delayable</a> *dwork);</div><div id="3584" class="line none"> 3584 </div><div id="3585" class="line none"> 3585 /** @brief Get the absolute tick count at which a scheduled delayable work</div><div id="3586" class="line none"> 3586  * will be submitted.</div><div id="3587" class="line none"> 3587  *</div><div id="3588" class="line none"> 3588  * @note This is a live snapshot of state, which may change before the result</div><div id="3589" class="line none"> 3589  * can be inspected.  Use locks where appropriate.</div><div id="3590" class="line none"> 3590  *</div><div id="3591" class="line none"> 3591  * @funcprops \isr_ok</div><div id="3592" class="line none"> 3592  *</div><div id="3593" class="line none"> 3593  * @param dwork pointer to the delayable work item.</div><div id="3594" class="line none"> 3594  *</div><div id="3595" class="line none"> 3595  * @return the tick count when the timer that will schedule the work item will</div><div id="3596" class="line none"> 3596  * expire, or the current tick count if the work is not scheduled.</div><div id="3597" class="line none"> 3597  */</div><div id="3598" class="line none"> 3598 static inline k_ticks_t <a href="kernel.h.html#4069">k_work_delayable_expires_get</a>(</div><div id="3599" class="line none"> 3599         const struct <a href="kernel.h.html#3905">k_work_delayable</a> *dwork);</div><div id="3600" class="line none"> 3600 </div><div id="3601" class="line none"> 3601 /** @brief Get the number of ticks until a scheduled delayable work will be</div><div id="3602" class="line none"> 3602  * submitted.</div><div id="3603" class="line none"> 3603  *</div><div id="3604" class="line none"> 3604  * @note This is a live snapshot of state, which may change before the result</div><div id="3605" class="line none"> 3605  * can be inspected.  Use locks where appropriate.</div><div id="3606" class="line none"> 3606  *</div><div id="3607" class="line none"> 3607  * @funcprops \isr_ok</div><div id="3608" class="line none"> 3608  *</div><div id="3609" class="line none"> 3609  * @param dwork pointer to the delayable work item.</div><div id="3610" class="line none"> 3610  *</div><div id="3611" class="line none"> 3611  * @return the number of ticks until the timer that will schedule the work</div><div id="3612" class="line none"> 3612  * item will expire, or zero if the item is not scheduled.</div><div id="3613" class="line none"> 3613  */</div><div id="3614" class="line none"> 3614 static inline k_ticks_t <a href="kernel.h.html#4075">k_work_delayable_remaining_get</a>(</div><div id="3615" class="line none"> 3615         const struct <a href="kernel.h.html#3905">k_work_delayable</a> *dwork);</div><div id="3616" class="line none"> 3616 </div><div id="3617" class="line none"> 3617 /** @brief Submit an idle work item to a queue after a delay.</div><div id="3618" class="line none"> 3618  *</div><div id="3619" class="line none"> 3619  * Unlike k_work_reschedule_for_queue() this is a no-op if the work item is</div><div id="3620" class="line none"> 3620  * already scheduled or submitted, even if @p delay is @c K_NO_WAIT.</div><div id="3621" class="line none"> 3621  *</div><div id="3622" class="line none"> 3622  * @funcprops \isr_ok</div><div id="3623" class="line none"> 3623  *</div><div id="3624" class="line none"> 3624  * @param queue the queue on which the work item should be submitted after the</div><div id="3625" class="line none"> 3625  * delay.</div><div id="3626" class="line none"> 3626  *</div><div id="3627" class="line none"> 3627  * @param dwork pointer to the delayable work item.</div><div id="3628" class="line none"> 3628  *</div><div id="3629" class="line none"> 3629  * @param delay the time to wait before submitting the work item.  If @c</div><div id="3630" class="line none"> 3630  * K_NO_WAIT and the work is not pending this is equivalent to</div><div id="3631" class="line none"> 3631  * k_work_submit_to_queue().</div><div id="3632" class="line none"> 3632  *</div><div id="3633" class="line none"> 3633  * @retval 0 if work was already scheduled or submitted.</div><div id="3634" class="line none"> 3634  * @retval 1 if work has been scheduled.</div><div id="3635" class="line none"> 3635  * @retval 2 if @p delay is @c K_NO_WAIT and work</div><div id="3636" class="line none"> 3636  *         was running and has been queued to the queue that was running it.</div><div id="3637" class="line none"> 3637  * @retval -EBUSY if @p delay is @c K_NO_WAIT and</div><div id="3638" class="line none"> 3638  *         k_work_submit_to_queue() fails with this code.</div><div id="3639" class="line none"> 3639  * @retval -EINVAL if @p delay is @c K_NO_WAIT and</div><div id="3640" class="line none"> 3640  *         k_work_submit_to_queue() fails with this code.</div><div id="3641" class="line none"> 3641  * @retval -ENODEV if @p delay is @c K_NO_WAIT and</div><div id="3642" class="line none"> 3642  *         k_work_submit_to_queue() fails with this code.</div><div id="3643" class="line none"> 3643  */</div><div id="3644" class="line none"> 3644 int k_work_schedule_for_queue(struct <a href="kernel.h.html#4029">k_work_q</a> *<a href="kernel.h.html#3889">queue</a>,</div><div id="3645" class="line none"> 3645                                struct <a href="kernel.h.html#3905">k_work_delayable</a> *dwork,</div><div id="3646" class="line none"> 3646                                k_timeout_t delay);</div><div id="3647" class="line none"> 3647 </div><div id="3648" class="line none"> 3648 /** @brief Submit an idle work item to the system work queue after a</div><div id="3649" class="line none"> 3649  * delay.</div><div id="3650" class="line none"> 3650  *</div><div id="3651" class="line none"> 3651  * This is a thin wrapper around k_work_schedule_for_queue(), with all the API</div><div id="3652" class="line none"> 3652  * characteristics of that function.</div><div id="3653" class="line none"> 3653  *</div><div id="3654" class="line none"> 3654  * @param dwork pointer to the delayable work item.</div><div id="3655" class="line none"> 3655  *</div><div id="3656" class="line none"> 3656  * @param delay the time to wait before submitting the work item.  If @c</div><div id="3657" class="line none"> 3657  * K_NO_WAIT this is equivalent to k_work_submit_to_queue().</div><div id="3658" class="line none"> 3658  *</div><div id="3659" class="line none"> 3659  * @return as with k_work_schedule_for_queue().</div><div id="3660" class="line none"> 3660  */</div><div id="3661" class="line none"> 3661 int k_work_schedule(struct <a href="kernel.h.html#3905">k_work_delayable</a> *dwork,</div><div id="3662" class="line none"> 3662                                    k_timeout_t delay);</div><div id="3663" class="line none"> 3663 </div><div id="3664" class="line none"> 3664 /** @brief Reschedule a work item to a queue after a delay.</div><div id="3665" class="line none"> 3665  *</div><div id="3666" class="line none"> 3666  * Unlike k_work_schedule_for_queue() this function can change the deadline of</div><div id="3667" class="line none"> 3667  * a scheduled work item, and will schedule a work item that is in any state</div><div id="3668" class="line none"> 3668  * (e.g. is idle, submitted, or running).  This function does not affect</div><div id="3669" class="line none"> 3669  * ("unsubmit") a work item that has been submitted to a queue.</div><div id="3670" class="line none"> 3670  *</div><div id="3671" class="line none"> 3671  * @funcprops \isr_ok</div><div id="3672" class="line none"> 3672  *</div><div id="3673" class="line none"> 3673  * @param queue the queue on which the work item should be submitted after the</div><div id="3674" class="line none"> 3674  * delay.</div><div id="3675" class="line none"> 3675  *</div><div id="3676" class="line none"> 3676  * @param dwork pointer to the delayable work item.</div><div id="3677" class="line none"> 3677  *</div><div id="3678" class="line none"> 3678  * @param delay the time to wait before submitting the work item.  If @c</div><div id="3679" class="line none"> 3679  * K_NO_WAIT this is equivalent to k_work_submit_to_queue() after canceling</div><div id="3680" class="line none"> 3680  * any previous scheduled submission.</div><div id="3681" class="line none"> 3681  *</div><div id="3682" class="line none"> 3682  * @note If delay is @c K_NO_WAIT ("no delay") the return values are as with</div><div id="3683" class="line none"> 3683  * k_work_submit_to_queue().</div><div id="3684" class="line none"> 3684  *</div><div id="3685" class="line none"> 3685  * @retval 0 if delay is @c K_NO_WAIT and work was already on a queue</div><div id="3686" class="line none"> 3686  * @retval 1 if</div><div id="3687" class="line none"> 3687  * * delay is @c K_NO_WAIT and work was not submitted but has now been queued</div><div id="3688" class="line none"> 3688  *   to @p queue; or</div><div id="3689" class="line none"> 3689  * * delay not @c K_NO_WAIT and work has been scheduled</div><div id="3690" class="line none"> 3690  * @retval 2 if delay is @c K_NO_WAIT and work was running and has been queued</div><div id="3691" class="line none"> 3691  * to the queue that was running it</div><div id="3692" class="line none"> 3692  * @retval -EBUSY if @p delay is @c K_NO_WAIT and</div><div id="3693" class="line none"> 3693  *         k_work_submit_to_queue() fails with this code.</div><div id="3694" class="line none"> 3694  * @retval -EINVAL if @p delay is @c K_NO_WAIT and</div><div id="3695" class="line none"> 3695  *         k_work_submit_to_queue() fails with this code.</div><div id="3696" class="line none"> 3696  * @retval -ENODEV if @p delay is @c K_NO_WAIT and</div><div id="3697" class="line none"> 3697  *         k_work_submit_to_queue() fails with this code.</div><div id="3698" class="line none"> 3698  */</div><div id="3699" class="line none"> 3699 int k_work_reschedule_for_queue(struct <a href="kernel.h.html#4029">k_work_q</a> *<a href="kernel.h.html#3889">queue</a>,</div><div id="3700" class="line none"> 3700                                  struct <a href="kernel.h.html#3905">k_work_delayable</a> *dwork,</div><div id="3701" class="line none"> 3701                                  k_timeout_t delay);</div><div id="3702" class="line none"> 3702 </div><div id="3703" class="line none"> 3703 /** @brief Reschedule a work item to the system work queue after a</div><div id="3704" class="line none"> 3704  * delay.</div><div id="3705" class="line none"> 3705  *</div><div id="3706" class="line none"> 3706  * This is a thin wrapper around k_work_reschedule_for_queue(), with all the</div><div id="3707" class="line none"> 3707  * API characteristics of that function.</div><div id="3708" class="line none"> 3708  *</div><div id="3709" class="line none"> 3709  * @param dwork pointer to the delayable work item.</div><div id="3710" class="line none"> 3710  *</div><div id="3711" class="line none"> 3711  * @param delay the time to wait before submitting the work item.</div><div id="3712" class="line none"> 3712  *</div><div id="3713" class="line none"> 3713  * @return as with k_work_reschedule_for_queue().</div><div id="3714" class="line none"> 3714  */</div><div id="3715" class="line none"> 3715 int k_work_reschedule(struct <a href="kernel.h.html#3905">k_work_delayable</a> *dwork,</div><div id="3716" class="line none"> 3716                                      k_timeout_t delay);</div><div id="3717" class="line none"> 3717 </div><div id="3718" class="line none"> 3718 /** @brief Flush delayable work.</div><div id="3719" class="line none"> 3719  *</div><div id="3720" class="line none"> 3720  * If the work is scheduled, it is immediately submitted.  Then the caller</div><div id="3721" class="line none"> 3721  * blocks until the work completes, as with k_work_flush().</div><div id="3722" class="line none"> 3722  *</div><div id="3723" class="line none"> 3723  * @note Be careful of caller and work queue thread relative priority.  If</div><div id="3724" class="line none"> 3724  * this function sleeps it will not return until the work queue thread</div><div id="3725" class="line none"> 3725  * completes the tasks that allow this thread to resume.</div><div id="3726" class="line none"> 3726  *</div><div id="3727" class="line none"> 3727  * @note Behavior is undefined if this function is invoked on @p dwork from a</div><div id="3728" class="line none"> 3728  * work queue running @p dwork.</div><div id="3729" class="line none"> 3729  *</div><div id="3730" class="line none"> 3730  * @param dwork pointer to the delayable work item.</div><div id="3731" class="line none"> 3731  *</div><div id="3732" class="line none"> 3732  * @param sync pointer to an opaque item containing state related to the</div><div id="3733" class="line none"> 3733  * pending cancellation.  The object must persist until the call returns, and</div><div id="3734" class="line none"> 3734  * be accessible from both the caller thread and the work queue thread.  The</div><div id="3735" class="line none"> 3735  * object must not be used for any other flush or cancel operation until this</div><div id="3736" class="line none"> 3736  * one completes.  On architectures with CONFIG_KERNEL_COHERENCE the object</div><div id="3737" class="line none"> 3737  * must be allocated in coherent memory.</div><div id="3738" class="line none"> 3738  *</div><div id="3739" class="line none"> 3739  * @retval true if call had to wait for completion</div><div id="3740" class="line none"> 3740  * @retval false if work was already idle</div><div id="3741" class="line none"> 3741  */</div><div id="3742" class="line none"> 3742 bool k_work_flush_delayable(struct <a href="kernel.h.html#3905">k_work_delayable</a> *dwork,</div><div id="3743" class="line none"> 3743                             struct <a href="kernel.h.html#3988">k_work_sync</a> *sync);</div><div id="3744" class="line none"> 3744 </div><div id="3745" class="line none"> 3745 /** @brief Cancel delayable work.</div><div id="3746" class="line none"> 3746  *</div><div id="3747" class="line none"> 3747  * Similar to k_work_cancel() but for delayable work.  If the work is</div><div id="3748" class="line none"> 3748  * scheduled or submitted it is canceled.  This function does not wait for the</div><div id="3749" class="line none"> 3749  * cancellation to complete.</div><div id="3750" class="line none"> 3750  *</div><div id="3751" class="line none"> 3751  * @note The work may still be running when this returns.  Use</div><div id="3752" class="line none"> 3752  * k_work_flush_delayable() or k_work_cancel_delayable_sync() to ensure it is</div><div id="3753" class="line none"> 3753  * not running.</div><div id="3754" class="line none"> 3754  *</div><div id="3755" class="line none"> 3755  * @note Canceling delayable work does not prevent rescheduling it.  It does</div><div id="3756" class="line none"> 3756  * prevent submitting it until the cancellation completes.</div><div id="3757" class="line none"> 3757  *</div><div id="3758" class="line none"> 3758  * @funcprops \isr_ok</div><div id="3759" class="line none"> 3759  *</div><div id="3760" class="line none"> 3760  * @param dwork pointer to the delayable work item.</div><div id="3761" class="line none"> 3761  *</div><div id="3762" class="line none"> 3762  * @return the k_work_delayable_busy_get() status indicating the state of the</div><div id="3763" class="line none"> 3763  * item after all cancellation steps performed by this call are completed.</div><div id="3764" class="line none"> 3764  */</div><div id="3765" class="line none"> 3765 int k_work_cancel_delayable(struct <a href="kernel.h.html#3905">k_work_delayable</a> *dwork);</div><div id="3766" class="line none"> 3766 </div><div id="3767" class="line none"> 3767 /** @brief Cancel delayable work and wait.</div><div id="3768" class="line none"> 3768  *</div><div id="3769" class="line none"> 3769  * Like k_work_cancel_delayable() but waits until the work becomes idle.</div><div id="3770" class="line none"> 3770  *</div><div id="3771" class="line none"> 3771  * @note Canceling delayable work does not prevent rescheduling it.  It does</div><div id="3772" class="line none"> 3772  * prevent submitting it until the cancellation completes.</div><div id="3773" class="line none"> 3773  *</div><div id="3774" class="line none"> 3774  * @note Be careful of caller and work queue thread relative priority.  If</div><div id="3775" class="line none"> 3775  * this function sleeps it will not return until the work queue thread</div><div id="3776" class="line none"> 3776  * completes the tasks that allow this thread to resume.</div><div id="3777" class="line none"> 3777  *</div><div id="3778" class="line none"> 3778  * @note Behavior is undefined if this function is invoked on @p dwork from a</div><div id="3779" class="line none"> 3779  * work queue running @p dwork.</div><div id="3780" class="line none"> 3780  *</div><div id="3781" class="line none"> 3781  * @param dwork pointer to the delayable work item.</div><div id="3782" class="line none"> 3782  *</div><div id="3783" class="line none"> 3783  * @param sync pointer to an opaque item containing state related to the</div><div id="3784" class="line none"> 3784  * pending cancellation.  The object must persist until the call returns, and</div><div id="3785" class="line none"> 3785  * be accessible from both the caller thread and the work queue thread.  The</div><div id="3786" class="line none"> 3786  * object must not be used for any other flush or cancel operation until this</div><div id="3787" class="line none"> 3787  * one completes.  On architectures with CONFIG_KERNEL_COHERENCE the object</div><div id="3788" class="line none"> 3788  * must be allocated in coherent memory.</div><div id="3789" class="line none"> 3789  *</div><div id="3790" class="line none"> 3790  * @retval true if work was not idle (call had to wait for cancellation of a</div><div id="3791" class="line none"> 3791  * running handler to complete, or scheduled or submitted operations were</div><div id="3792" class="line none"> 3792  * cancelled);</div><div id="3793" class="line none"> 3793  * @retval false otherwise</div><div id="3794" class="line none"> 3794  */</div><div id="3795" class="line none"> 3795 bool k_work_cancel_delayable_sync(struct <a href="kernel.h.html#3905">k_work_delayable</a> *dwork,</div><div id="3796" class="line none"> 3796                                   struct <a href="kernel.h.html#3988">k_work_sync</a> *sync);</div><div id="3797" class="line none"> 3797 </div><div id="3798" class="line none"> 3798 enum {</div><div id="3799" class="line none"> 3799 /**</div><div id="3800" class="line none"> 3800  * @cond INTERNAL_HIDDEN</div><div id="3801" class="line none"> 3801  */</div><div id="3802" class="line none"> 3802 </div><div id="3803" class="line none"> 3803         /* The atomic API is used for all work and queue flags fields to</div><div id="3804" class="line none"> 3804          * enforce sequential consistency in SMP environments.</div><div id="3805" class="line none"> 3805          */</div><div id="3806" class="line none"> 3806 </div><div id="3807" class="line none"> 3807         /* Bits that represent the work item states.  At least nine of the</div><div id="3808" class="line none"> 3808          * combinations are distinct valid stable states.</div><div id="3809" class="line none"> 3809          */</div><div id="3810" class="line none"> 3810         <a href="kernel.h.html#3810">K_WORK_RUNNING_BIT</a> = 0,</div><div id="3811" class="line none"> 3811         <a href="kernel.h.html#3811">K_WORK_CANCELING_BIT</a> = 1,</div><div id="3812" class="line none"> 3812         <a href="kernel.h.html#3812">K_WORK_QUEUED_BIT</a> = 2,</div><div id="3813" class="line none"> 3813         <a href="kernel.h.html#3813">K_WORK_DELAYED_BIT</a> = 3,</div><div id="3814" class="line none"> 3814         <a href="kernel.h.html#3814">K_WORK_FLUSHING_BIT</a> = 4,</div><div id="3815" class="line none"> 3815 </div><div id="3816" class="line none"> 3816         <a href="kernel.h.html#3816">K_WORK_MASK</a> = BIT(<a href="kernel.h.html#3813">K_WORK_DELAYED_BIT</a>) | BIT(<a href="kernel.h.html#3812">K_WORK_QUEUED_BIT</a>)</div><div id="3817" class="line none"> 3817                 | BIT(<a href="kernel.h.html#3810">K_WORK_RUNNING_BIT</a>) | BIT(<a href="kernel.h.html#3811">K_WORK_CANCELING_BIT</a>) | BIT(<a href="kernel.h.html#3814">K_WORK_FLUSHING_BIT</a>),</div><div id="3818" class="line none"> 3818 </div><div id="3819" class="line none"> 3819         /* Static work flags */</div><div id="3820" class="line none"> 3820         <a href="kernel.h.html#3820">K_WORK_DELAYABLE_BIT</a> = 8,</div><div id="3821" class="line none"> 3821         <a href="kernel.h.html#3821">K_WORK_DELAYABLE</a> = BIT(<a href="kernel.h.html#3820">K_WORK_DELAYABLE_BIT</a>),</div><div id="3822" class="line none"> 3822 </div><div id="3823" class="line none"> 3823         /* Dynamic work queue flags */</div><div id="3824" class="line none"> 3824         <a href="kernel.h.html#3824">K_WORK_QUEUE_STARTED_BIT</a> = 0,</div><div id="3825" class="line none"> 3825         <a href="kernel.h.html#3825">K_WORK_QUEUE_STARTED</a> = BIT(<a href="kernel.h.html#3824">K_WORK_QUEUE_STARTED_BIT</a>),</div><div id="3826" class="line none"> 3826         <a href="kernel.h.html#3826">K_WORK_QUEUE_BUSY_BIT</a> = 1,</div><div id="3827" class="line none"> 3827         <a href="kernel.h.html#3827">K_WORK_QUEUE_BUSY</a> = BIT(<a href="kernel.h.html#3826">K_WORK_QUEUE_BUSY_BIT</a>),</div><div id="3828" class="line none"> 3828         <a href="kernel.h.html#3828">K_WORK_QUEUE_DRAIN_BIT</a> = 2,</div><div id="3829" class="line none"> 3829         <a href="kernel.h.html#3829">K_WORK_QUEUE_DRAIN</a> = BIT(<a href="kernel.h.html#3828">K_WORK_QUEUE_DRAIN_BIT</a>),</div><div id="3830" class="line none"> 3830         <a href="kernel.h.html#3830">K_WORK_QUEUE_PLUGGED_BIT</a> = 3,</div><div id="3831" class="line none"> 3831         <a href="kernel.h.html#3831">K_WORK_QUEUE_PLUGGED</a> = BIT(<a href="kernel.h.html#3830">K_WORK_QUEUE_PLUGGED_BIT</a>),</div><div id="3832" class="line none"> 3832 </div><div id="3833" class="line none"> 3833         /* Static work queue flags */</div><div id="3834" class="line none"> 3834         <a href="kernel.h.html#3834">K_WORK_QUEUE_NO_YIELD_BIT</a> = 8,</div><div id="3835" class="line none"> 3835         <a href="kernel.h.html#3835">K_WORK_QUEUE_NO_YIELD</a> = BIT(<a href="kernel.h.html#3834">K_WORK_QUEUE_NO_YIELD_BIT</a>),</div><div id="3836" class="line none"> 3836 </div><div id="3837" class="line none"> 3837 /**</div><div id="3838" class="line none"> 3838  * INTERNAL_HIDDEN @endcond</div><div id="3839" class="line none"> 3839  */</div><div id="3840" class="line none"> 3840         /* Transient work flags */</div><div id="3841" class="line none"> 3841 </div><div id="3842" class="line none"> 3842         /** @brief Flag indicating a work item that is running under a work</div><div id="3843" class="line none"> 3843          * queue thread.</div><div id="3844" class="line none"> 3844          *</div><div id="3845" class="line none"> 3845          * Accessed via k_work_busy_get().  May co-occur with other flags.</div><div id="3846" class="line none"> 3846          */</div><div id="3847" class="line none"> 3847         <a href="kernel.h.html#3847">K_WORK_RUNNING</a> = BIT(<a href="kernel.h.html#3810">K_WORK_RUNNING_BIT</a>),</div><div id="3848" class="line none"> 3848 </div><div id="3849" class="line none"> 3849         /** @brief Flag indicating a work item that is being canceled.</div><div id="3850" class="line none"> 3850          *</div><div id="3851" class="line none"> 3851          * Accessed via k_work_busy_get().  May co-occur with other flags.</div><div id="3852" class="line none"> 3852          */</div><div id="3853" class="line none"> 3853         <a href="kernel.h.html#3853">K_WORK_CANCELING</a> = BIT(<a href="kernel.h.html#3811">K_WORK_CANCELING_BIT</a>),</div><div id="3854" class="line none"> 3854 </div><div id="3855" class="line none"> 3855         /** @brief Flag indicating a work item that has been submitted to a</div><div id="3856" class="line none"> 3856          * queue but has not started running.</div><div id="3857" class="line none"> 3857          *</div><div id="3858" class="line none"> 3858          * Accessed via k_work_busy_get().  May co-occur with other flags.</div><div id="3859" class="line none"> 3859          */</div><div id="3860" class="line none"> 3860         <a href="kernel.h.html#3860">K_WORK_QUEUED</a> = BIT(<a href="kernel.h.html#3812">K_WORK_QUEUED_BIT</a>),</div><div id="3861" class="line none"> 3861 </div><div id="3862" class="line none"> 3862         /** @brief Flag indicating a delayed work item that is scheduled for</div><div id="3863" class="line none"> 3863          * submission to a queue.</div><div id="3864" class="line none"> 3864          *</div><div id="3865" class="line none"> 3865          * Accessed via k_work_busy_get().  May co-occur with other flags.</div><div id="3866" class="line none"> 3866          */</div><div id="3867" class="line none"> 3867         <a href="kernel.h.html#3867">K_WORK_DELAYED</a> = BIT(<a href="kernel.h.html#3813">K_WORK_DELAYED_BIT</a>),</div><div id="3868" class="line none"> 3868 </div><div id="3869" class="line none"> 3869         /** @brief Flag indicating a synced work item that is being flushed.</div><div id="3870" class="line none"> 3870          *</div><div id="3871" class="line none"> 3871          * Accessed via k_work_busy_get().  May co-occur with other flags.</div><div id="3872" class="line none"> 3872          */</div><div id="3873" class="line none"> 3873         <a href="kernel.h.html#3873">K_WORK_FLUSHING</a> = BIT(<a href="kernel.h.html#3814">K_WORK_FLUSHING_BIT</a>),</div><div id="3874" class="line none"> 3874 };</div><div id="3875" class="line none"> 3875 </div><div id="3876" class="line none"> 3876 /** @brief A structure used to submit work. */</div><div id="3877" class="line none"> 3877 struct <a href="kernel.h.html#3877">k_work</a> {</div><div id="3878" class="line none"> 3878         /* All fields are protected by the work module spinlock.  No fields</div><div id="3879" class="line none"> 3879          * are to be accessed except through kernel API.</div><div id="3880" class="line none"> 3880          */</div><div id="3881" class="line none"> 3881 </div><div id="3882" class="line none"> 3882         /* Node to link into k_work_q pending list. */</div><div id="3883" class="line none"> 3883         sys_snode_t <a href="kernel.h.html#3883">node</a>;</div><div id="3884" class="line none"> 3884 </div><div id="3885" class="line none"> 3885         /* The function to be invoked by the work queue thread. */</div><div id="3886" class="line none"> 3886         <a href="kernel.h.html#3276">k_work_handler_t</a> <a href="kernel.h.html#3886">handler</a>;</div><div id="3887" class="line none"> 3887 </div><div id="3888" class="line none"> 3888         /* The queue on which the work item was last submitted. */</div><div id="3889" class="line none"> 3889         struct <a href="kernel.h.html#4029">k_work_q</a> *<a href="kernel.h.html#3889">queue</a>;</div><div id="3890" class="line none"> 3890 </div><div id="3891" class="line none"> 3891         /* State of the work item.</div><div id="3892" class="line none"> 3892          *</div><div id="3893" class="line none"> 3893          * The item can be DELAYED, QUEUED, and RUNNING simultaneously.</div><div id="3894" class="line none"> 3894          *</div><div id="3895" class="line none"> 3895          * It can be RUNNING and CANCELING simultaneously.</div><div id="3896" class="line none"> 3896          */</div><div id="3897" class="line none"> 3897         uint32_t <a href="kernel.h.html#2764">flags</a>;</div><div id="3898" class="line none"> 3898 };</div><div id="3899" class="line none"> 3899 </div><div id="3900" class="line none"> 3900 #define <a href="kernel.h.html#3900">Z_WORK_INITIALIZER</a>(work_handler) { \</div><div id="3901" class="line none"> 3901         .<a href="kernel.h.html#3886">handler</a> = (work_handler), \</div><div id="3902" class="line none"> 3902 }</div><div id="3903" class="line none"> 3903 </div><div id="3904" class="line none"> 3904 /** @brief A structure used to submit work after a delay. */</div><div id="3905" class="line none"> 3905 struct <a href="kernel.h.html#3905">k_work_delayable</a> {</div><div id="3906" class="line none"> 3906         /* The work item. */</div><div id="3907" class="line none"> 3907         struct <a href="kernel.h.html#3877">k_work</a> <a href="kernel.h.html#3907">work</a>;</div><div id="3908" class="line none"> 3908 </div><div id="3909" class="line none"> 3909         /* Timeout used to submit work after a delay. */</div><div id="3910" class="line none"> 3910         struct <a href="kernel_structs.h.html#293">_timeout</a> <a href="kernel.h.html#1452">timeout</a>;</div><div id="3911" class="line none"> 3911 </div><div id="3912" class="line none"> 3912         /* The queue to which the work should be submitted. */</div><div id="3913" class="line none"> 3913         struct <a href="kernel.h.html#4029">k_work_q</a> *<a href="kernel.h.html#3889">queue</a>;</div><div id="3914" class="line none"> 3914 };</div><div id="3915" class="line none"> 3915 </div><div id="3916" class="line none"> 3916 #define <a href="kernel.h.html#3916">Z_WORK_DELAYABLE_INITIALIZER</a>(work_handler) { \</div><div id="3917" class="line none"> 3917         .<a href="kernel.h.html#3907">work</a> = { \</div><div id="3918" class="line none"> 3918                 .<a href="kernel.h.html#3886">handler</a> = (work_handler), \</div><div id="3919" class="line none"> 3919                 .<a href="kernel.h.html#2764">flags</a> = <a href="kernel.h.html#3821">K_WORK_DELAYABLE</a>, \</div><div id="3920" class="line none"> 3920         }, \</div><div id="3921" class="line none"> 3921 }</div><div id="3922" class="line none"> 3922 </div><div id="3923" class="line none"> 3923 /**</div><div id="3924" class="line none"> 3924  * @brief Initialize a statically-defined delayable work item.</div><div id="3925" class="line none"> 3925  *</div><div id="3926" class="line none"> 3926  * This macro can be used to initialize a statically-defined delayable</div><div id="3927" class="line none"> 3927  * work item, prior to its first use. For example,</div><div id="3928" class="line none"> 3928  *</div><div id="3929" class="line none"> 3929  * @code static K_WORK_DELAYABLE_DEFINE(&lt;dwork&gt;, &lt;work_handler&gt;); @endcode</div><div id="3930" class="line none"> 3930  *</div><div id="3931" class="line none"> 3931  * Note that if the runtime dependencies support initialization with</div><div id="3932" class="line none"> 3932  * k_work_init_delayable() using that will eliminate the initialized</div><div id="3933" class="line none"> 3933  * object in ROM that is produced by this macro and copied in at</div><div id="3934" class="line none"> 3934  * system startup.</div><div id="3935" class="line none"> 3935  *</div><div id="3936" class="line none"> 3936  * @param work Symbol name for delayable work item object</div><div id="3937" class="line none"> 3937  * @param work_handler Function to invoke each time work item is processed.</div><div id="3938" class="line none"> 3938  */</div><div id="3939" class="line none"> 3939 #define <a href="kernel.h.html#3939">K_WORK_DELAYABLE_DEFINE</a>(<a href="kernel.h.html#3907">work</a>, work_handler) \</div><div id="3940" class="line none"> 3940         struct <a href="kernel.h.html#3905">k_work_delayable</a> <a href="kernel.h.html#3907">work</a> \</div><div id="3941" class="line none"> 3941           = <a href="kernel.h.html#3916">Z_WORK_DELAYABLE_INITIALIZER</a>(work_handler)</div><div id="3942" class="line none"> 3942 </div><div id="3943" class="line none"> 3943 /**</div><div id="3944" class="line none"> 3944  * @cond INTERNAL_HIDDEN</div><div id="3945" class="line none"> 3945  */</div><div id="3946" class="line none"> 3946 </div><div id="3947" class="line none"> 3947 /* Record used to wait for work to flush.</div><div id="3948" class="line none"> 3948  *</div><div id="3949" class="line none"> 3949  * The work item is inserted into the queue that will process (or is</div><div id="3950" class="line none"> 3950  * processing) the item, and will be processed as soon as the item</div><div id="3951" class="line none"> 3951  * completes.  When the flusher is processed the semaphore will be</div><div id="3952" class="line none"> 3952  * signaled, releasing the thread waiting for the flush.</div><div id="3953" class="line none"> 3953  */</div><div id="3954" class="line none"> 3954 struct <a href="kernel.h.html#3954">z_work_flusher</a> {</div><div id="3955" class="line none"> 3955         struct <a href="kernel.h.html#3877">k_work</a> <a href="kernel.h.html#3907">work</a>;</div><div id="3956" class="line none"> 3956         struct <a href="kernel.h.html#3111">k_sem</a> <a href="kernel.h.html#3956">sem</a>;</div><div id="3957" class="line none"> 3957 };</div><div id="3958" class="line none"> 3958 </div><div id="3959" class="line none"> 3959 /* Record used to wait for work to complete a cancellation.</div><div id="3960" class="line none"> 3960  *</div><div id="3961" class="line none"> 3961  * The work item is inserted into a global queue of pending cancels.</div><div id="3962" class="line none"> 3962  * When a cancelling work item goes idle any matching waiters are</div><div id="3963" class="line none"> 3963  * removed from pending_cancels and are woken.</div><div id="3964" class="line none"> 3964  */</div><div id="3965" class="line none"> 3965 struct <a href="kernel.h.html#3965">z_work_canceller</a> {</div><div id="3966" class="line none"> 3966         sys_snode_t <a href="kernel.h.html#3883">node</a>;</div><div id="3967" class="line none"> 3967         struct <a href="kernel.h.html#3877">k_work</a> *<a href="kernel.h.html#3907">work</a>;</div><div id="3968" class="line none"> 3968         struct <a href="kernel.h.html#3111">k_sem</a> <a href="kernel.h.html#3956">sem</a>;</div><div id="3969" class="line none"> 3969 };</div><div id="3970" class="line none"> 3970 </div><div id="3971" class="line none"> 3971 /**</div><div id="3972" class="line none"> 3972  * INTERNAL_HIDDEN @endcond</div><div id="3973" class="line none"> 3973  */</div><div id="3974" class="line none"> 3974 </div><div id="3975" class="line none"> 3975 /** @brief A structure holding internal state for a pending synchronous</div><div id="3976" class="line none"> 3976  * operation on a work item or queue.</div><div id="3977" class="line none"> 3977  *</div><div id="3978" class="line none"> 3978  * Instances of this type are provided by the caller for invocation of</div><div id="3979" class="line none"> 3979  * k_work_flush(), k_work_cancel_sync() and sibling flush and cancel APIs.  A</div><div id="3980" class="line none"> 3980  * referenced object must persist until the call returns, and be accessible</div><div id="3981" class="line none"> 3981  * from both the caller thread and the work queue thread.</div><div id="3982" class="line none"> 3982  *</div><div id="3983" class="line none"> 3983  * @note If CONFIG_KERNEL_COHERENCE is enabled the object must be allocated in</div><div id="3984" class="line none"> 3984  * coherent memory; see arch_mem_coherent().  The stack on these architectures</div><div id="3985" class="line none"> 3985  * is generally not coherent.  be stack-allocated.  Violations are detected by</div><div id="3986" class="line none"> 3986  * runtime assertion.</div><div id="3987" class="line none"> 3987  */</div><div id="3988" class="line none"> 3988 struct <a href="kernel.h.html#3988">k_work_sync</a> {</div><div id="3989" class="line none"> 3989         union {</div><div id="3990" class="line none"> 3990                 struct <a href="kernel.h.html#3954">z_work_flusher</a> <a href="kernel.h.html#3990">flusher</a>;</div><div id="3991" class="line none"> 3991                 struct <a href="kernel.h.html#3965">z_work_canceller</a> <a href="kernel.h.html#3991">canceller</a>;</div><div id="3992" class="line none"> 3992         };</div><div id="3993" class="line none"> 3993 };</div><div id="3994" class="line none"> 3994 </div><div id="3995" class="line none"> 3995 /** @brief A structure holding optional configuration items for a work</div><div id="3996" class="line none"> 3996  * queue.</div><div id="3997" class="line none"> 3997  *</div><div id="3998" class="line none"> 3998  * This structure, and values it references, are not retained by</div><div id="3999" class="line none"> 3999  * k_work_queue_start().</div><div id="4000" class="line none"> 4000  */</div><div id="4001" class="line none"> 4001 struct <a href="kernel.h.html#4001">k_work_queue_config</a> {</div><div id="4002" class="line none"> 4002         /** The name to be given to the work queue thread.</div><div id="4003" class="line none"> 4003          *</div><div id="4004" class="line none"> 4004          * If left null the thread will not have a name.</div><div id="4005" class="line none"> 4005          */</div><div id="4006" class="line none"> 4006         const char *<a href="kernel.h.html#4006">name</a>;</div><div id="4007" class="line none"> 4007 </div><div id="4008" class="line none"> 4008         /** Control whether the work queue thread should yield between</div><div id="4009" class="line none"> 4009          * items.</div><div id="4010" class="line none"> 4010          *</div><div id="4011" class="line none"> 4011          * Yielding between items helps guarantee the work queue</div><div id="4012" class="line none"> 4012          * thread does not starve other threads, including cooperative</div><div id="4013" class="line none"> 4013          * ones released by a work item.  This is the default behavior.</div><div id="4014" class="line none"> 4014          *</div><div id="4015" class="line none"> 4015          * Set this to @c true to prevent the work queue thread from</div><div id="4016" class="line none"> 4016          * yielding between items.  This may be appropriate when a</div><div id="4017" class="line none"> 4017          * sequence of items should complete without yielding</div><div id="4018" class="line none"> 4018          * control.</div><div id="4019" class="line none"> 4019          */</div><div id="4020" class="line none"> 4020         bool <a href="kernel.h.html#4020">no_yield</a>;</div><div id="4021" class="line none"> 4021 </div><div id="4022" class="line none"> 4022         /** Control whether the work queue thread should be marked as</div><div id="4023" class="line none"> 4023          * essential thread.</div><div id="4024" class="line none"> 4024          */</div><div id="4025" class="line none"> 4025         bool <a href="kernel.h.html#4025">essential</a>;</div><div id="4026" class="line none"> 4026 };</div><div id="4027" class="line none"> 4027 </div><div id="4028" class="line none"> 4028 /** @brief A structure used to hold work until it can be processed. */</div><div id="4029" class="line none"> 4029 struct <a href="kernel.h.html#4029">k_work_q</a> {</div><div id="4030" class="line none"> 4030         /* The thread that animates the work. */</div><div id="4031" class="line none"> 4031         struct <a href="arch/arch_interface.h.html#43">k_thread</a> <a href="kernel.h.html#4031">thread</a>;</div><div id="4032" class="line none"> 4032 </div><div id="4033" class="line none"> 4033         /* All the following fields must be accessed only while the</div><div id="4034" class="line none"> 4034          * work module spinlock is held.</div><div id="4035" class="line none"> 4035          */</div><div id="4036" class="line none"> 4036 </div><div id="4037" class="line none"> 4037         /* List of k_work items to be worked. */</div><div id="4038" class="line none"> 4038         sys_slist_t <a href="kernel.h.html#4038">pending</a>;</div><div id="4039" class="line none"> 4039 </div><div id="4040" class="line none"> 4040         /* Wait queue for idle work thread. */</div><div id="4041" class="line none"> 4041         <a href="kernel_structs.h.html#286">_wait_q_t</a> <a href="kernel.h.html#4041">notifyq</a>;</div><div id="4042" class="line none"> 4042 </div><div id="4043" class="line none"> 4043         /* Wait queue for threads waiting for the queue to drain. */</div><div id="4044" class="line none"> 4044         <a href="kernel_structs.h.html#286">_wait_q_t</a> <a href="kernel.h.html#4044">drainq</a>;</div><div id="4045" class="line none"> 4045 </div><div id="4046" class="line none"> 4046         /* Flags describing queue state. */</div><div id="4047" class="line none"> 4047         uint32_t <a href="kernel.h.html#2764">flags</a>;</div><div id="4048" class="line none"> 4048 };</div><div id="4049" class="line none"> 4049 </div><div id="4050" class="line none"> 4050 /* Provide the implementation for inline functions declared above */</div><div id="4051" class="line none"> 4051 </div><div id="4052" class="line none"> 4052 static inline bool <a href="kernel.h.html#4052">k_work_is_pending</a>(const struct <a href="kernel.h.html#3877">k_work</a> *<a href="kernel.h.html#3907">work</a>)</div><div id="4053" class="line none"> 4053 {</div><div id="4054" class="line none"> 4054         return k_work_busy_get(<a href="kernel.h.html#3907">work</a>) != 0;</div><div id="4055" class="line none"> 4055 }</div><div id="4056" class="line none"> 4056 </div><div id="4057" class="line none"> 4057 static inline struct <a href="kernel.h.html#3905">k_work_delayable</a> *</div><div id="4058" class="line none"> 4058 <a href="kernel.h.html#4058">k_work_delayable_from_work</a>(struct <a href="kernel.h.html#3877">k_work</a> *<a href="kernel.h.html#3907">work</a>)</div><div id="4059" class="line none"> 4059 {</div><div id="4060" class="line none"> 4060         return CONTAINER_OF(<a href="kernel.h.html#3907">work</a>, struct <a href="kernel.h.html#3905">k_work_delayable</a>, <a href="kernel.h.html#3907">work</a>);</div><div id="4061" class="line none"> 4061 }</div><div id="4062" class="line none"> 4062 </div><div id="4063" class="line none"> 4063 static inline bool <a href="kernel.h.html#4063">k_work_delayable_is_pending</a>(</div><div id="4064" class="line none"> 4064         const struct <a href="kernel.h.html#3905">k_work_delayable</a> *dwork)</div><div id="4065" class="line none"> 4065 {</div><div id="4066" class="line none"> 4066         return k_work_delayable_busy_get(dwork) != 0;</div><div id="4067" class="line none"> 4067 }</div><div id="4068" class="line none"> 4068 </div><div id="4069" class="line none"> 4069 static inline k_ticks_t <a href="kernel.h.html#4069">k_work_delayable_expires_get</a>(</div><div id="4070" class="line none"> 4070         const struct <a href="kernel.h.html#3905">k_work_delayable</a> *dwork)</div><div id="4071" class="line none"> 4071 {</div><div id="4072" class="line none"> 4072         return z_timeout_expires(&amp;dwork-&gt;<a href="kernel.h.html#1452">timeout</a>);</div><div id="4073" class="line none"> 4073 }</div><div id="4074" class="line none"> 4074 </div><div id="4075" class="line none"> 4075 static inline k_ticks_t <a href="kernel.h.html#4075">k_work_delayable_remaining_get</a>(</div><div id="4076" class="line none"> 4076         const struct <a href="kernel.h.html#3905">k_work_delayable</a> *dwork)</div><div id="4077" class="line none"> 4077 {</div><div id="4078" class="line none"> 4078         return z_timeout_remaining(&amp;dwork-&gt;<a href="kernel.h.html#1452">timeout</a>);</div><div id="4079" class="line none"> 4079 }</div><div id="4080" class="line none"> 4080 </div><div id="4081" class="line none"> 4081 static inline <a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4081">k_work_queue_thread_get</a>(struct <a href="kernel.h.html#4029">k_work_q</a> *<a href="kernel.h.html#3889">queue</a>)</div><div id="4082" class="line none"> 4082 {</div><div id="4083" class="line none"> 4083         return &amp;<a href="kernel.h.html#3889">queue</a>-&gt;<a href="kernel.h.html#4031">thread</a>;</div><div id="4084" class="line none"> 4084 }</div><div id="4085" class="line none"> 4085 </div><div id="4086" class="line none"> 4086 /** @} */</div><div id="4087" class="line none"> 4087 </div><div id="4088" class="line none"> 4088 struct <a href="kernel.h.html#4119">k_work_user</a>;</div><div id="4089" class="line none"> 4089 </div><div id="4090" class="line none"> 4090 /**</div><div id="4091" class="line none"> 4091  * @addtogroup workqueue_apis</div><div id="4092" class="line none"> 4092  * @{</div><div id="4093" class="line none"> 4093  */</div><div id="4094" class="line none"> 4094 </div><div id="4095" class="line none"> 4095 /**</div><div id="4096" class="line none"> 4096  * @typedef k_work_user_handler_t</div><div id="4097" class="line none"> 4097  * @brief Work item handler function type for user work queues.</div><div id="4098" class="line none"> 4098  *</div><div id="4099" class="line none"> 4099  * A work item's handler function is executed by a user workqueue's thread</div><div id="4100" class="line none"> 4100  * when the work item is processed by the workqueue.</div><div id="4101" class="line none"> 4101  *</div><div id="4102" class="line none"> 4102  * @param work Address of the work item.</div><div id="4103" class="line none"> 4103  */</div><div id="4104" class="line none"> 4104 typedef void (*<a href="kernel.h.html#4104">k_work_user_handler_t</a>)(struct <a href="kernel.h.html#4119">k_work_user</a> *<a href="kernel.h.html#3907">work</a>);</div><div id="4105" class="line none"> 4105 </div><div id="4106" class="line none"> 4106 /**</div><div id="4107" class="line none"> 4107  * @cond INTERNAL_HIDDEN</div><div id="4108" class="line none"> 4108  */</div><div id="4109" class="line none"> 4109 </div><div id="4110" class="line none"> 4110 struct <a href="kernel.h.html#4110">k_work_user_q</a> {</div><div id="4111" class="line none"> 4111         struct <a href="kernel.h.html#1850">k_queue</a> <a href="kernel.h.html#3889">queue</a>;</div><div id="4112" class="line none"> 4112         struct <a href="arch/arch_interface.h.html#43">k_thread</a> <a href="kernel.h.html#4031">thread</a>;</div><div id="4113" class="line none"> 4113 };</div><div id="4114" class="line none"> 4114 </div><div id="4115" class="line none"> 4115 enum {</div><div id="4116" class="line none"> 4116         <a href="kernel.h.html#4116">K_WORK_USER_STATE_PENDING</a>,      /* Work item pending state */</div><div id="4117" class="line none"> 4117 };</div><div id="4118" class="line none"> 4118 </div><div id="4119" class="line none"> 4119 struct <a href="kernel.h.html#4119">k_work_user</a> {</div><div id="4120" class="line none"> 4120         void *<a href="kernel.h.html#4120">_reserved</a>;                /* Used by k_queue implementation. */</div><div id="4121" class="line none"> 4121         <a href="kernel.h.html#4104">k_work_user_handler_t</a> <a href="kernel.h.html#3886">handler</a>;</div><div id="4122" class="line none"> 4122         <a href="sys/atomic_types.h.html#15">atomic_t</a> <a href="kernel.h.html#2764">flags</a>;</div><div id="4123" class="line none"> 4123 };</div><div id="4124" class="line none"> 4124 </div><div id="4125" class="line none"> 4125 /**</div><div id="4126" class="line none"> 4126  * INTERNAL_HIDDEN @endcond</div><div id="4127" class="line none"> 4127  */</div><div id="4128" class="line none"> 4128 </div><div id="4129" class="line none"> 4129 #if defined(__cplusplus) &amp;&amp; ((__cplusplus - 0) &lt; 202002L)</div><div id="4130" class="line none"> 4130 #define <a href="kernel.h.html#4130">Z_WORK_USER_INITIALIZER</a>(work_handler) { NULL, work_handler, 0 }</div><div id="4131" class="line none"> 4131 #else</div><div id="4132" class="line none"> 4132 #define <a href="kernel.h.html#4130">Z_WORK_USER_INITIALIZER</a>(work_handler) \</div><div id="4133" class="line none"> 4133         { \</div><div id="4134" class="line none"> 4134         .<a href="kernel.h.html#4120">_reserved</a> = NULL, \</div><div id="4135" class="line none"> 4135         .<a href="kernel.h.html#3886">handler</a> = (work_handler), \</div><div id="4136" class="line none"> 4136         .<a href="kernel.h.html#2764">flags</a> = 0 \</div><div id="4137" class="line none"> 4137         }</div><div id="4138" class="line none"> 4138 #endif</div><div id="4139" class="line none"> 4139 </div><div id="4140" class="line none"> 4140 /**</div><div id="4141" class="line none"> 4141  * @brief Initialize a statically-defined user work item.</div><div id="4142" class="line none"> 4142  *</div><div id="4143" class="line none"> 4143  * This macro can be used to initialize a statically-defined user work</div><div id="4144" class="line none"> 4144  * item, prior to its first use. For example,</div><div id="4145" class="line none"> 4145  *</div><div id="4146" class="line none"> 4146  * @code static K_WORK_USER_DEFINE(&lt;work&gt;, &lt;work_handler&gt;); @endcode</div><div id="4147" class="line none"> 4147  *</div><div id="4148" class="line none"> 4148  * @param work Symbol name for work item object</div><div id="4149" class="line none"> 4149  * @param work_handler Function to invoke each time work item is processed.</div><div id="4150" class="line none"> 4150  */</div><div id="4151" class="line none"> 4151 #define <a href="kernel.h.html#4151">K_WORK_USER_DEFINE</a>(<a href="kernel.h.html#3907">work</a>, work_handler) \</div><div id="4152" class="line none"> 4152         struct <a href="kernel.h.html#4119">k_work_user</a> <a href="kernel.h.html#3907">work</a> = <a href="kernel.h.html#4130">Z_WORK_USER_INITIALIZER</a>(work_handler)</div><div id="4153" class="line none"> 4153 </div><div id="4154" class="line none"> 4154 /**</div><div id="4155" class="line none"> 4155  * @brief Initialize a userspace work item.</div><div id="4156" class="line none"> 4156  *</div><div id="4157" class="line none"> 4157  * This routine initializes a user workqueue work item, prior to its</div><div id="4158" class="line none"> 4158  * first use.</div><div id="4159" class="line none"> 4159  *</div><div id="4160" class="line none"> 4160  * @param work Address of work item.</div><div id="4161" class="line none"> 4161  * @param handler Function to invoke each time work item is processed.</div><div id="4162" class="line none"> 4162  */</div><div id="4163" class="line none"> 4163 static inline void <a href="kernel.h.html#4163">k_work_user_init</a>(struct <a href="kernel.h.html#4119">k_work_user</a> *<a href="kernel.h.html#3907">work</a>,</div><div id="4164" class="line none"> 4164                                     <a href="kernel.h.html#4104">k_work_user_handler_t</a> <a href="kernel.h.html#3886">handler</a>)</div><div id="4165" class="line none"> 4165 {</div><div id="4166" class="line none"> 4166         *<a href="kernel.h.html#3907">work</a> = (struct <a href="kernel.h.html#4119">k_work_user</a>)<a href="kernel.h.html#4130">Z_WORK_USER_INITIALIZER</a>(<a href="kernel.h.html#3886">handler</a>);</div><div id="4167" class="line none"> 4167 }</div><div id="4168" class="line none"> 4168 </div><div id="4169" class="line none"> 4169 /**</div><div id="4170" class="line none"> 4170  * @brief Check if a userspace work item is pending.</div><div id="4171" class="line none"> 4171  *</div><div id="4172" class="line none"> 4172  * This routine indicates if user work item @a work is pending in a workqueue's</div><div id="4173" class="line none"> 4173  * queue.</div><div id="4174" class="line none"> 4174  *</div><div id="4175" class="line none"> 4175  * @note Checking if the work is pending gives no guarantee that the</div><div id="4176" class="line none"> 4176  *       work will still be pending when this information is used. It is up to</div><div id="4177" class="line none"> 4177  *       the caller to make sure that this information is used in a safe manner.</div><div id="4178" class="line none"> 4178  *</div><div id="4179" class="line none"> 4179  * @funcprops \isr_ok</div><div id="4180" class="line none"> 4180  *</div><div id="4181" class="line none"> 4181  * @param work Address of work item.</div><div id="4182" class="line none"> 4182  *</div><div id="4183" class="line none"> 4183  * @return true if work item is pending, or false if it is not pending.</div><div id="4184" class="line none"> 4184  */</div><div id="4185" class="line none"> 4185 static inline bool <a href="kernel.h.html#4185">k_work_user_is_pending</a>(struct <a href="kernel.h.html#4119">k_work_user</a> *<a href="kernel.h.html#3907">work</a>)</div><div id="4186" class="line none"> 4186 {</div><div id="4187" class="line none"> 4187         return atomic_test_bit(&amp;<a href="kernel.h.html#3907">work</a>-&gt;<a href="kernel.h.html#2764">flags</a>, <a href="kernel.h.html#4116">K_WORK_USER_STATE_PENDING</a>);</div><div id="4188" class="line none"> 4188 }</div><div id="4189" class="line none"> 4189 </div><div id="4190" class="line none"> 4190 /**</div><div id="4191" class="line none"> 4191  * @brief Submit a work item to a user mode workqueue</div><div id="4192" class="line none"> 4192  *</div><div id="4193" class="line none"> 4193  * Submits a work item to a workqueue that runs in user mode. A temporary</div><div id="4194" class="line none"> 4194  * memory allocation is made from the caller's resource pool which is freed</div><div id="4195" class="line none"> 4195  * once the worker thread consumes the k_work item. The workqueue</div><div id="4196" class="line none"> 4196  * thread must have memory access to the k_work item being submitted. The caller</div><div id="4197" class="line none"> 4197  * must have permission granted on the work_q parameter's queue object.</div><div id="4198" class="line none"> 4198  *</div><div id="4199" class="line none"> 4199  * @funcprops \isr_ok</div><div id="4200" class="line none"> 4200  *</div><div id="4201" class="line none"> 4201  * @param work_q Address of workqueue.</div><div id="4202" class="line none"> 4202  * @param work Address of work item.</div><div id="4203" class="line none"> 4203  *</div><div id="4204" class="line none"> 4204  * @retval -EBUSY if the work item was already in some workqueue</div><div id="4205" class="line none"> 4205  * @retval -ENOMEM if no memory for thread resource pool allocation</div><div id="4206" class="line none"> 4206  * @retval 0 Success</div><div id="4207" class="line none"> 4207  */</div><div id="4208" class="line none"> 4208 static inline int <a href="kernel.h.html#4208">k_work_user_submit_to_queue</a>(struct <a href="kernel.h.html#4110">k_work_user_q</a> *work_q,</div><div id="4209" class="line none"> 4209                                               struct <a href="kernel.h.html#4119">k_work_user</a> *<a href="kernel.h.html#3907">work</a>)</div><div id="4210" class="line none"> 4210 {</div><div id="4211" class="line none"> 4211         int ret = -EBUSY;</div><div id="4212" class="line none"> 4212 </div><div id="4213" class="line none"> 4213         if (!atomic_test_and_set_bit(&amp;<a href="kernel.h.html#3907">work</a>-&gt;<a href="kernel.h.html#2764">flags</a>,</div><div id="4214" class="line none"> 4214                                      <a href="kernel.h.html#4116">K_WORK_USER_STATE_PENDING</a>)) {</div><div id="4215" class="line none"> 4215                 ret = k_queue_alloc_append(&amp;work_q-&gt;<a href="kernel.h.html#3889">queue</a>, <a href="kernel.h.html#3907">work</a>);</div><div id="4216" class="line none"> 4216 </div><div id="4217" class="line none"> 4217                 /* Couldn't insert into the queue. Clear the pending bit</div><div id="4218" class="line none"> 4218                  * so the work item can be submitted again</div><div id="4219" class="line none"> 4219                  */</div><div id="4220" class="line none"> 4220                 if (ret != 0) {</div><div id="4221" class="line none"> 4221                         atomic_clear_bit(&amp;<a href="kernel.h.html#3907">work</a>-&gt;<a href="kernel.h.html#2764">flags</a>,</div><div id="4222" class="line none"> 4222                                          <a href="kernel.h.html#4116">K_WORK_USER_STATE_PENDING</a>);</div><div id="4223" class="line none"> 4223                 }</div><div id="4224" class="line none"> 4224         }</div><div id="4225" class="line none"> 4225 </div><div id="4226" class="line none"> 4226         return ret;</div><div id="4227" class="line none"> 4227 }</div><div id="4228" class="line none"> 4228 </div><div id="4229" class="line none"> 4229 /**</div><div id="4230" class="line none"> 4230  * @brief Start a workqueue in user mode</div><div id="4231" class="line none"> 4231  *</div><div id="4232" class="line none"> 4232  * This works identically to k_work_queue_start() except it is callable from</div><div id="4233" class="line none"> 4233  * user mode, and the worker thread created will run in user mode.  The caller</div><div id="4234" class="line none"> 4234  * must have permissions granted on both the work_q parameter's thread and</div><div id="4235" class="line none"> 4235  * queue objects, and the same restrictions on priority apply as</div><div id="4236" class="line none"> 4236  * k_thread_create().</div><div id="4237" class="line none"> 4237  *</div><div id="4238" class="line none"> 4238  * @param work_q Address of workqueue.</div><div id="4239" class="line none"> 4239  * @param stack Pointer to work queue thread's stack space, as defined by</div><div id="4240" class="line none"> 4240  *              K_THREAD_STACK_DEFINE()</div><div id="4241" class="line none"> 4241  * @param stack_size Size of the work queue thread's stack (in bytes), which</div><div id="4242" class="line none"> 4242  *              should either be the same constant passed to</div><div id="4243" class="line none"> 4243  *              K_THREAD_STACK_DEFINE() or the value of K_THREAD_STACK_SIZEOF().</div><div id="4244" class="line none"> 4244  * @param prio Priority of the work queue's thread.</div><div id="4245" class="line none"> 4245  * @param name optional thread name.  If not null a copy is made into the</div><div id="4246" class="line none"> 4246  *              thread's name buffer.</div><div id="4247" class="line none"> 4247  */</div><div id="4248" class="line none"> 4248 void k_work_user_queue_start(struct <a href="kernel.h.html#4110">k_work_user_q</a> *work_q,</div><div id="4249" class="line none"> 4249                                     <a href="arch/arch_interface.h.html#46">k_thread_stack_t</a> *<a href="sys/rb.h.html#173">stack</a>,</div><div id="4250" class="line none"> 4250                                     size_t stack_size, int <a href="kernel/thread.h.html#95">prio</a>,</div><div id="4251" class="line none"> 4251                                     const char *<a href="kernel.h.html#4006">name</a>);</div><div id="4252" class="line none"> 4252 </div><div id="4253" class="line none"> 4253 /**</div><div id="4254" class="line none"> 4254  * @brief Access the user mode thread that animates a work queue.</div><div id="4255" class="line none"> 4255  *</div><div id="4256" class="line none"> 4256  * This is necessary to grant a user mode work queue thread access to things</div><div id="4257" class="line none"> 4257  * the work items it will process are expected to use.</div><div id="4258" class="line none"> 4258  *</div><div id="4259" class="line none"> 4259  * @param work_q pointer to the user mode queue structure.</div><div id="4260" class="line none"> 4260  *</div><div id="4261" class="line none"> 4261  * @return the user mode thread associated with the work queue.</div><div id="4262" class="line none"> 4262  */</div><div id="4263" class="line none"> 4263 static inline <a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4263">k_work_user_queue_thread_get</a>(struct <a href="kernel.h.html#4110">k_work_user_q</a> *work_q)</div><div id="4264" class="line none"> 4264 {</div><div id="4265" class="line none"> 4265         return &amp;work_q-&gt;<a href="kernel.h.html#4031">thread</a>;</div><div id="4266" class="line none"> 4266 }</div><div id="4267" class="line none"> 4267 </div><div id="4268" class="line none"> 4268 /** @} */</div><div id="4269" class="line none"> 4269 </div><div id="4270" class="line none"> 4270 /**</div><div id="4271" class="line none"> 4271  * @cond INTERNAL_HIDDEN</div><div id="4272" class="line none"> 4272  */</div><div id="4273" class="line none"> 4273 </div><div id="4274" class="line none"> 4274 struct <a href="kernel.h.html#4274">k_work_poll</a> {</div><div id="4275" class="line none"> 4275         struct <a href="kernel.h.html#3877">k_work</a> <a href="kernel.h.html#3907">work</a>;</div><div id="4276" class="line none"> 4276         struct <a href="kernel.h.html#4029">k_work_q</a> *<a href="kernel.h.html#4276">workq</a>;</div><div id="4277" class="line none"> 4277         struct <a href="kernel/thread.h.html#250">z_poller</a> <a href="kernel.h.html#4277">poller</a>;</div><div id="4278" class="line none"> 4278         struct <a href="kernel.h.html#5712">k_poll_event</a> *<a href="kernel.h.html#2223">events</a>;</div><div id="4279" class="line none"> 4279         int <a href="kernel.h.html#4279">num_events</a>;</div><div id="4280" class="line none"> 4280         <a href="kernel.h.html#3276">k_work_handler_t</a> <a href="kernel.h.html#4280">real_handler</a>;</div><div id="4281" class="line none"> 4281         struct <a href="kernel_structs.h.html#293">_timeout</a> <a href="kernel.h.html#1452">timeout</a>;</div><div id="4282" class="line none"> 4282         int <a href="kernel.h.html#4282">poll_result</a>;</div><div id="4283" class="line none"> 4283 };</div><div id="4284" class="line none"> 4284 </div><div id="4285" class="line none"> 4285 /**</div><div id="4286" class="line none"> 4286  * INTERNAL_HIDDEN @endcond</div><div id="4287" class="line none"> 4287  */</div><div id="4288" class="line none"> 4288 </div><div id="4289" class="line none"> 4289 /**</div><div id="4290" class="line none"> 4290  * @addtogroup workqueue_apis</div><div id="4291" class="line none"> 4291  * @{</div><div id="4292" class="line none"> 4292  */</div><div id="4293" class="line none"> 4293 </div><div id="4294" class="line none"> 4294 /**</div><div id="4295" class="line none"> 4295  * @brief Initialize a statically-defined work item.</div><div id="4296" class="line none"> 4296  *</div><div id="4297" class="line none"> 4297  * This macro can be used to initialize a statically-defined workqueue work</div><div id="4298" class="line none"> 4298  * item, prior to its first use. For example,</div><div id="4299" class="line none"> 4299  *</div><div id="4300" class="line none"> 4300  * @code static K_WORK_DEFINE(&lt;work&gt;, &lt;work_handler&gt;); @endcode</div><div id="4301" class="line none"> 4301  *</div><div id="4302" class="line none"> 4302  * @param work Symbol name for work item object</div><div id="4303" class="line none"> 4303  * @param work_handler Function to invoke each time work item is processed.</div><div id="4304" class="line none"> 4304  */</div><div id="4305" class="line none"> 4305 #define <a href="kernel.h.html#4305">K_WORK_DEFINE</a>(<a href="kernel.h.html#3907">work</a>, work_handler) \</div><div id="4306" class="line none"> 4306         struct <a href="kernel.h.html#3877">k_work</a> <a href="kernel.h.html#3907">work</a> = <a href="kernel.h.html#3900">Z_WORK_INITIALIZER</a>(work_handler)</div><div id="4307" class="line none"> 4307 </div><div id="4308" class="line none"> 4308 /**</div><div id="4309" class="line none"> 4309  * @brief Initialize a triggered work item.</div><div id="4310" class="line none"> 4310  *</div><div id="4311" class="line none"> 4311  * This routine initializes a workqueue triggered work item, prior to</div><div id="4312" class="line none"> 4312  * its first use.</div><div id="4313" class="line none"> 4313  *</div><div id="4314" class="line none"> 4314  * @param work Address of triggered work item.</div><div id="4315" class="line none"> 4315  * @param handler Function to invoke each time work item is processed.</div><div id="4316" class="line none"> 4316  */</div><div id="4317" class="line none"> 4317 void k_work_poll_init(struct <a href="kernel.h.html#4274">k_work_poll</a> *<a href="kernel.h.html#3907">work</a>,</div><div id="4318" class="line none"> 4318                              <a href="kernel.h.html#3276">k_work_handler_t</a> <a href="kernel.h.html#3886">handler</a>);</div><div id="4319" class="line none"> 4319 </div><div id="4320" class="line none"> 4320 /**</div><div id="4321" class="line none"> 4321  * @brief Submit a triggered work item.</div><div id="4322" class="line none"> 4322  *</div><div id="4323" class="line none"> 4323  * This routine schedules work item @a work to be processed by workqueue</div><div id="4324" class="line none"> 4324  * @a work_q when one of the given @a events is signaled. The routine</div><div id="4325" class="line none"> 4325  * initiates internal poller for the work item and then returns to the caller.</div><div id="4326" class="line none"> 4326  * Only when one of the watched events happen the work item is actually</div><div id="4327" class="line none"> 4327  * submitted to the workqueue and becomes pending.</div><div id="4328" class="line none"> 4328  *</div><div id="4329" class="line none"> 4329  * Submitting a previously submitted triggered work item that is still</div><div id="4330" class="line none"> 4330  * waiting for the event cancels the existing submission and reschedules it</div><div id="4331" class="line none"> 4331  * the using the new event list. Note that this behavior is inherently subject</div><div id="4332" class="line none"> 4332  * to race conditions with the pre-existing triggered work item and work queue,</div><div id="4333" class="line none"> 4333  * so care must be taken to synchronize such resubmissions externally.</div><div id="4334" class="line none"> 4334  *</div><div id="4335" class="line none"> 4335  * @funcprops \isr_ok</div><div id="4336" class="line none"> 4336  *</div><div id="4337" class="line none"> 4337  * @warning</div><div id="4338" class="line none"> 4338  * Provided array of events as well as a triggered work item must be placed</div><div id="4339" class="line none"> 4339  * in persistent memory (valid until work handler execution or work</div><div id="4340" class="line none"> 4340  * cancellation) and cannot be modified after submission.</div><div id="4341" class="line none"> 4341  *</div><div id="4342" class="line none"> 4342  * @param work_q Address of workqueue.</div><div id="4343" class="line none"> 4343  * @param work Address of delayed work item.</div><div id="4344" class="line none"> 4344  * @param events An array of events which trigger the work.</div><div id="4345" class="line none"> 4345  * @param num_events The number of events in the array.</div><div id="4346" class="line none"> 4346  * @param timeout Timeout after which the work will be scheduled</div><div id="4347" class="line none"> 4347  *                for execution even if not triggered.</div><div id="4348" class="line none"> 4348  *</div><div id="4349" class="line none"> 4349  *</div><div id="4350" class="line none"> 4350  * @retval 0 Work item started watching for events.</div><div id="4351" class="line none"> 4351  * @retval -EINVAL Work item is being processed or has completed its work.</div><div id="4352" class="line none"> 4352  * @retval -EADDRINUSE Work item is pending on a different workqueue.</div><div id="4353" class="line none"> 4353  */</div><div id="4354" class="line none"> 4354 int k_work_poll_submit_to_queue(struct <a href="kernel.h.html#4029">k_work_q</a> *work_q,</div><div id="4355" class="line none"> 4355                                        struct <a href="kernel.h.html#4274">k_work_poll</a> *<a href="kernel.h.html#3907">work</a>,</div><div id="4356" class="line none"> 4356                                        struct <a href="kernel.h.html#5712">k_poll_event</a> *<a href="kernel.h.html#2223">events</a>,</div><div id="4357" class="line none"> 4357                                        int <a href="kernel.h.html#4279">num_events</a>,</div><div id="4358" class="line none"> 4358                                        k_timeout_t <a href="kernel.h.html#1452">timeout</a>);</div><div id="4359" class="line none"> 4359 </div><div id="4360" class="line none"> 4360 /**</div><div id="4361" class="line none"> 4361  * @brief Submit a triggered work item to the system workqueue.</div><div id="4362" class="line none"> 4362  *</div><div id="4363" class="line none"> 4363  * This routine schedules work item @a work to be processed by system</div><div id="4364" class="line none"> 4364  * workqueue when one of the given @a events is signaled. The routine</div><div id="4365" class="line none"> 4365  * initiates internal poller for the work item and then returns to the caller.</div><div id="4366" class="line none"> 4366  * Only when one of the watched events happen the work item is actually</div><div id="4367" class="line none"> 4367  * submitted to the workqueue and becomes pending.</div><div id="4368" class="line none"> 4368  *</div><div id="4369" class="line none"> 4369  * Submitting a previously submitted triggered work item that is still</div><div id="4370" class="line none"> 4370  * waiting for the event cancels the existing submission and reschedules it</div><div id="4371" class="line none"> 4371  * the using the new event list. Note that this behavior is inherently subject</div><div id="4372" class="line none"> 4372  * to race conditions with the pre-existing triggered work item and work queue,</div><div id="4373" class="line none"> 4373  * so care must be taken to synchronize such resubmissions externally.</div><div id="4374" class="line none"> 4374  *</div><div id="4375" class="line none"> 4375  * @funcprops \isr_ok</div><div id="4376" class="line none"> 4376  *</div><div id="4377" class="line none"> 4377  * @warning</div><div id="4378" class="line none"> 4378  * Provided array of events as well as a triggered work item must not be</div><div id="4379" class="line none"> 4379  * modified until the item has been processed by the workqueue.</div><div id="4380" class="line none"> 4380  *</div><div id="4381" class="line none"> 4381  * @param work Address of delayed work item.</div><div id="4382" class="line none"> 4382  * @param events An array of events which trigger the work.</div><div id="4383" class="line none"> 4383  * @param num_events The number of events in the array.</div><div id="4384" class="line none"> 4384  * @param timeout Timeout after which the work will be scheduled</div><div id="4385" class="line none"> 4385  *                for execution even if not triggered.</div><div id="4386" class="line none"> 4386  *</div><div id="4387" class="line none"> 4387  * @retval 0 Work item started watching for events.</div><div id="4388" class="line none"> 4388  * @retval -EINVAL Work item is being processed or has completed its work.</div><div id="4389" class="line none"> 4389  * @retval -EADDRINUSE Work item is pending on a different workqueue.</div><div id="4390" class="line none"> 4390  */</div><div id="4391" class="line none"> 4391 int k_work_poll_submit(struct <a href="kernel.h.html#4274">k_work_poll</a> *<a href="kernel.h.html#3907">work</a>,</div><div id="4392" class="line none"> 4392                                      struct <a href="kernel.h.html#5712">k_poll_event</a> *<a href="kernel.h.html#2223">events</a>,</div><div id="4393" class="line none"> 4393                                      int <a href="kernel.h.html#4279">num_events</a>,</div><div id="4394" class="line none"> 4394                                      k_timeout_t <a href="kernel.h.html#1452">timeout</a>);</div><div id="4395" class="line none"> 4395 </div><div id="4396" class="line none"> 4396 /**</div><div id="4397" class="line none"> 4397  * @brief Cancel a triggered work item.</div><div id="4398" class="line none"> 4398  *</div><div id="4399" class="line none"> 4399  * This routine cancels the submission of triggered work item @a work.</div><div id="4400" class="line none"> 4400  * A triggered work item can only be canceled if no event triggered work</div><div id="4401" class="line none"> 4401  * submission.</div><div id="4402" class="line none"> 4402  *</div><div id="4403" class="line none"> 4403  * @funcprops \isr_ok</div><div id="4404" class="line none"> 4404  *</div><div id="4405" class="line none"> 4405  * @param work Address of delayed work item.</div><div id="4406" class="line none"> 4406  *</div><div id="4407" class="line none"> 4407  * @retval 0 Work item canceled.</div><div id="4408" class="line none"> 4408  * @retval -EINVAL Work item is being processed or has completed its work.</div><div id="4409" class="line none"> 4409  */</div><div id="4410" class="line none"> 4410 int k_work_poll_cancel(struct <a href="kernel.h.html#4274">k_work_poll</a> *<a href="kernel.h.html#3907">work</a>);</div><div id="4411" class="line none"> 4411 </div><div id="4412" class="line none"> 4412 /** @} */</div><div id="4413" class="line none"> 4413 </div><div id="4414" class="line none"> 4414 /**</div><div id="4415" class="line none"> 4415  * @defgroup msgq_apis Message Queue APIs</div><div id="4416" class="line none"> 4416  * @ingroup kernel_apis</div><div id="4417" class="line none"> 4417  * @{</div><div id="4418" class="line none"> 4418  */</div><div id="4419" class="line none"> 4419 </div><div id="4420" class="line none"> 4420 /**</div><div id="4421" class="line none"> 4421  * @brief Message Queue Structure</div><div id="4422" class="line none"> 4422  */</div><div id="4423" class="line none"> 4423 struct <a href="kernel.h.html#4423">k_msgq</a> {</div><div id="4424" class="line none"> 4424         /** Message queue wait queue */</div><div id="4425" class="line none"> 4425         <a href="kernel_structs.h.html#286">_wait_q_t</a> <a href="kernel.h.html#1455">wait_q</a>;</div><div id="4426" class="line none"> 4426         /** Lock */</div><div id="4427" class="line none"> 4427         struct <a href="spinlock.h.html#45">k_spinlock</a> <a href="kernel.h.html#1852">lock</a>;</div><div id="4428" class="line none"> 4428         /** Message size */</div><div id="4429" class="line none"> 4429         size_t <a href="kernel.h.html#4429">msg_size</a>;</div><div id="4430" class="line none"> 4430         /** Maximal number of messages */</div><div id="4431" class="line none"> 4431         uint32_t <a href="kernel.h.html#4431">max_msgs</a>;</div><div id="4432" class="line none"> 4432         /** Start of message buffer */</div><div id="4433" class="line none"> 4433         char *<a href="kernel.h.html#4433">buffer_start</a>;</div><div id="4434" class="line none"> 4434         /** End of message buffer */</div><div id="4435" class="line none"> 4435         char *<a href="kernel.h.html#4435">buffer_end</a>;</div><div id="4436" class="line none"> 4436         /** Read pointer */</div><div id="4437" class="line none"> 4437         char *<a href="kernel.h.html#4437">read_ptr</a>;</div><div id="4438" class="line none"> 4438         /** Write pointer */</div><div id="4439" class="line none"> 4439         char *<a href="kernel.h.html#4439">write_ptr</a>;</div><div id="4440" class="line none"> 4440         /** Number of used messages */</div><div id="4441" class="line none"> 4441         uint32_t <a href="kernel.h.html#4441">used_msgs</a>;</div><div id="4442" class="line none"> 4442 </div><div id="4443" class="line none"> 4443         <a href="kernel.h.html#65">Z_DECL_POLL_EVENT</a></div><div id="4444" class="line none"> 4444 </div><div id="4445" class="line none"> 4445         /** Message queue */</div><div id="4446" class="line none"> 4446         uint8_t <a href="kernel.h.html#2764">flags</a>;</div><div id="4447" class="line none"> 4447 </div><div id="4448" class="line none"> 4448         SYS_PORT_TRACING_TRACKING_FIELD(<a href="kernel.h.html#4423">k_msgq</a>)</div><div id="4449" class="line none"> 4449 </div><div id="4450" class="line none"> 4450 #ifdef CONFIG_OBJ_CORE_MSGQ</div><div id="4451" class="line none"> 4451         struct k_obj_core  <a href="kernel.h.html#1475">obj_core</a>;</div><div id="4452" class="line none"> 4452 #endif</div><div id="4453" class="line none"> 4453 };</div><div id="4454" class="line none"> 4454 /**</div><div id="4455" class="line none"> 4455  * @cond INTERNAL_HIDDEN</div><div id="4456" class="line none"> 4456  */</div><div id="4457" class="line none"> 4457 </div><div id="4458" class="line none"> 4458 </div><div id="4459" class="line none"> 4459 #define <a href="kernel.h.html#4459">Z_MSGQ_INITIALIZER</a>(<a href="kernel.h.html#5739">obj</a>, q_buffer, q_msg_size, q_max_msgs) \</div><div id="4460" class="line none"> 4460         { \</div><div id="4461" class="line none"> 4461         .<a href="kernel.h.html#1455">wait_q</a> = <a href="kernel_structs.h.html#280">Z_WAIT_Q_INIT</a>(&amp;<a href="kernel.h.html#5739">obj</a>.<a href="kernel.h.html#1455">wait_q</a>), \</div><div id="4462" class="line none"> 4462         .<a href="kernel.h.html#4429">msg_size</a> = q_msg_size, \</div><div id="4463" class="line none"> 4463         .<a href="kernel.h.html#4431">max_msgs</a> = q_max_msgs, \</div><div id="4464" class="line none"> 4464         .<a href="kernel.h.html#4433">buffer_start</a> = q_buffer, \</div><div id="4465" class="line none"> 4465         .<a href="kernel.h.html#4435">buffer_end</a> = q_buffer + (q_max_msgs * q_msg_size), \</div><div id="4466" class="line none"> 4466         .<a href="kernel.h.html#4437">read_ptr</a> = q_buffer, \</div><div id="4467" class="line none"> 4467         .<a href="kernel.h.html#4439">write_ptr</a> = q_buffer, \</div><div id="4468" class="line none"> 4468         .<a href="kernel.h.html#4441">used_msgs</a> = 0, \</div><div id="4469" class="line none"> 4469         <a href="kernel.h.html#63">Z_POLL_EVENT_OBJ_INIT</a>(<a href="kernel.h.html#5739">obj</a>) \</div><div id="4470" class="line none"> 4470         }</div><div id="4471" class="line none"> 4471 </div><div id="4472" class="line none"> 4472 /**</div><div id="4473" class="line none"> 4473  * INTERNAL_HIDDEN @endcond</div><div id="4474" class="line none"> 4474  */</div><div id="4475" class="line none"> 4475 </div><div id="4476" class="line none"> 4476 </div><div id="4477" class="line none"> 4477 #define <a href="kernel.h.html#4477">K_MSGQ_FLAG_ALLOC</a>       BIT(0)</div><div id="4478" class="line none"> 4478 </div><div id="4479" class="line none"> 4479 /**</div><div id="4480" class="line none"> 4480  * @brief Message Queue Attributes</div><div id="4481" class="line none"> 4481  */</div><div id="4482" class="line none"> 4482 struct <a href="kernel.h.html#4482">k_msgq_attrs</a> {</div><div id="4483" class="line none"> 4483         /** Message Size */</div><div id="4484" class="line none"> 4484         size_t <a href="kernel.h.html#4429">msg_size</a>;</div><div id="4485" class="line none"> 4485         /** Maximal number of messages */</div><div id="4486" class="line none"> 4486         uint32_t <a href="kernel.h.html#4431">max_msgs</a>;</div><div id="4487" class="line none"> 4487         /** Used messages */</div><div id="4488" class="line none"> 4488         uint32_t <a href="kernel.h.html#4441">used_msgs</a>;</div><div id="4489" class="line none"> 4489 };</div><div id="4490" class="line none"> 4490 </div><div id="4491" class="line none"> 4491 </div><div id="4492" class="line none"> 4492 /**</div><div id="4493" class="line none"> 4493  * @brief Statically define and initialize a message queue.</div><div id="4494" class="line none"> 4494  *</div><div id="4495" class="line none"> 4495  * The message queue's ring buffer contains space for @a q_max_msgs messages,</div><div id="4496" class="line none"> 4496  * each of which is @a q_msg_size bytes long. Alignment of the message queue's</div><div id="4497" class="line none"> 4497  * ring buffer is not necessary, setting @a q_align to 1 is sufficient.</div><div id="4498" class="line none"> 4498  *</div><div id="4499" class="line none"> 4499  * The message queue can be accessed outside the module where it is defined</div><div id="4500" class="line none"> 4500  * using:</div><div id="4501" class="line none"> 4501  *</div><div id="4502" class="line none"> 4502  * @code extern struct k_msgq &lt;name&gt;; @endcode</div><div id="4503" class="line none"> 4503  *</div><div id="4504" class="line none"> 4504  * @param q_name Name of the message queue.</div><div id="4505" class="line none"> 4505  * @param q_msg_size Message size (in bytes).</div><div id="4506" class="line none"> 4506  * @param q_max_msgs Maximum number of messages that can be queued.</div><div id="4507" class="line none"> 4507  * @param q_align Alignment of the message queue's ring buffer (power of 2).</div><div id="4508" class="line none"> 4508  *</div><div id="4509" class="line none"> 4509  */</div><div id="4510" class="line none"> 4510 #define <a href="kernel.h.html#4510">K_MSGQ_DEFINE</a>(q_name, q_msg_size, q_max_msgs, q_align)          \</div><div id="4511" class="line none"> 4511         static char __noinit __aligned(q_align)                         \</div><div id="4512" class="line none"> 4512                 _k_fifo_buf_##q_name[(q_max_msgs) * (q_msg_size)];      \</div><div id="4513" class="line none"> 4513         STRUCT_SECTION_ITERABLE(<a href="kernel.h.html#4423">k_msgq</a>, q_name) =                       \</div><div id="4514" class="line none"> 4514                <a href="kernel.h.html#4459">Z_MSGQ_INITIALIZER</a>(q_name, _k_fifo_buf_##q_name, \</div><div id="4515" class="line none"> 4515                                   (q_msg_size), (q_max_msgs))</div><div id="4516" class="line none"> 4516 </div><div id="4517" class="line none"> 4517 /**</div><div id="4518" class="line none"> 4518  * @brief Initialize a message queue.</div><div id="4519" class="line none"> 4519  *</div><div id="4520" class="line none"> 4520  * This routine initializes a message queue object, prior to its first use.</div><div id="4521" class="line none"> 4521  *</div><div id="4522" class="line none"> 4522  * The message queue's ring buffer must contain space for @a max_msgs messages,</div><div id="4523" class="line none"> 4523  * each of which is @a msg_size bytes long. Alignment of the message queue's</div><div id="4524" class="line none"> 4524  * ring buffer is not necessary.</div><div id="4525" class="line none"> 4525  *</div><div id="4526" class="line none"> 4526  * @param msgq Address of the message queue.</div><div id="4527" class="line none"> 4527  * @param buffer Pointer to ring buffer that holds queued messages.</div><div id="4528" class="line none"> 4528  * @param msg_size Message size (in bytes).</div><div id="4529" class="line none"> 4529  * @param max_msgs Maximum number of messages that can be queued.</div><div id="4530" class="line none"> 4530  */</div><div id="4531" class="line none"> 4531 void k_msgq_init(struct <a href="kernel.h.html#4423">k_msgq</a> *<a href="kernel.h.html#5744">msgq</a>, char *<a href="kernel.h.html#4868">buffer</a>, size_t <a href="kernel.h.html#4429">msg_size</a>,</div><div id="4532" class="line none"> 4532                  uint32_t <a href="kernel.h.html#4431">max_msgs</a>);</div><div id="4533" class="line none"> 4533 </div><div id="4534" class="line none"> 4534 /**</div><div id="4535" class="line none"> 4535  * @brief Initialize a message queue.</div><div id="4536" class="line none"> 4536  *</div><div id="4537" class="line none"> 4537  * This routine initializes a message queue object, prior to its first use,</div><div id="4538" class="line none"> 4538  * allocating its internal ring buffer from the calling thread's resource</div><div id="4539" class="line none"> 4539  * pool.</div><div id="4540" class="line none"> 4540  *</div><div id="4541" class="line none"> 4541  * Memory allocated for the ring buffer can be released by calling</div><div id="4542" class="line none"> 4542  * k_msgq_cleanup(), or if userspace is enabled and the msgq object loses</div><div id="4543" class="line none"> 4543  * all of its references.</div><div id="4544" class="line none"> 4544  *</div><div id="4545" class="line none"> 4545  * @param msgq Address of the message queue.</div><div id="4546" class="line none"> 4546  * @param msg_size Message size (in bytes).</div><div id="4547" class="line none"> 4547  * @param max_msgs Maximum number of messages that can be queued.</div><div id="4548" class="line none"> 4548  *</div><div id="4549" class="line none"> 4549  * @return 0 on success, -ENOMEM if there was insufficient memory in the</div><div id="4550" class="line none"> 4550  *      thread's resource pool, or -EINVAL if the size parameters cause</div><div id="4551" class="line none"> 4551  *      an integer overflow.</div><div id="4552" class="line none"> 4552  */</div><div id="4553" class="line none"> 4553 __syscall int k_msgq_alloc_init(struct <a href="kernel.h.html#4423">k_msgq</a> *<a href="kernel.h.html#5744">msgq</a>, size_t <a href="kernel.h.html#4429">msg_size</a>,</div><div id="4554" class="line none"> 4554                                 uint32_t <a href="kernel.h.html#4431">max_msgs</a>);</div><div id="4555" class="line none"> 4555 </div><div id="4556" class="line none"> 4556 /**</div><div id="4557" class="line none"> 4557  * @brief Release allocated buffer for a queue</div><div id="4558" class="line none"> 4558  *</div><div id="4559" class="line none"> 4559  * Releases memory allocated for the ring buffer.</div><div id="4560" class="line none"> 4560  *</div><div id="4561" class="line none"> 4561  * @param msgq message queue to cleanup</div><div id="4562" class="line none"> 4562  *</div><div id="4563" class="line none"> 4563  * @retval 0 on success</div><div id="4564" class="line none"> 4564  * @retval -EBUSY Queue not empty</div><div id="4565" class="line none"> 4565  */</div><div id="4566" class="line none"> 4566 int k_msgq_cleanup(struct <a href="kernel.h.html#4423">k_msgq</a> *<a href="kernel.h.html#5744">msgq</a>);</div><div id="4567" class="line none"> 4567 </div><div id="4568" class="line none"> 4568 /**</div><div id="4569" class="line none"> 4569  * @brief Send a message to a message queue.</div><div id="4570" class="line none"> 4570  *</div><div id="4571" class="line none"> 4571  * This routine sends a message to message queue @a q.</div><div id="4572" class="line none"> 4572  *</div><div id="4573" class="line none"> 4573  * @note The message content is copied from @a data into @a msgq and the @a data</div><div id="4574" class="line none"> 4574  * pointer is not retained, so the message content will not be modified</div><div id="4575" class="line none"> 4575  * by this function.</div><div id="4576" class="line none"> 4576  *</div><div id="4577" class="line none"> 4577  * @funcprops \isr_ok</div><div id="4578" class="line none"> 4578  *</div><div id="4579" class="line none"> 4579  * @param msgq Address of the message queue.</div><div id="4580" class="line none"> 4580  * @param data Pointer to the message.</div><div id="4581" class="line none"> 4581  * @param timeout Waiting period to add the message, or one of the special</div><div id="4582" class="line none"> 4582  *                values K_NO_WAIT and K_FOREVER.</div><div id="4583" class="line none"> 4583  *</div><div id="4584" class="line none"> 4584  * @retval 0 Message sent.</div><div id="4585" class="line none"> 4585  * @retval -ENOMSG Returned without waiting or queue purged.</div><div id="4586" class="line none"> 4586  * @retval -EAGAIN Waiting period timed out.</div><div id="4587" class="line none"> 4587  */</div><div id="4588" class="line none"> 4588 __syscall int k_msgq_put(struct <a href="kernel.h.html#4423">k_msgq</a> *<a href="kernel.h.html#5744">msgq</a>, const void *<a href="logging/log_msg.h.html#100">data</a>, k_timeout_t <a href="kernel.h.html#1452">timeout</a>);</div><div id="4589" class="line none"> 4589 </div><div id="4590" class="line none"> 4590 /**</div><div id="4591" class="line none"> 4591  * @brief Receive a message from a message queue.</div><div id="4592" class="line none"> 4592  *</div><div id="4593" class="line none"> 4593  * This routine receives a message from message queue @a q in a "first in,</div><div id="4594" class="line none"> 4594  * first out" manner.</div><div id="4595" class="line none"> 4595  *</div><div id="4596" class="line none"> 4596  * @note @a timeout must be set to K_NO_WAIT if called from ISR.</div><div id="4597" class="line none"> 4597  *</div><div id="4598" class="line none"> 4598  * @funcprops \isr_ok</div><div id="4599" class="line none"> 4599  *</div><div id="4600" class="line none"> 4600  * @param msgq Address of the message queue.</div><div id="4601" class="line none"> 4601  * @param data Address of area to hold the received message.</div><div id="4602" class="line none"> 4602  * @param timeout Waiting period to receive the message,</div><div id="4603" class="line none"> 4603  *                or one of the special values K_NO_WAIT and</div><div id="4604" class="line none"> 4604  *                K_FOREVER.</div><div id="4605" class="line none"> 4605  *</div><div id="4606" class="line none"> 4606  * @retval 0 Message received.</div><div id="4607" class="line none"> 4607  * @retval -ENOMSG Returned without waiting.</div><div id="4608" class="line none"> 4608  * @retval -EAGAIN Waiting period timed out.</div><div id="4609" class="line none"> 4609  */</div><div id="4610" class="line none"> 4610 __syscall int k_msgq_get(struct <a href="kernel.h.html#4423">k_msgq</a> *<a href="kernel.h.html#5744">msgq</a>, void *<a href="logging/log_msg.h.html#100">data</a>, k_timeout_t <a href="kernel.h.html#1452">timeout</a>);</div><div id="4611" class="line none"> 4611 </div><div id="4612" class="line none"> 4612 /**</div><div id="4613" class="line none"> 4613  * @brief Peek/read a message from a message queue.</div><div id="4614" class="line none"> 4614  *</div><div id="4615" class="line none"> 4615  * This routine reads a message from message queue @a q in a "first in,</div><div id="4616" class="line none"> 4616  * first out" manner and leaves the message in the queue.</div><div id="4617" class="line none"> 4617  *</div><div id="4618" class="line none"> 4618  * @funcprops \isr_ok</div><div id="4619" class="line none"> 4619  *</div><div id="4620" class="line none"> 4620  * @param msgq Address of the message queue.</div><div id="4621" class="line none"> 4621  * @param data Address of area to hold the message read from the queue.</div><div id="4622" class="line none"> 4622  *</div><div id="4623" class="line none"> 4623  * @retval 0 Message read.</div><div id="4624" class="line none"> 4624  * @retval -ENOMSG Returned when the queue has no message.</div><div id="4625" class="line none"> 4625  */</div><div id="4626" class="line none"> 4626 __syscall int k_msgq_peek(struct <a href="kernel.h.html#4423">k_msgq</a> *<a href="kernel.h.html#5744">msgq</a>, void *<a href="logging/log_msg.h.html#100">data</a>);</div><div id="4627" class="line none"> 4627 </div><div id="4628" class="line none"> 4628 /**</div><div id="4629" class="line none"> 4629  * @brief Peek/read a message from a message queue at the specified index</div><div id="4630" class="line none"> 4630  *</div><div id="4631" class="line none"> 4631  * This routine reads a message from message queue at the specified index</div><div id="4632" class="line none"> 4632  * and leaves the message in the queue.</div><div id="4633" class="line none"> 4633  * k_msgq_peek_at(msgq, data, 0) is equivalent to k_msgq_peek(msgq, data)</div><div id="4634" class="line none"> 4634  *</div><div id="4635" class="line none"> 4635  * @funcprops \isr_ok</div><div id="4636" class="line none"> 4636  *</div><div id="4637" class="line none"> 4637  * @param msgq Address of the message queue.</div><div id="4638" class="line none"> 4638  * @param data Address of area to hold the message read from the queue.</div><div id="4639" class="line none"> 4639  * @param idx Message queue index at which to peek</div><div id="4640" class="line none"> 4640  *</div><div id="4641" class="line none"> 4641  * @retval 0 Message read.</div><div id="4642" class="line none"> 4642  * @retval -ENOMSG Returned when the queue has no message at index.</div><div id="4643" class="line none"> 4643  */</div><div id="4644" class="line none"> 4644 __syscall int k_msgq_peek_at(struct <a href="kernel.h.html#4423">k_msgq</a> *<a href="kernel.h.html#5744">msgq</a>, void *<a href="logging/log_msg.h.html#100">data</a>, uint32_t idx);</div><div id="4645" class="line none"> 4645 </div><div id="4646" class="line none"> 4646 /**</div><div id="4647" class="line none"> 4647  * @brief Purge a message queue.</div><div id="4648" class="line none"> 4648  *</div><div id="4649" class="line none"> 4649  * This routine discards all unreceived messages in a message queue's ring</div><div id="4650" class="line none"> 4650  * buffer. Any threads that are blocked waiting to send a message to the</div><div id="4651" class="line none"> 4651  * message queue are unblocked and see an -ENOMSG error code.</div><div id="4652" class="line none"> 4652  *</div><div id="4653" class="line none"> 4653  * @param msgq Address of the message queue.</div><div id="4654" class="line none"> 4654  */</div><div id="4655" class="line none"> 4655 __syscall void k_msgq_purge(struct <a href="kernel.h.html#4423">k_msgq</a> *<a href="kernel.h.html#5744">msgq</a>);</div><div id="4656" class="line none"> 4656 </div><div id="4657" class="line none"> 4657 /**</div><div id="4658" class="line none"> 4658  * @brief Get the amount of free space in a message queue.</div><div id="4659" class="line none"> 4659  *</div><div id="4660" class="line none"> 4660  * This routine returns the number of unused entries in a message queue's</div><div id="4661" class="line none"> 4661  * ring buffer.</div><div id="4662" class="line none"> 4662  *</div><div id="4663" class="line none"> 4663  * @param msgq Address of the message queue.</div><div id="4664" class="line none"> 4664  *</div><div id="4665" class="line none"> 4665  * @return Number of unused ring buffer entries.</div><div id="4666" class="line none"> 4666  */</div><div id="4667" class="line none"> 4667 __syscall uint32_t k_msgq_num_free_get(struct <a href="kernel.h.html#4423">k_msgq</a> *<a href="kernel.h.html#5744">msgq</a>);</div><div id="4668" class="line none"> 4668 </div><div id="4669" class="line none"> 4669 /**</div><div id="4670" class="line none"> 4670  * @brief Get basic attributes of a message queue.</div><div id="4671" class="line none"> 4671  *</div><div id="4672" class="line none"> 4672  * This routine fetches basic attributes of message queue into attr argument.</div><div id="4673" class="line none"> 4673  *</div><div id="4674" class="line none"> 4674  * @param msgq Address of the message queue.</div><div id="4675" class="line none"> 4675  * @param attrs pointer to message queue attribute structure.</div><div id="4676" class="line none"> 4676  */</div><div id="4677" class="line none"> 4677 __syscall void  k_msgq_get_attrs(struct <a href="kernel.h.html#4423">k_msgq</a> *<a href="kernel.h.html#5744">msgq</a>,</div><div id="4678" class="line none"> 4678                                  struct <a href="kernel.h.html#4482">k_msgq_attrs</a> *attrs);</div><div id="4679" class="line none"> 4679 </div><div id="4680" class="line none"> 4680 </div><div id="4681" class="line none"> 4681 static inline uint32_t <a href="kernel.h.html#4681">z_impl_k_msgq_num_free_get</a>(struct <a href="kernel.h.html#4423">k_msgq</a> *<a href="kernel.h.html#5744">msgq</a>)</div><div id="4682" class="line none"> 4682 {</div><div id="4683" class="line none"> 4683         return <a href="kernel.h.html#5744">msgq</a>-&gt;<a href="kernel.h.html#4431">max_msgs</a> - <a href="kernel.h.html#5744">msgq</a>-&gt;<a href="kernel.h.html#4441">used_msgs</a>;</div><div id="4684" class="line none"> 4684 }</div><div id="4685" class="line none"> 4685 </div><div id="4686" class="line none"> 4686 /**</div><div id="4687" class="line none"> 4687  * @brief Get the number of messages in a message queue.</div><div id="4688" class="line none"> 4688  *</div><div id="4689" class="line none"> 4689  * This routine returns the number of messages in a message queue's ring buffer.</div><div id="4690" class="line none"> 4690  *</div><div id="4691" class="line none"> 4691  * @param msgq Address of the message queue.</div><div id="4692" class="line none"> 4692  *</div><div id="4693" class="line none"> 4693  * @return Number of messages.</div><div id="4694" class="line none"> 4694  */</div><div id="4695" class="line none"> 4695 __syscall uint32_t k_msgq_num_used_get(struct <a href="kernel.h.html#4423">k_msgq</a> *<a href="kernel.h.html#5744">msgq</a>);</div><div id="4696" class="line none"> 4696 </div><div id="4697" class="line none"> 4697 static inline uint32_t <a href="kernel.h.html#4697">z_impl_k_msgq_num_used_get</a>(struct <a href="kernel.h.html#4423">k_msgq</a> *<a href="kernel.h.html#5744">msgq</a>)</div><div id="4698" class="line none"> 4698 {</div><div id="4699" class="line none"> 4699         return <a href="kernel.h.html#5744">msgq</a>-&gt;<a href="kernel.h.html#4441">used_msgs</a>;</div><div id="4700" class="line none"> 4700 }</div><div id="4701" class="line none"> 4701 </div><div id="4702" class="line none"> 4702 /** @} */</div><div id="4703" class="line none"> 4703 </div><div id="4704" class="line none"> 4704 /**</div><div id="4705" class="line none"> 4705  * @defgroup mailbox_apis Mailbox APIs</div><div id="4706" class="line none"> 4706  * @ingroup kernel_apis</div><div id="4707" class="line none"> 4707  * @{</div><div id="4708" class="line none"> 4708  */</div><div id="4709" class="line none"> 4709 </div><div id="4710" class="line none"> 4710 /**</div><div id="4711" class="line none"> 4711  * @brief Mailbox Message Structure</div><div id="4712" class="line none"> 4712  *</div><div id="4713" class="line none"> 4713  */</div><div id="4714" class="line none"> 4714 struct <a href="kernel.h.html#4714">k_mbox_msg</a> {</div><div id="4715" class="line none"> 4715         /** size of message (in bytes) */</div><div id="4716" class="line none"> 4716         size_t <a href="kernel.h.html#4716">size</a>;</div><div id="4717" class="line none"> 4717         /** application-defined information value */</div><div id="4718" class="line none"> 4718         uint32_t <a href="kernel.h.html#4718">info</a>;</div><div id="4719" class="line none"> 4719         /** sender's message data buffer */</div><div id="4720" class="line none"> 4720         void *<a href="kernel.h.html#4720">tx_data</a>;</div><div id="4721" class="line none"> 4721         /** source thread id */</div><div id="4722" class="line none"> 4722         <a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4722">rx_source_thread</a>;</div><div id="4723" class="line none"> 4723         /** target thread id */</div><div id="4724" class="line none"> 4724         <a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4724">tx_target_thread</a>;</div><div id="4725" class="line none"> 4725         /** internal use only - thread waiting on send (may be a dummy) */</div><div id="4726" class="line none"> 4726         <a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4726">_syncing_thread</a>;</div><div id="4727" class="line none"> 4727 #if (CONFIG_NUM_MBOX_ASYNC_MSGS &gt; 0)</div><div id="4728" class="line none"> 4728         /** internal use only - semaphore used during asynchronous send */</div><div id="4729" class="line none"> 4729         struct <a href="kernel.h.html#3111">k_sem</a> *<a href="kernel.h.html#4729">_async_sem</a>;</div><div id="4730" class="line none"> 4730 #endif</div><div id="4731" class="line none"> 4731 };</div><div id="4732" class="line none"> 4732 /**</div><div id="4733" class="line none"> 4733  * @brief Mailbox Structure</div><div id="4734" class="line none"> 4734  *</div><div id="4735" class="line none"> 4735  */</div><div id="4736" class="line none"> 4736 struct <a href="kernel.h.html#4736">k_mbox</a> {</div><div id="4737" class="line none"> 4737         /** Transmit messages queue */</div><div id="4738" class="line none"> 4738         <a href="kernel_structs.h.html#286">_wait_q_t</a> <a href="kernel.h.html#4738">tx_msg_queue</a>;</div><div id="4739" class="line none"> 4739         /** Receive message queue */</div><div id="4740" class="line none"> 4740         <a href="kernel_structs.h.html#286">_wait_q_t</a> <a href="kernel.h.html#4740">rx_msg_queue</a>;</div><div id="4741" class="line none"> 4741         struct <a href="spinlock.h.html#45">k_spinlock</a> <a href="kernel.h.html#1852">lock</a>;</div><div id="4742" class="line none"> 4742 </div><div id="4743" class="line none"> 4743         SYS_PORT_TRACING_TRACKING_FIELD(<a href="kernel.h.html#4736">k_mbox</a>)</div><div id="4744" class="line none"> 4744 </div><div id="4745" class="line none"> 4745 #ifdef CONFIG_OBJ_CORE_MAILBOX</div><div id="4746" class="line none"> 4746         struct k_obj_core  <a href="kernel.h.html#1475">obj_core</a>;</div><div id="4747" class="line none"> 4747 #endif</div><div id="4748" class="line none"> 4748 };</div><div id="4749" class="line none"> 4749 /**</div><div id="4750" class="line none"> 4750  * @cond INTERNAL_HIDDEN</div><div id="4751" class="line none"> 4751  */</div><div id="4752" class="line none"> 4752 </div><div id="4753" class="line none"> 4753 #define <a href="kernel.h.html#4753">Z_MBOX_INITIALIZER</a>(<a href="kernel.h.html#5739">obj</a>) \</div><div id="4754" class="line none"> 4754         { \</div><div id="4755" class="line none"> 4755         .<a href="kernel.h.html#4738">tx_msg_queue</a> = <a href="kernel_structs.h.html#280">Z_WAIT_Q_INIT</a>(&amp;<a href="kernel.h.html#5739">obj</a>.<a href="kernel.h.html#4738">tx_msg_queue</a>), \</div><div id="4756" class="line none"> 4756         .<a href="kernel.h.html#4740">rx_msg_queue</a> = <a href="kernel_structs.h.html#280">Z_WAIT_Q_INIT</a>(&amp;<a href="kernel.h.html#5739">obj</a>.<a href="kernel.h.html#4740">rx_msg_queue</a>), \</div><div id="4757" class="line none"> 4757         }</div><div id="4758" class="line none"> 4758 </div><div id="4759" class="line none"> 4759 /**</div><div id="4760" class="line none"> 4760  * INTERNAL_HIDDEN @endcond</div><div id="4761" class="line none"> 4761  */</div><div id="4762" class="line none"> 4762 </div><div id="4763" class="line none"> 4763 /**</div><div id="4764" class="line none"> 4764  * @brief Statically define and initialize a mailbox.</div><div id="4765" class="line none"> 4765  *</div><div id="4766" class="line none"> 4766  * The mailbox is to be accessed outside the module where it is defined using:</div><div id="4767" class="line none"> 4767  *</div><div id="4768" class="line none"> 4768  * @code extern struct k_mbox &lt;name&gt;; @endcode</div><div id="4769" class="line none"> 4769  *</div><div id="4770" class="line none"> 4770  * @param name Name of the mailbox.</div><div id="4771" class="line none"> 4771  */</div><div id="4772" class="line none"> 4772 #define <a href="kernel.h.html#4772">K_MBOX_DEFINE</a>(<a href="kernel.h.html#4006">name</a>) \</div><div id="4773" class="line none"> 4773         STRUCT_SECTION_ITERABLE(<a href="kernel.h.html#4736">k_mbox</a>, <a href="kernel.h.html#4006">name</a>) = \</div><div id="4774" class="line none"> 4774                 <a href="kernel.h.html#4753">Z_MBOX_INITIALIZER</a>(<a href="kernel.h.html#4006">name</a>) \</div><div id="4775" class="line none"> 4775 </div><div id="4776" class="line none"> 4776 /**</div><div id="4777" class="line none"> 4777  * @brief Initialize a mailbox.</div><div id="4778" class="line none"> 4778  *</div><div id="4779" class="line none"> 4779  * This routine initializes a mailbox object, prior to its first use.</div><div id="4780" class="line none"> 4780  *</div><div id="4781" class="line none"> 4781  * @param mbox Address of the mailbox.</div><div id="4782" class="line none"> 4782  */</div><div id="4783" class="line none"> 4783 void k_mbox_init(struct <a href="kernel.h.html#4736">k_mbox</a> *mbox);</div><div id="4784" class="line none"> 4784 </div><div id="4785" class="line none"> 4785 /**</div><div id="4786" class="line none"> 4786  * @brief Send a mailbox message in a synchronous manner.</div><div id="4787" class="line none"> 4787  *</div><div id="4788" class="line none"> 4788  * This routine sends a message to @a mbox and waits for a receiver to both</div><div id="4789" class="line none"> 4789  * receive and process it. The message data may be in a buffer or non-existent</div><div id="4790" class="line none"> 4790  * (i.e. an empty message).</div><div id="4791" class="line none"> 4791  *</div><div id="4792" class="line none"> 4792  * @param mbox Address of the mailbox.</div><div id="4793" class="line none"> 4793  * @param tx_msg Address of the transmit message descriptor.</div><div id="4794" class="line none"> 4794  * @param timeout Waiting period for the message to be received,</div><div id="4795" class="line none"> 4795  *                or one of the special values K_NO_WAIT</div><div id="4796" class="line none"> 4796  *                and K_FOREVER. Once the message has been received,</div><div id="4797" class="line none"> 4797  *                this routine waits as long as necessary for the message</div><div id="4798" class="line none"> 4798  *                to be completely processed.</div><div id="4799" class="line none"> 4799  *</div><div id="4800" class="line none"> 4800  * @retval 0 Message sent.</div><div id="4801" class="line none"> 4801  * @retval -ENOMSG Returned without waiting.</div><div id="4802" class="line none"> 4802  * @retval -EAGAIN Waiting period timed out.</div><div id="4803" class="line none"> 4803  */</div><div id="4804" class="line none"> 4804 int k_mbox_put(struct <a href="kernel.h.html#4736">k_mbox</a> *mbox, struct <a href="kernel.h.html#4714">k_mbox_msg</a> *tx_msg,</div><div id="4805" class="line none"> 4805                       k_timeout_t <a href="kernel.h.html#1452">timeout</a>);</div><div id="4806" class="line none"> 4806 </div><div id="4807" class="line none"> 4807 /**</div><div id="4808" class="line none"> 4808  * @brief Send a mailbox message in an asynchronous manner.</div><div id="4809" class="line none"> 4809  *</div><div id="4810" class="line none"> 4810  * This routine sends a message to @a mbox without waiting for a receiver</div><div id="4811" class="line none"> 4811  * to process it. The message data may be in a buffer or non-existent</div><div id="4812" class="line none"> 4812  * (i.e. an empty message). Optionally, the semaphore @a sem will be given</div><div id="4813" class="line none"> 4813  * when the message has been both received and completely processed by</div><div id="4814" class="line none"> 4814  * the receiver.</div><div id="4815" class="line none"> 4815  *</div><div id="4816" class="line none"> 4816  * @param mbox Address of the mailbox.</div><div id="4817" class="line none"> 4817  * @param tx_msg Address of the transmit message descriptor.</div><div id="4818" class="line none"> 4818  * @param sem Address of a semaphore, or NULL if none is needed.</div><div id="4819" class="line none"> 4819  */</div><div id="4820" class="line none"> 4820 void k_mbox_async_put(struct <a href="kernel.h.html#4736">k_mbox</a> *mbox, struct <a href="kernel.h.html#4714">k_mbox_msg</a> *tx_msg,</div><div id="4821" class="line none"> 4821                              struct <a href="kernel.h.html#3111">k_sem</a> *<a href="kernel.h.html#3956">sem</a>);</div><div id="4822" class="line none"> 4822 </div><div id="4823" class="line none"> 4823 /**</div><div id="4824" class="line none"> 4824  * @brief Receive a mailbox message.</div><div id="4825" class="line none"> 4825  *</div><div id="4826" class="line none"> 4826  * This routine receives a message from @a mbox, then optionally retrieves</div><div id="4827" class="line none"> 4827  * its data and disposes of the message.</div><div id="4828" class="line none"> 4828  *</div><div id="4829" class="line none"> 4829  * @param mbox Address of the mailbox.</div><div id="4830" class="line none"> 4830  * @param rx_msg Address of the receive message descriptor.</div><div id="4831" class="line none"> 4831  * @param buffer Address of the buffer to receive data, or NULL to defer data</div><div id="4832" class="line none"> 4832  *               retrieval and message disposal until later.</div><div id="4833" class="line none"> 4833  * @param timeout Waiting period for a message to be received,</div><div id="4834" class="line none"> 4834  *                or one of the special values K_NO_WAIT and K_FOREVER.</div><div id="4835" class="line none"> 4835  *</div><div id="4836" class="line none"> 4836  * @retval 0 Message received.</div><div id="4837" class="line none"> 4837  * @retval -ENOMSG Returned without waiting.</div><div id="4838" class="line none"> 4838  * @retval -EAGAIN Waiting period timed out.</div><div id="4839" class="line none"> 4839  */</div><div id="4840" class="line none"> 4840 int k_mbox_get(struct <a href="kernel.h.html#4736">k_mbox</a> *mbox, struct <a href="kernel.h.html#4714">k_mbox_msg</a> *rx_msg,</div><div id="4841" class="line none"> 4841                       void *<a href="kernel.h.html#4868">buffer</a>, k_timeout_t <a href="kernel.h.html#1452">timeout</a>);</div><div id="4842" class="line none"> 4842 </div><div id="4843" class="line none"> 4843 /**</div><div id="4844" class="line none"> 4844  * @brief Retrieve mailbox message data into a buffer.</div><div id="4845" class="line none"> 4845  *</div><div id="4846" class="line none"> 4846  * This routine completes the processing of a received message by retrieving</div><div id="4847" class="line none"> 4847  * its data into a buffer, then disposing of the message.</div><div id="4848" class="line none"> 4848  *</div><div id="4849" class="line none"> 4849  * Alternatively, this routine can be used to dispose of a received message</div><div id="4850" class="line none"> 4850  * without retrieving its data.</div><div id="4851" class="line none"> 4851  *</div><div id="4852" class="line none"> 4852  * @param rx_msg Address of the receive message descriptor.</div><div id="4853" class="line none"> 4853  * @param buffer Address of the buffer to receive data, or NULL to discard</div><div id="4854" class="line none"> 4854  *               the data.</div><div id="4855" class="line none"> 4855  */</div><div id="4856" class="line none"> 4856 void k_mbox_data_get(struct <a href="kernel.h.html#4714">k_mbox_msg</a> *rx_msg, void *<a href="kernel.h.html#4868">buffer</a>);</div><div id="4857" class="line none"> 4857 </div><div id="4858" class="line none"> 4858 /** @} */</div><div id="4859" class="line none"> 4859 </div><div id="4860" class="line none"> 4860 /**</div><div id="4861" class="line none"> 4861  * @defgroup pipe_apis Pipe APIs</div><div id="4862" class="line none"> 4862  * @ingroup kernel_apis</div><div id="4863" class="line none"> 4863  * @{</div><div id="4864" class="line none"> 4864  */</div><div id="4865" class="line none"> 4865 </div><div id="4866" class="line none"> 4866 /** Pipe Structure */</div><div id="4867" class="line none"> 4867 struct <a href="kernel.h.html#4867">k_pipe</a> {</div><div id="4868" class="line none"> 4868         unsigned char *<a href="kernel.h.html#4868">buffer</a>;          /**&lt; Pipe buffer: may be NULL */</div><div id="4869" class="line none"> 4869         size_t         <a href="kernel.h.html#4716">size</a>;            /**&lt; Buffer size */</div><div id="4870" class="line none"> 4870         size_t         <a href="kernel.h.html#4870">bytes_used</a>;      /**&lt; Number of bytes used in buffer */</div><div id="4871" class="line none"> 4871         size_t         <a href="kernel.h.html#4871">read_index</a>;      /**&lt; Where in buffer to read from */</div><div id="4872" class="line none"> 4872         size_t         <a href="kernel.h.html#4872">write_index</a>;     /**&lt; Where in buffer to write */</div><div id="4873" class="line none"> 4873         struct <a href="spinlock.h.html#45">k_spinlock</a> <a href="kernel.h.html#1852">lock</a>;         /**&lt; Synchronization lock */</div><div id="4874" class="line none"> 4874 </div><div id="4875" class="line none"> 4875         struct {</div><div id="4876" class="line none"> 4876                 <a href="kernel_structs.h.html#286">_wait_q_t</a>      <a href="kernel.h.html#4876">readers</a>; /**&lt; Reader wait queue */</div><div id="4877" class="line none"> 4877                 <a href="kernel_structs.h.html#286">_wait_q_t</a>      <a href="kernel.h.html#4877">writers</a>; /**&lt; Writer wait queue */</div><div id="4878" class="line none"> 4878         } <a href="kernel.h.html#1455">wait_q</a>;                       /** Wait queue */</div><div id="4879" class="line none"> 4879 </div><div id="4880" class="line none"> 4880         <a href="kernel.h.html#65">Z_DECL_POLL_EVENT</a></div><div id="4881" class="line none"> 4881 </div><div id="4882" class="line none"> 4882         uint8_t        <a href="kernel.h.html#2764">flags</a>;           /**&lt; Flags */</div><div id="4883" class="line none"> 4883 </div><div id="4884" class="line none"> 4884         SYS_PORT_TRACING_TRACKING_FIELD(<a href="kernel.h.html#4867">k_pipe</a>)</div><div id="4885" class="line none"> 4885 </div><div id="4886" class="line none"> 4886 #ifdef CONFIG_OBJ_CORE_PIPE</div><div id="4887" class="line none"> 4887         struct k_obj_core  <a href="kernel.h.html#1475">obj_core</a>;</div><div id="4888" class="line none"> 4888 #endif</div><div id="4889" class="line none"> 4889 };</div><div id="4890" class="line none"> 4890 </div><div id="4891" class="line none"> 4891 /**</div><div id="4892" class="line none"> 4892  * @cond INTERNAL_HIDDEN</div><div id="4893" class="line none"> 4893  */</div><div id="4894" class="line none"> 4894 #define <a href="kernel.h.html#4894">K_PIPE_FLAG_ALLOC</a>       BIT(0)  /** Buffer was allocated */</div><div id="4895" class="line none"> 4895 </div><div id="4896" class="line none"> 4896 #define <a href="kernel.h.html#4896">Z_PIPE_INITIALIZER</a>(<a href="kernel.h.html#5739">obj</a>, pipe_buffer, pipe_buffer_size)     \</div><div id="4897" class="line none"> 4897         {                                                           \</div><div id="4898" class="line none"> 4898         .<a href="kernel.h.html#4868">buffer</a> = pipe_buffer,                                      \</div><div id="4899" class="line none"> 4899         .<a href="kernel.h.html#4716">size</a> = pipe_buffer_size,                                   \</div><div id="4900" class="line none"> 4900         .<a href="kernel.h.html#4870">bytes_used</a> = 0,                                            \</div><div id="4901" class="line none"> 4901         .<a href="kernel.h.html#4871">read_index</a> = 0,                                            \</div><div id="4902" class="line none"> 4902         .<a href="kernel.h.html#4872">write_index</a> = 0,                                           \</div><div id="4903" class="line none"> 4903         .<a href="kernel.h.html#1852">lock</a> = {},                                                 \</div><div id="4904" class="line none"> 4904         .<a href="kernel.h.html#1455">wait_q</a> = {                                                 \</div><div id="4905" class="line none"> 4905                 .<a href="kernel.h.html#4876">readers</a> = <a href="kernel_structs.h.html#280">Z_WAIT_Q_INIT</a>(&amp;<a href="kernel.h.html#5739">obj</a>.<a href="kernel.h.html#1455">wait_q</a>.<a href="kernel.h.html#4876">readers</a>),       \</div><div id="4906" class="line none"> 4906                 .<a href="kernel.h.html#4877">writers</a> = <a href="kernel_structs.h.html#280">Z_WAIT_Q_INIT</a>(&amp;<a href="kernel.h.html#5739">obj</a>.<a href="kernel.h.html#1455">wait_q</a>.<a href="kernel.h.html#4877">writers</a>)        \</div><div id="4907" class="line none"> 4907         },                                                          \</div><div id="4908" class="line none"> 4908         <a href="kernel.h.html#63">Z_POLL_EVENT_OBJ_INIT</a>(<a href="kernel.h.html#5739">obj</a>)                                   \</div><div id="4909" class="line none"> 4909         .<a href="kernel.h.html#2764">flags</a> = 0,                                                 \</div><div id="4910" class="line none"> 4910         }</div><div id="4911" class="line none"> 4911 </div><div id="4912" class="line none"> 4912 /**</div><div id="4913" class="line none"> 4913  * INTERNAL_HIDDEN @endcond</div><div id="4914" class="line none"> 4914  */</div><div id="4915" class="line none"> 4915 </div><div id="4916" class="line none"> 4916 /**</div><div id="4917" class="line none"> 4917  * @brief Statically define and initialize a pipe.</div><div id="4918" class="line none"> 4918  *</div><div id="4919" class="line none"> 4919  * The pipe can be accessed outside the module where it is defined using:</div><div id="4920" class="line none"> 4920  *</div><div id="4921" class="line none"> 4921  * @code extern struct k_pipe &lt;name&gt;; @endcode</div><div id="4922" class="line none"> 4922  *</div><div id="4923" class="line none"> 4923  * @param name Name of the pipe.</div><div id="4924" class="line none"> 4924  * @param pipe_buffer_size Size of the pipe's ring buffer (in bytes),</div><div id="4925" class="line none"> 4925  *                         or zero if no ring buffer is used.</div><div id="4926" class="line none"> 4926  * @param pipe_align Alignment of the pipe's ring buffer (power of 2).</div><div id="4927" class="line none"> 4927  *</div><div id="4928" class="line none"> 4928  */</div><div id="4929" class="line none"> 4929 #define <a href="kernel.h.html#4929">K_PIPE_DEFINE</a>(<a href="kernel.h.html#4006">name</a>, pipe_buffer_size, pipe_align)               \</div><div id="4930" class="line none"> 4930         static unsigned char __noinit __aligned(pipe_align)             \</div><div id="4931" class="line none"> 4931                 _k_pipe_buf_##<a href="kernel.h.html#4006">name</a>[pipe_buffer_size];                   \</div><div id="4932" class="line none"> 4932         STRUCT_SECTION_ITERABLE(<a href="kernel.h.html#4867">k_pipe</a>, <a href="kernel.h.html#4006">name</a>) =                         \</div><div id="4933" class="line none"> 4933                 <a href="kernel.h.html#4896">Z_PIPE_INITIALIZER</a>(<a href="kernel.h.html#4006">name</a>, _k_pipe_buf_##<a href="kernel.h.html#4006">name</a>, pipe_buffer_size)</div><div id="4934" class="line none"> 4934 </div><div id="4935" class="line none"> 4935 /**</div><div id="4936" class="line none"> 4936  * @brief Initialize a pipe.</div><div id="4937" class="line none"> 4937  *</div><div id="4938" class="line none"> 4938  * This routine initializes a pipe object, prior to its first use.</div><div id="4939" class="line none"> 4939  *</div><div id="4940" class="line none"> 4940  * @param pipe Address of the pipe.</div><div id="4941" class="line none"> 4941  * @param buffer Address of the pipe's ring buffer, or NULL if no ring buffer</div><div id="4942" class="line none"> 4942  *               is used.</div><div id="4943" class="line none"> 4943  * @param size Size of the pipe's ring buffer (in bytes), or zero if no ring</div><div id="4944" class="line none"> 4944  *             buffer is used.</div><div id="4945" class="line none"> 4945  */</div><div id="4946" class="line none"> 4946 void k_pipe_init(struct <a href="kernel.h.html#4867">k_pipe</a> *<a href="kernel.h.html#5746">pipe</a>, unsigned char *<a href="kernel.h.html#4868">buffer</a>, size_t <a href="kernel.h.html#4716">size</a>);</div><div id="4947" class="line none"> 4947 </div><div id="4948" class="line none"> 4948 /**</div><div id="4949" class="line none"> 4949  * @brief Release a pipe's allocated buffer</div><div id="4950" class="line none"> 4950  *</div><div id="4951" class="line none"> 4951  * If a pipe object was given a dynamically allocated buffer via</div><div id="4952" class="line none"> 4952  * k_pipe_alloc_init(), this will free it. This function does nothing</div><div id="4953" class="line none"> 4953  * if the buffer wasn't dynamically allocated.</div><div id="4954" class="line none"> 4954  *</div><div id="4955" class="line none"> 4955  * @param pipe Address of the pipe.</div><div id="4956" class="line none"> 4956  * @retval 0 on success</div><div id="4957" class="line none"> 4957  * @retval -EAGAIN nothing to cleanup</div><div id="4958" class="line none"> 4958  */</div><div id="4959" class="line none"> 4959 int k_pipe_cleanup(struct <a href="kernel.h.html#4867">k_pipe</a> *<a href="kernel.h.html#5746">pipe</a>);</div><div id="4960" class="line none"> 4960 </div><div id="4961" class="line none"> 4961 /**</div><div id="4962" class="line none"> 4962  * @brief Initialize a pipe and allocate a buffer for it</div><div id="4963" class="line none"> 4963  *</div><div id="4964" class="line none"> 4964  * Storage for the buffer region will be allocated from the calling thread's</div><div id="4965" class="line none"> 4965  * resource pool. This memory will be released if k_pipe_cleanup() is called,</div><div id="4966" class="line none"> 4966  * or userspace is enabled and the pipe object loses all references to it.</div><div id="4967" class="line none"> 4967  *</div><div id="4968" class="line none"> 4968  * This function should only be called on uninitialized pipe objects.</div><div id="4969" class="line none"> 4969  *</div><div id="4970" class="line none"> 4970  * @param pipe Address of the pipe.</div><div id="4971" class="line none"> 4971  * @param size Size of the pipe's ring buffer (in bytes), or zero if no ring</div><div id="4972" class="line none"> 4972  *             buffer is used.</div><div id="4973" class="line none"> 4973  * @retval 0 on success</div><div id="4974" class="line none"> 4974  * @retval -ENOMEM if memory couldn't be allocated</div><div id="4975" class="line none"> 4975  */</div><div id="4976" class="line none"> 4976 __syscall int k_pipe_alloc_init(struct <a href="kernel.h.html#4867">k_pipe</a> *<a href="kernel.h.html#5746">pipe</a>, size_t <a href="kernel.h.html#4716">size</a>);</div><div id="4977" class="line none"> 4977 </div><div id="4978" class="line none"> 4978 /**</div><div id="4979" class="line none"> 4979  * @brief Write data to a pipe.</div><div id="4980" class="line none"> 4980  *</div><div id="4981" class="line none"> 4981  * This routine writes up to @a bytes_to_write bytes of data to @a pipe.</div><div id="4982" class="line none"> 4982  *</div><div id="4983" class="line none"> 4983  * @param pipe Address of the pipe.</div><div id="4984" class="line none"> 4984  * @param data Address of data to write.</div><div id="4985" class="line none"> 4985  * @param bytes_to_write Size of data (in bytes).</div><div id="4986" class="line none"> 4986  * @param bytes_written Address of area to hold the number of bytes written.</div><div id="4987" class="line none"> 4987  * @param min_xfer Minimum number of bytes to write.</div><div id="4988" class="line none"> 4988  * @param timeout Waiting period to wait for the data to be written,</div><div id="4989" class="line none"> 4989  *                or one of the special values K_NO_WAIT and K_FOREVER.</div><div id="4990" class="line none"> 4990  *</div><div id="4991" class="line none"> 4991  * @retval 0 At least @a min_xfer bytes of data were written.</div><div id="4992" class="line none"> 4992  * @retval -EIO Returned without waiting; zero data bytes were written.</div><div id="4993" class="line none"> 4993  * @retval -EAGAIN Waiting period timed out; between zero and @a min_xfer</div><div id="4994" class="line none"> 4994  *                 minus one data bytes were written.</div><div id="4995" class="line none"> 4995  */</div><div id="4996" class="line none"> 4996 __syscall int k_pipe_put(struct <a href="kernel.h.html#4867">k_pipe</a> *<a href="kernel.h.html#5746">pipe</a>, const void *<a href="logging/log_msg.h.html#100">data</a>,</div><div id="4997" class="line none"> 4997                          size_t bytes_to_write, size_t *bytes_written,</div><div id="4998" class="line none"> 4998                          size_t min_xfer, k_timeout_t <a href="kernel.h.html#1452">timeout</a>);</div><div id="4999" class="line none"> 4999 </div><div id="5000" class="line none"> 5000 /**</div><div id="5001" class="line none"> 5001  * @brief Read data from a pipe.</div><div id="5002" class="line none"> 5002  *</div><div id="5003" class="line none"> 5003  * This routine reads up to @a bytes_to_read bytes of data from @a pipe.</div><div id="5004" class="line none"> 5004  *</div><div id="5005" class="line none"> 5005  * @param pipe Address of the pipe.</div><div id="5006" class="line none"> 5006  * @param data Address to place the data read from pipe.</div><div id="5007" class="line none"> 5007  * @param bytes_to_read Maximum number of data bytes to read.</div><div id="5008" class="line none"> 5008  * @param bytes_read Address of area to hold the number of bytes read.</div><div id="5009" class="line none"> 5009  * @param min_xfer Minimum number of data bytes to read.</div><div id="5010" class="line none"> 5010  * @param timeout Waiting period to wait for the data to be read,</div><div id="5011" class="line none"> 5011  *                or one of the special values K_NO_WAIT and K_FOREVER.</div><div id="5012" class="line none"> 5012  *</div><div id="5013" class="line none"> 5013  * @retval 0 At least @a min_xfer bytes of data were read.</div><div id="5014" class="line none"> 5014  * @retval -EINVAL invalid parameters supplied</div><div id="5015" class="line none"> 5015  * @retval -EIO Returned without waiting; zero data bytes were read.</div><div id="5016" class="line none"> 5016  * @retval -EAGAIN Waiting period timed out; between zero and @a min_xfer</div><div id="5017" class="line none"> 5017  *                 minus one data bytes were read.</div><div id="5018" class="line none"> 5018  */</div><div id="5019" class="line none"> 5019 __syscall int k_pipe_get(struct <a href="kernel.h.html#4867">k_pipe</a> *<a href="kernel.h.html#5746">pipe</a>, void *<a href="logging/log_msg.h.html#100">data</a>,</div><div id="5020" class="line none"> 5020                          size_t bytes_to_read, size_t *bytes_read,</div><div id="5021" class="line none"> 5021                          size_t min_xfer, k_timeout_t <a href="kernel.h.html#1452">timeout</a>);</div><div id="5022" class="line none"> 5022 </div><div id="5023" class="line none"> 5023 /**</div><div id="5024" class="line none"> 5024  * @brief Query the number of bytes that may be read from @a pipe.</div><div id="5025" class="line none"> 5025  *</div><div id="5026" class="line none"> 5026  * @param pipe Address of the pipe.</div><div id="5027" class="line none"> 5027  *</div><div id="5028" class="line none"> 5028  * @retval a number n such that 0 &lt;= n &lt;= @ref k_pipe.size; the</div><div id="5029" class="line none"> 5029  *         result is zero for unbuffered pipes.</div><div id="5030" class="line none"> 5030  */</div><div id="5031" class="line none"> 5031 __syscall size_t k_pipe_read_avail(struct <a href="kernel.h.html#4867">k_pipe</a> *<a href="kernel.h.html#5746">pipe</a>);</div><div id="5032" class="line none"> 5032 </div><div id="5033" class="line none"> 5033 /**</div><div id="5034" class="line none"> 5034  * @brief Query the number of bytes that may be written to @a pipe</div><div id="5035" class="line none"> 5035  *</div><div id="5036" class="line none"> 5036  * @param pipe Address of the pipe.</div><div id="5037" class="line none"> 5037  *</div><div id="5038" class="line none"> 5038  * @retval a number n such that 0 &lt;= n &lt;= @ref k_pipe.size; the</div><div id="5039" class="line none"> 5039  *         result is zero for unbuffered pipes.</div><div id="5040" class="line none"> 5040  */</div><div id="5041" class="line none"> 5041 __syscall size_t k_pipe_write_avail(struct <a href="kernel.h.html#4867">k_pipe</a> *<a href="kernel.h.html#5746">pipe</a>);</div><div id="5042" class="line none"> 5042 </div><div id="5043" class="line none"> 5043 /**</div><div id="5044" class="line none"> 5044  * @brief Flush the pipe of write data</div><div id="5045" class="line none"> 5045  *</div><div id="5046" class="line none"> 5046  * This routine flushes the pipe. Flushing the pipe is equivalent to reading</div><div id="5047" class="line none"> 5047  * both all the data in the pipe's buffer and all the data waiting to go into</div><div id="5048" class="line none"> 5048  * that pipe into a large temporary buffer and discarding the buffer. Any</div><div id="5049" class="line none"> 5049  * writers that were previously pended become unpended.</div><div id="5050" class="line none"> 5050  *</div><div id="5051" class="line none"> 5051  * @param pipe Address of the pipe.</div><div id="5052" class="line none"> 5052  */</div><div id="5053" class="line none"> 5053 __syscall void k_pipe_flush(struct <a href="kernel.h.html#4867">k_pipe</a> *<a href="kernel.h.html#5746">pipe</a>);</div><div id="5054" class="line none"> 5054 </div><div id="5055" class="line none"> 5055 /**</div><div id="5056" class="line none"> 5056  * @brief Flush the pipe's internal buffer</div><div id="5057" class="line none"> 5057  *</div><div id="5058" class="line none"> 5058  * This routine flushes the pipe's internal buffer. This is equivalent to</div><div id="5059" class="line none"> 5059  * reading up to N bytes from the pipe (where N is the size of the pipe's</div><div id="5060" class="line none"> 5060  * buffer) into a temporary buffer and then discarding that buffer. If there</div><div id="5061" class="line none"> 5061  * were writers previously pending, then some may unpend as they try to fill</div><div id="5062" class="line none"> 5062  * up the pipe's emptied buffer.</div><div id="5063" class="line none"> 5063  *</div><div id="5064" class="line none"> 5064  * @param pipe Address of the pipe.</div><div id="5065" class="line none"> 5065  */</div><div id="5066" class="line none"> 5066 __syscall void k_pipe_buffer_flush(struct <a href="kernel.h.html#4867">k_pipe</a> *<a href="kernel.h.html#5746">pipe</a>);</div><div id="5067" class="line none"> 5067 </div><div id="5068" class="line none"> 5068 /** @} */</div><div id="5069" class="line none"> 5069 </div><div id="5070" class="line none"> 5070 /**</div><div id="5071" class="line none"> 5071  * @cond INTERNAL_HIDDEN</div><div id="5072" class="line none"> 5072  */</div><div id="5073" class="line none"> 5073 </div><div id="5074" class="line none"> 5074 struct <a href="kernel.h.html#5074">k_mem_slab_info</a> {</div><div id="5075" class="line none"> 5075         uint32_t <a href="kernel.h.html#5075">num_blocks</a>;</div><div id="5076" class="line none"> 5076         size_t   <a href="kernel.h.html#5076">block_size</a>;</div><div id="5077" class="line none"> 5077         uint32_t <a href="kernel.h.html#5077">num_used</a>;</div><div id="5078" class="line none"> 5078 #ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION</div><div id="5079" class="line none"> 5079         uint32_t <a href="kernel.h.html#5079">max_used</a>;</div><div id="5080" class="line none"> 5080 #endif</div><div id="5081" class="line none"> 5081 };</div><div id="5082" class="line none"> 5082 </div><div id="5083" class="line none"> 5083 struct <a href="kernel.h.html#5083">k_mem_slab</a> {</div><div id="5084" class="line none"> 5084         <a href="kernel_structs.h.html#286">_wait_q_t</a> <a href="kernel.h.html#1455">wait_q</a>;</div><div id="5085" class="line none"> 5085         struct <a href="spinlock.h.html#45">k_spinlock</a> <a href="kernel.h.html#1852">lock</a>;</div><div id="5086" class="line none"> 5086         char *<a href="kernel.h.html#4868">buffer</a>;</div><div id="5087" class="line none"> 5087         char *<a href="kernel.h.html#5087">free_list</a>;</div><div id="5088" class="line none"> 5088         struct <a href="kernel.h.html#5074">k_mem_slab_info</a> <a href="kernel.h.html#4718">info</a>;</div><div id="5089" class="line none"> 5089 </div><div id="5090" class="line none"> 5090         SYS_PORT_TRACING_TRACKING_FIELD(<a href="kernel.h.html#5083">k_mem_slab</a>)</div><div id="5091" class="line none"> 5091 </div><div id="5092" class="line none"> 5092 #ifdef CONFIG_OBJ_CORE_MEM_SLAB</div><div id="5093" class="line none"> 5093         struct k_obj_core  <a href="kernel.h.html#1475">obj_core</a>;</div><div id="5094" class="line none"> 5094 #endif</div><div id="5095" class="line none"> 5095 };</div><div id="5096" class="line none"> 5096 </div><div id="5097" class="line none"> 5097 #define <a href="kernel.h.html#5097">Z_MEM_SLAB_INITIALIZER</a>(_slab, _slab_buffer, _slab_block_size, \</div><div id="5098" class="line none"> 5098                                _slab_num_blocks)                      \</div><div id="5099" class="line none"> 5099         {                                                             \</div><div id="5100" class="line none"> 5100         .<a href="kernel.h.html#1455">wait_q</a> = <a href="kernel_structs.h.html#280">Z_WAIT_Q_INIT</a>(&amp;(_slab).<a href="kernel.h.html#1455">wait_q</a>),                     \</div><div id="5101" class="line none"> 5101         .<a href="kernel.h.html#1852">lock</a> = {},                                                   \</div><div id="5102" class="line none"> 5102         .<a href="kernel.h.html#4868">buffer</a> = _slab_buffer,                                       \</div><div id="5103" class="line none"> 5103         .<a href="kernel.h.html#5087">free_list</a> = NULL,                                            \</div><div id="5104" class="line none"> 5104         .<a href="kernel.h.html#4718">info</a> = {_slab_num_blocks, _slab_block_size, 0}               \</div><div id="5105" class="line none"> 5105         }</div><div id="5106" class="line none"> 5106 </div><div id="5107" class="line none"> 5107 </div><div id="5108" class="line none"> 5108 /**</div><div id="5109" class="line none"> 5109  * INTERNAL_HIDDEN @endcond</div><div id="5110" class="line none"> 5110  */</div><div id="5111" class="line none"> 5111 </div><div id="5112" class="line none"> 5112 /**</div><div id="5113" class="line none"> 5113  * @defgroup mem_slab_apis Memory Slab APIs</div><div id="5114" class="line none"> 5114  * @ingroup kernel_apis</div><div id="5115" class="line none"> 5115  * @{</div><div id="5116" class="line none"> 5116  */</div><div id="5117" class="line none"> 5117 </div><div id="5118" class="line none"> 5118 /**</div><div id="5119" class="line none"> 5119  * @brief Statically define and initialize a memory slab in a public (non-static) scope.</div><div id="5120" class="line none"> 5120  *</div><div id="5121" class="line none"> 5121  * The memory slab's buffer contains @a slab_num_blocks memory blocks</div><div id="5122" class="line none"> 5122  * that are @a slab_block_size bytes long. The buffer is aligned to a</div><div id="5123" class="line none"> 5123  * @a slab_align -byte boundary. To ensure that each memory block is similarly</div><div id="5124" class="line none"> 5124  * aligned to this boundary, @a slab_block_size must also be a multiple of</div><div id="5125" class="line none"> 5125  * @a slab_align.</div><div id="5126" class="line none"> 5126  *</div><div id="5127" class="line none"> 5127  * The memory slab can be accessed outside the module where it is defined</div><div id="5128" class="line none"> 5128  * using:</div><div id="5129" class="line none"> 5129  *</div><div id="5130" class="line none"> 5130  * @code extern struct k_mem_slab &lt;name&gt;; @endcode</div><div id="5131" class="line none"> 5131  *</div><div id="5132" class="line none"> 5132  * @note This macro cannot be used together with a static keyword.</div><div id="5133" class="line none"> 5133  *       If such a use-case is desired, use @ref K_MEM_SLAB_DEFINE_STATIC</div><div id="5134" class="line none"> 5134  *       instead.</div><div id="5135" class="line none"> 5135  *</div><div id="5136" class="line none"> 5136  * @param name Name of the memory slab.</div><div id="5137" class="line none"> 5137  * @param slab_block_size Size of each memory block (in bytes).</div><div id="5138" class="line none"> 5138  * @param slab_num_blocks Number memory blocks.</div><div id="5139" class="line none"> 5139  * @param slab_align Alignment of the memory slab's buffer (power of 2).</div><div id="5140" class="line none"> 5140  */</div><div id="5141" class="line none"> 5141 #define <a href="kernel.h.html#5141">K_MEM_SLAB_DEFINE</a>(<a href="kernel.h.html#4006">name</a>, slab_block_size, slab_num_blocks, slab_align) \</div><div id="5142" class="line none"> 5142         char __noinit_named(k_mem_slab_buf_##<a href="kernel.h.html#4006">name</a>) \</div><div id="5143" class="line none"> 5143            __aligned(WB_UP(slab_align)) \</div><div id="5144" class="line none"> 5144            _k_mem_slab_buf_##<a href="kernel.h.html#4006">name</a>[(slab_num_blocks) * WB_UP(slab_block_size)]; \</div><div id="5145" class="line none"> 5145         STRUCT_SECTION_ITERABLE(<a href="kernel.h.html#5083">k_mem_slab</a>, <a href="kernel.h.html#4006">name</a>) = \</div><div id="5146" class="line none"> 5146                 <a href="kernel.h.html#5097">Z_MEM_SLAB_INITIALIZER</a>(<a href="kernel.h.html#4006">name</a>, _k_mem_slab_buf_##<a href="kernel.h.html#4006">name</a>, \</div><div id="5147" class="line none"> 5147                                         WB_UP(slab_block_size), slab_num_blocks)</div><div id="5148" class="line none"> 5148 </div><div id="5149" class="line none"> 5149 /**</div><div id="5150" class="line none"> 5150  * @brief Statically define and initialize a memory slab in a private (static) scope.</div><div id="5151" class="line none"> 5151  *</div><div id="5152" class="line none"> 5152  * The memory slab's buffer contains @a slab_num_blocks memory blocks</div><div id="5153" class="line none"> 5153  * that are @a slab_block_size bytes long. The buffer is aligned to a</div><div id="5154" class="line none"> 5154  * @a slab_align -byte boundary. To ensure that each memory block is similarly</div><div id="5155" class="line none"> 5155  * aligned to this boundary, @a slab_block_size must also be a multiple of</div><div id="5156" class="line none"> 5156  * @a slab_align.</div><div id="5157" class="line none"> 5157  *</div><div id="5158" class="line none"> 5158  * @param name Name of the memory slab.</div><div id="5159" class="line none"> 5159  * @param slab_block_size Size of each memory block (in bytes).</div><div id="5160" class="line none"> 5160  * @param slab_num_blocks Number memory blocks.</div><div id="5161" class="line none"> 5161  * @param slab_align Alignment of the memory slab's buffer (power of 2).</div><div id="5162" class="line none"> 5162  */</div><div id="5163" class="line none"> 5163 #define <a href="kernel.h.html#5163">K_MEM_SLAB_DEFINE_STATIC</a>(<a href="kernel.h.html#4006">name</a>, slab_block_size, slab_num_blocks, slab_align) \</div><div id="5164" class="line none"> 5164         static char __noinit_named(k_mem_slab_buf_##<a href="kernel.h.html#4006">name</a>) \</div><div id="5165" class="line none"> 5165            __aligned(WB_UP(slab_align)) \</div><div id="5166" class="line none"> 5166            _k_mem_slab_buf_##<a href="kernel.h.html#4006">name</a>[(slab_num_blocks) * WB_UP(slab_block_size)]; \</div><div id="5167" class="line none"> 5167         static STRUCT_SECTION_ITERABLE(<a href="kernel.h.html#5083">k_mem_slab</a>, <a href="kernel.h.html#4006">name</a>) = \</div><div id="5168" class="line none"> 5168                 <a href="kernel.h.html#5097">Z_MEM_SLAB_INITIALIZER</a>(<a href="kernel.h.html#4006">name</a>, _k_mem_slab_buf_##<a href="kernel.h.html#4006">name</a>, \</div><div id="5169" class="line none"> 5169                                         WB_UP(slab_block_size), slab_num_blocks)</div><div id="5170" class="line none"> 5170 </div><div id="5171" class="line none"> 5171 /**</div><div id="5172" class="line none"> 5172  * @brief Initialize a memory slab.</div><div id="5173" class="line none"> 5173  *</div><div id="5174" class="line none"> 5174  * Initializes a memory slab, prior to its first use.</div><div id="5175" class="line none"> 5175  *</div><div id="5176" class="line none"> 5176  * The memory slab's buffer contains @a slab_num_blocks memory blocks</div><div id="5177" class="line none"> 5177  * that are @a slab_block_size bytes long. The buffer must be aligned to an</div><div id="5178" class="line none"> 5178  * N-byte boundary matching a word boundary, where N is a power of 2</div><div id="5179" class="line none"> 5179  * (i.e. 4 on 32-bit systems, 8, 16, ...).</div><div id="5180" class="line none"> 5180  * To ensure that each memory block is similarly aligned to this boundary,</div><div id="5181" class="line none"> 5181  * @a slab_block_size must also be a multiple of N.</div><div id="5182" class="line none"> 5182  *</div><div id="5183" class="line none"> 5183  * @param slab Address of the memory slab.</div><div id="5184" class="line none"> 5184  * @param buffer Pointer to buffer used for the memory blocks.</div><div id="5185" class="line none"> 5185  * @param block_size Size of each memory block (in bytes).</div><div id="5186" class="line none"> 5186  * @param num_blocks Number of memory blocks.</div><div id="5187" class="line none"> 5187  *</div><div id="5188" class="line none"> 5188  * @retval 0 on success</div><div id="5189" class="line none"> 5189  * @retval -EINVAL invalid data supplied</div><div id="5190" class="line none"> 5190  *</div><div id="5191" class="line none"> 5191  */</div><div id="5192" class="line none"> 5192 int k_mem_slab_init(struct <a href="kernel.h.html#5083">k_mem_slab</a> *slab, void *<a href="kernel.h.html#4868">buffer</a>,</div><div id="5193" class="line none"> 5193                            size_t <a href="kernel.h.html#5076">block_size</a>, uint32_t <a href="kernel.h.html#5075">num_blocks</a>);</div><div id="5194" class="line none"> 5194 </div><div id="5195" class="line none"> 5195 /**</div><div id="5196" class="line none"> 5196  * @brief Allocate memory from a memory slab.</div><div id="5197" class="line none"> 5197  *</div><div id="5198" class="line none"> 5198  * This routine allocates a memory block from a memory slab.</div><div id="5199" class="line none"> 5199  *</div><div id="5200" class="line none"> 5200  * @note @a timeout must be set to K_NO_WAIT if called from ISR.</div><div id="5201" class="line none"> 5201  * @note When CONFIG_MULTITHREADING=n any @a timeout is treated as K_NO_WAIT.</div><div id="5202" class="line none"> 5202  *</div><div id="5203" class="line none"> 5203  * @funcprops \isr_ok</div><div id="5204" class="line none"> 5204  *</div><div id="5205" class="line none"> 5205  * @param slab Address of the memory slab.</div><div id="5206" class="line none"> 5206  * @param mem Pointer to block address area.</div><div id="5207" class="line none"> 5207  * @param timeout Waiting period to wait for operation to complete.</div><div id="5208" class="line none"> 5208  *        Use K_NO_WAIT to return without waiting,</div><div id="5209" class="line none"> 5209  *        or K_FOREVER to wait as long as necessary.</div><div id="5210" class="line none"> 5210  *</div><div id="5211" class="line none"> 5211  * @retval 0 Memory allocated. The block address area pointed at by @a mem</div><div id="5212" class="line none"> 5212  *         is set to the starting address of the memory block.</div><div id="5213" class="line none"> 5213  * @retval -ENOMEM Returned without waiting.</div><div id="5214" class="line none"> 5214  * @retval -EAGAIN Waiting period timed out.</div><div id="5215" class="line none"> 5215  * @retval -EINVAL Invalid data supplied</div><div id="5216" class="line none"> 5216  */</div><div id="5217" class="line none"> 5217 int k_mem_slab_alloc(struct <a href="kernel.h.html#5083">k_mem_slab</a> *slab, void **mem,</div><div id="5218" class="line none"> 5218                             k_timeout_t <a href="kernel.h.html#1452">timeout</a>);</div><div id="5219" class="line none"> 5219 </div><div id="5220" class="line none"> 5220 /**</div><div id="5221" class="line none"> 5221  * @brief Free memory allocated from a memory slab.</div><div id="5222" class="line none"> 5222  *</div><div id="5223" class="line none"> 5223  * This routine releases a previously allocated memory block back to its</div><div id="5224" class="line none"> 5224  * associated memory slab.</div><div id="5225" class="line none"> 5225  *</div><div id="5226" class="line none"> 5226  * @param slab Address of the memory slab.</div><div id="5227" class="line none"> 5227  * @param mem Pointer to the memory block (as returned by k_mem_slab_alloc()).</div><div id="5228" class="line none"> 5228  */</div><div id="5229" class="line none"> 5229 void k_mem_slab_free(struct <a href="kernel.h.html#5083">k_mem_slab</a> *slab, void *mem);</div><div id="5230" class="line none"> 5230 </div><div id="5231" class="line none"> 5231 /**</div><div id="5232" class="line none"> 5232  * @brief Get the number of used blocks in a memory slab.</div><div id="5233" class="line none"> 5233  *</div><div id="5234" class="line none"> 5234  * This routine gets the number of memory blocks that are currently</div><div id="5235" class="line none"> 5235  * allocated in @a slab.</div><div id="5236" class="line none"> 5236  *</div><div id="5237" class="line none"> 5237  * @param slab Address of the memory slab.</div><div id="5238" class="line none"> 5238  *</div><div id="5239" class="line none"> 5239  * @return Number of allocated memory blocks.</div><div id="5240" class="line none"> 5240  */</div><div id="5241" class="line none"> 5241 static inline uint32_t <a href="kernel.h.html#5241">k_mem_slab_num_used_get</a>(struct <a href="kernel.h.html#5083">k_mem_slab</a> *slab)</div><div id="5242" class="line none"> 5242 {</div><div id="5243" class="line none"> 5243         return slab-&gt;<a href="kernel.h.html#4718">info</a>.<a href="kernel.h.html#5077">num_used</a>;</div><div id="5244" class="line none"> 5244 }</div><div id="5245" class="line none"> 5245 </div><div id="5246" class="line none"> 5246 /**</div><div id="5247" class="line none"> 5247  * @brief Get the number of maximum used blocks so far in a memory slab.</div><div id="5248" class="line none"> 5248  *</div><div id="5249" class="line none"> 5249  * This routine gets the maximum number of memory blocks that were</div><div id="5250" class="line none"> 5250  * allocated in @a slab.</div><div id="5251" class="line none"> 5251  *</div><div id="5252" class="line none"> 5252  * @param slab Address of the memory slab.</div><div id="5253" class="line none"> 5253  *</div><div id="5254" class="line none"> 5254  * @return Maximum number of allocated memory blocks.</div><div id="5255" class="line none"> 5255  */</div><div id="5256" class="line none"> 5256 static inline uint32_t <a href="kernel.h.html#5256">k_mem_slab_max_used_get</a>(struct <a href="kernel.h.html#5083">k_mem_slab</a> *slab)</div><div id="5257" class="line none"> 5257 {</div><div id="5258" class="line none"> 5258 #ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION</div><div id="5259" class="line none"> 5259         return slab-&gt;<a href="kernel.h.html#4718">info</a>.<a href="kernel.h.html#5079">max_used</a>;</div><div id="5260" class="line none"> 5260 #else</div><div id="5261" class="line none"> 5261         ARG_UNUSED(slab);</div><div id="5262" class="line none"> 5262         return 0;</div><div id="5263" class="line none"> 5263 #endif</div><div id="5264" class="line none"> 5264 }</div><div id="5265" class="line none"> 5265 </div><div id="5266" class="line none"> 5266 /**</div><div id="5267" class="line none"> 5267  * @brief Get the number of unused blocks in a memory slab.</div><div id="5268" class="line none"> 5268  *</div><div id="5269" class="line none"> 5269  * This routine gets the number of memory blocks that are currently</div><div id="5270" class="line none"> 5270  * unallocated in @a slab.</div><div id="5271" class="line none"> 5271  *</div><div id="5272" class="line none"> 5272  * @param slab Address of the memory slab.</div><div id="5273" class="line none"> 5273  *</div><div id="5274" class="line none"> 5274  * @return Number of unallocated memory blocks.</div><div id="5275" class="line none"> 5275  */</div><div id="5276" class="line none"> 5276 static inline uint32_t <a href="kernel.h.html#5276">k_mem_slab_num_free_get</a>(struct <a href="kernel.h.html#5083">k_mem_slab</a> *slab)</div><div id="5277" class="line none"> 5277 {</div><div id="5278" class="line none"> 5278         return slab-&gt;<a href="kernel.h.html#4718">info</a>.<a href="kernel.h.html#5075">num_blocks</a> - slab-&gt;<a href="kernel.h.html#4718">info</a>.<a href="kernel.h.html#5077">num_used</a>;</div><div id="5279" class="line none"> 5279 }</div><div id="5280" class="line none"> 5280 </div><div id="5281" class="line none"> 5281 /**</div><div id="5282" class="line none"> 5282  * @brief Get the memory stats for a memory slab</div><div id="5283" class="line none"> 5283  *</div><div id="5284" class="line none"> 5284  * This routine gets the runtime memory usage stats for the slab @a slab.</div><div id="5285" class="line none"> 5285  *</div><div id="5286" class="line none"> 5286  * @param slab Address of the memory slab</div><div id="5287" class="line none"> 5287  * @param stats Pointer to memory into which to copy memory usage statistics</div><div id="5288" class="line none"> 5288  *</div><div id="5289" class="line none"> 5289  * @retval 0 Success</div><div id="5290" class="line none"> 5290  * @retval -EINVAL Any parameter points to NULL</div><div id="5291" class="line none"> 5291  */</div><div id="5292" class="line none"> 5292 </div><div id="5293" class="line none"> 5293 int k_mem_slab_runtime_stats_get(struct <a href="kernel.h.html#5083">k_mem_slab</a> *slab, struct sys_memory_stats *stats);</div><div id="5294" class="line none"> 5294 </div><div id="5295" class="line none"> 5295 /**</div><div id="5296" class="line none"> 5296  * @brief Reset the maximum memory usage for a slab</div><div id="5297" class="line none"> 5297  *</div><div id="5298" class="line none"> 5298  * This routine resets the maximum memory usage for the slab @a slab to its</div><div id="5299" class="line none"> 5299  * current usage.</div><div id="5300" class="line none"> 5300  *</div><div id="5301" class="line none"> 5301  * @param slab Address of the memory slab</div><div id="5302" class="line none"> 5302  *</div><div id="5303" class="line none"> 5303  * @retval 0 Success</div><div id="5304" class="line none"> 5304  * @retval -EINVAL Memory slab is NULL</div><div id="5305" class="line none"> 5305  */</div><div id="5306" class="line none"> 5306 int k_mem_slab_runtime_stats_reset_max(struct <a href="kernel.h.html#5083">k_mem_slab</a> *slab);</div><div id="5307" class="line none"> 5307 </div><div id="5308" class="line none"> 5308 /** @} */</div><div id="5309" class="line none"> 5309 </div><div id="5310" class="line none"> 5310 /**</div><div id="5311" class="line none"> 5311  * @addtogroup heap_apis</div><div id="5312" class="line none"> 5312  * @{</div><div id="5313" class="line none"> 5313  */</div><div id="5314" class="line none"> 5314 </div><div id="5315" class="line none"> 5315 /* kernel synchronized heap struct */</div><div id="5316" class="line none"> 5316 </div><div id="5317" class="line none"> 5317 struct <a href="kernel/thread.h.html#349">k_heap</a> {</div><div id="5318" class="line none"> 5318         struct <a href="sys/sys_heap.h.html#56">sys_heap</a> <a href="kernel.h.html#5318">heap</a>;</div><div id="5319" class="line none"> 5319         <a href="kernel_structs.h.html#286">_wait_q_t</a> <a href="kernel.h.html#1455">wait_q</a>;</div><div id="5320" class="line none"> 5320         struct <a href="spinlock.h.html#45">k_spinlock</a> <a href="kernel.h.html#1852">lock</a>;</div><div id="5321" class="line none"> 5321 };</div><div id="5322" class="line none"> 5322 </div><div id="5323" class="line none"> 5323 /**</div><div id="5324" class="line none"> 5324  * @brief Initialize a k_heap</div><div id="5325" class="line none"> 5325  *</div><div id="5326" class="line none"> 5326  * This constructs a synchronized k_heap object over a memory region</div><div id="5327" class="line none"> 5327  * specified by the user.  Note that while any alignment and size can</div><div id="5328" class="line none"> 5328  * be passed as valid parameters, internal alignment restrictions</div><div id="5329" class="line none"> 5329  * inside the inner sys_heap mean that not all bytes may be usable as</div><div id="5330" class="line none"> 5330  * allocated memory.</div><div id="5331" class="line none"> 5331  *</div><div id="5332" class="line none"> 5332  * @param h Heap struct to initialize</div><div id="5333" class="line none"> 5333  * @param mem Pointer to memory.</div><div id="5334" class="line none"> 5334  * @param bytes Size of memory region, in bytes</div><div id="5335" class="line none"> 5335  */</div><div id="5336" class="line none"> 5336 void k_heap_init(struct <a href="kernel/thread.h.html#349">k_heap</a> *h, void *mem,</div><div id="5337" class="line none"> 5337                 size_t bytes) __attribute_nonnull(1);</div><div id="5338" class="line none"> 5338 </div><div id="5339" class="line none"> 5339 /**</div><div id="5340" class="line none"> 5340  * @brief Allocate aligned memory from a k_heap</div><div id="5341" class="line none"> 5341  *</div><div id="5342" class="line none"> 5342  * Behaves in all ways like k_heap_alloc(), except that the returned</div><div id="5343" class="line none"> 5343  * memory (if available) will have a starting address in memory which</div><div id="5344" class="line none"> 5344  * is a multiple of the specified power-of-two alignment value in</div><div id="5345" class="line none"> 5345  * bytes.  The resulting memory can be returned to the heap using</div><div id="5346" class="line none"> 5346  * k_heap_free().</div><div id="5347" class="line none"> 5347  *</div><div id="5348" class="line none"> 5348  * @note @a timeout must be set to K_NO_WAIT if called from ISR.</div><div id="5349" class="line none"> 5349  * @note When CONFIG_MULTITHREADING=n any @a timeout is treated as K_NO_WAIT.</div><div id="5350" class="line none"> 5350  *</div><div id="5351" class="line none"> 5351  * @funcprops \isr_ok</div><div id="5352" class="line none"> 5352  *</div><div id="5353" class="line none"> 5353  * @param h Heap from which to allocate</div><div id="5354" class="line none"> 5354  * @param align Alignment in bytes, must be a power of two</div><div id="5355" class="line none"> 5355  * @param bytes Number of bytes requested</div><div id="5356" class="line none"> 5356  * @param timeout How long to wait, or K_NO_WAIT</div><div id="5357" class="line none"> 5357  * @return Pointer to memory the caller can now use</div><div id="5358" class="line none"> 5358  */</div><div id="5359" class="line none"> 5359 void *k_heap_aligned_alloc(struct <a href="kernel/thread.h.html#349">k_heap</a> *h, size_t align, size_t bytes,</div><div id="5360" class="line none"> 5360                         k_timeout_t <a href="kernel.h.html#1452">timeout</a>) __attribute_nonnull(1);</div><div id="5361" class="line none"> 5361 </div><div id="5362" class="line none"> 5362 /**</div><div id="5363" class="line none"> 5363  * @brief Allocate memory from a k_heap</div><div id="5364" class="line none"> 5364  *</div><div id="5365" class="line none"> 5365  * Allocates and returns a memory buffer from the memory region owned</div><div id="5366" class="line none"> 5366  * by the heap.  If no memory is available immediately, the call will</div><div id="5367" class="line none"> 5367  * block for the specified timeout (constructed via the standard</div><div id="5368" class="line none"> 5368  * timeout API, or K_NO_WAIT or K_FOREVER) waiting for memory to be</div><div id="5369" class="line none"> 5369  * freed.  If the allocation cannot be performed by the expiration of</div><div id="5370" class="line none"> 5370  * the timeout, NULL will be returned.</div><div id="5371" class="line none"> 5371  * Allocated memory is aligned on a multiple of pointer sizes.</div><div id="5372" class="line none"> 5372  *</div><div id="5373" class="line none"> 5373  * @note @a timeout must be set to K_NO_WAIT if called from ISR.</div><div id="5374" class="line none"> 5374  * @note When CONFIG_MULTITHREADING=n any @a timeout is treated as K_NO_WAIT.</div><div id="5375" class="line none"> 5375  *</div><div id="5376" class="line none"> 5376  * @funcprops \isr_ok</div><div id="5377" class="line none"> 5377  *</div><div id="5378" class="line none"> 5378  * @param h Heap from which to allocate</div><div id="5379" class="line none"> 5379  * @param bytes Desired size of block to allocate</div><div id="5380" class="line none"> 5380  * @param timeout How long to wait, or K_NO_WAIT</div><div id="5381" class="line none"> 5381  * @return A pointer to valid heap memory, or NULL</div><div id="5382" class="line none"> 5382  */</div><div id="5383" class="line none"> 5383 void *k_heap_alloc(struct <a href="kernel/thread.h.html#349">k_heap</a> *h, size_t bytes,</div><div id="5384" class="line none"> 5384                 k_timeout_t <a href="kernel.h.html#1452">timeout</a>) __attribute_nonnull(1);</div><div id="5385" class="line none"> 5385 </div><div id="5386" class="line none"> 5386 /**</div><div id="5387" class="line none"> 5387  * @brief Reallocate memory from a k_heap</div><div id="5388" class="line none"> 5388  *</div><div id="5389" class="line none"> 5389  * Reallocates and returns a memory buffer from the memory region owned</div><div id="5390" class="line none"> 5390  * by the heap.  If no memory is available immediately, the call will</div><div id="5391" class="line none"> 5391  * block for the specified timeout (constructed via the standard</div><div id="5392" class="line none"> 5392  * timeout API, or K_NO_WAIT or K_FOREVER) waiting for memory to be</div><div id="5393" class="line none"> 5393  * freed.  If the allocation cannot be performed by the expiration of</div><div id="5394" class="line none"> 5394  * the timeout, NULL will be returned.</div><div id="5395" class="line none"> 5395  * Reallocated memory is aligned on a multiple of pointer sizes.</div><div id="5396" class="line none"> 5396  *</div><div id="5397" class="line none"> 5397  * @note @a timeout must be set to K_NO_WAIT if called from ISR.</div><div id="5398" class="line none"> 5398  * @note When CONFIG_MULTITHREADING=n any @a timeout is treated as K_NO_WAIT.</div><div id="5399" class="line none"> 5399  *</div><div id="5400" class="line none"> 5400  * @funcprops \isr_ok</div><div id="5401" class="line none"> 5401  *</div><div id="5402" class="line none"> 5402  * @param h Heap from which to allocate</div><div id="5403" class="line none"> 5403  * @param ptr Original pointer returned from a previous allocation</div><div id="5404" class="line none"> 5404  * @param bytes Desired size of block to allocate</div><div id="5405" class="line none"> 5405  * @param timeout How long to wait, or K_NO_WAIT</div><div id="5406" class="line none"> 5406  *</div><div id="5407" class="line none"> 5407  * @return Pointer to memory the caller can now use, or NULL</div><div id="5408" class="line none"> 5408  */</div><div id="5409" class="line none"> 5409 void *k_heap_realloc(struct <a href="kernel/thread.h.html#349">k_heap</a> *h, void *ptr, size_t bytes, k_timeout_t <a href="kernel.h.html#1452">timeout</a>)</div><div id="5410" class="line none"> 5410         __attribute_nonnull(1);</div><div id="5411" class="line none"> 5411 </div><div id="5412" class="line none"> 5412 /**</div><div id="5413" class="line none"> 5413  * @brief Free memory allocated by k_heap_alloc()</div><div id="5414" class="line none"> 5414  *</div><div id="5415" class="line none"> 5415  * Returns the specified memory block, which must have been returned</div><div id="5416" class="line none"> 5416  * from k_heap_alloc(), to the heap for use by other callers.  Passing</div><div id="5417" class="line none"> 5417  * a NULL block is legal, and has no effect.</div><div id="5418" class="line none"> 5418  *</div><div id="5419" class="line none"> 5419  * @param h Heap to which to return the memory</div><div id="5420" class="line none"> 5420  * @param mem A valid memory block, or NULL</div><div id="5421" class="line none"> 5421  */</div><div id="5422" class="line none"> 5422 void k_heap_free(struct <a href="kernel/thread.h.html#349">k_heap</a> *h, void *mem) __attribute_nonnull(1);</div><div id="5423" class="line none"> 5423 </div><div id="5424" class="line none"> 5424 /* Hand-calculated minimum heap sizes needed to return a successful</div><div id="5425" class="line none"> 5425  * 1-byte allocation.  See details in lib/os/heap.[ch]</div><div id="5426" class="line none"> 5426  */</div><div id="5427" class="line none"> 5427 #define <a href="kernel.h.html#5427">Z_HEAP_MIN_SIZE</a> ((sizeof(void *) &gt; 4) ? 56 : 44)</div><div id="5428" class="line none"> 5428 </div><div id="5429" class="line none"> 5429 /**</div><div id="5430" class="line none"> 5430  * @brief Define a static k_heap in the specified linker section</div><div id="5431" class="line none"> 5431  *</div><div id="5432" class="line none"> 5432  * This macro defines and initializes a static memory region and</div><div id="5433" class="line none"> 5433  * k_heap of the requested size in the specified linker section.</div><div id="5434" class="line none"> 5434  * After kernel start, &amp;name can be used as if k_heap_init() had</div><div id="5435" class="line none"> 5435  * been called.</div><div id="5436" class="line none"> 5436  *</div><div id="5437" class="line none"> 5437  * Note that this macro enforces a minimum size on the memory region</div><div id="5438" class="line none"> 5438  * to accommodate metadata requirements.  Very small heaps will be</div><div id="5439" class="line none"> 5439  * padded to fit.</div><div id="5440" class="line none"> 5440  *</div><div id="5441" class="line none"> 5441  * @param name Symbol name for the struct k_heap object</div><div id="5442" class="line none"> 5442  * @param bytes Size of memory region, in bytes</div><div id="5443" class="line none"> 5443  * @param in_section __attribute__((section(name))</div><div id="5444" class="line none"> 5444  */</div><div id="5445" class="line none"> 5445 #define <a href="kernel.h.html#5445">Z_HEAP_DEFINE_IN_SECT</a>(<a href="kernel.h.html#4006">name</a>, bytes, in_section)          \</div><div id="5446" class="line none"> 5446         char in_section                                         \</div><div id="5447" class="line none"> 5447              __aligned(8) /* CHUNK_UNIT */                      \</div><div id="5448" class="line none"> 5448              kheap_##<a href="kernel.h.html#4006">name</a>[MAX(bytes, <a href="kernel.h.html#5427">Z_HEAP_MIN_SIZE</a>)];         \</div><div id="5449" class="line none"> 5449         STRUCT_SECTION_ITERABLE(<a href="kernel/thread.h.html#349">k_heap</a>, <a href="kernel.h.html#4006">name</a>) = {               \</div><div id="5450" class="line none"> 5450                 .<a href="kernel.h.html#5318">heap</a> = {                                       \</div><div id="5451" class="line none"> 5451                         .<a href="sys/sys_heap.h.html#58">init_mem</a> = kheap_##<a href="kernel.h.html#4006">name</a>,               \</div><div id="5452" class="line none"> 5452                         .<a href="sys/sys_heap.h.html#59">init_bytes</a> = MAX(bytes, <a href="kernel.h.html#5427">Z_HEAP_MIN_SIZE</a>), \</div><div id="5453" class="line none"> 5453                  },                                             \</div><div id="5454" class="line none"> 5454         }</div><div id="5455" class="line none"> 5455 </div><div id="5456" class="line none"> 5456 /**</div><div id="5457" class="line none"> 5457  * @brief Define a static k_heap</div><div id="5458" class="line none"> 5458  *</div><div id="5459" class="line none"> 5459  * This macro defines and initializes a static memory region and</div><div id="5460" class="line none"> 5460  * k_heap of the requested size.  After kernel start, &amp;name can be</div><div id="5461" class="line none"> 5461  * used as if k_heap_init() had been called.</div><div id="5462" class="line none"> 5462  *</div><div id="5463" class="line none"> 5463  * Note that this macro enforces a minimum size on the memory region</div><div id="5464" class="line none"> 5464  * to accommodate metadata requirements.  Very small heaps will be</div><div id="5465" class="line none"> 5465  * padded to fit.</div><div id="5466" class="line none"> 5466  *</div><div id="5467" class="line none"> 5467  * @param name Symbol name for the struct k_heap object</div><div id="5468" class="line none"> 5468  * @param bytes Size of memory region, in bytes</div><div id="5469" class="line none"> 5469  */</div><div id="5470" class="line none"> 5470 #define <a href="kernel.h.html#5470">K_HEAP_DEFINE</a>(<a href="kernel.h.html#4006">name</a>, bytes)                              \</div><div id="5471" class="line none"> 5471         <a href="kernel.h.html#5445">Z_HEAP_DEFINE_IN_SECT</a>(<a href="kernel.h.html#4006">name</a>, bytes,                      \</div><div id="5472" class="line none"> 5472                               __noinit_named(kheap_buf_##<a href="kernel.h.html#4006">name</a>))</div><div id="5473" class="line none"> 5473 </div><div id="5474" class="line none"> 5474 /**</div><div id="5475" class="line none"> 5475  * @brief Define a static k_heap in uncached memory</div><div id="5476" class="line none"> 5476  *</div><div id="5477" class="line none"> 5477  * This macro defines and initializes a static memory region and</div><div id="5478" class="line none"> 5478  * k_heap of the requested size in uncached memory.  After kernel</div><div id="5479" class="line none"> 5479  * start, &amp;name can be used as if k_heap_init() had been called.</div><div id="5480" class="line none"> 5480  *</div><div id="5481" class="line none"> 5481  * Note that this macro enforces a minimum size on the memory region</div><div id="5482" class="line none"> 5482  * to accommodate metadata requirements.  Very small heaps will be</div><div id="5483" class="line none"> 5483  * padded to fit.</div><div id="5484" class="line none"> 5484  *</div><div id="5485" class="line none"> 5485  * @param name Symbol name for the struct k_heap object</div><div id="5486" class="line none"> 5486  * @param bytes Size of memory region, in bytes</div><div id="5487" class="line none"> 5487  */</div><div id="5488" class="line none"> 5488 #define <a href="kernel.h.html#5488">K_HEAP_DEFINE_NOCACHE</a>(<a href="kernel.h.html#4006">name</a>, bytes)                      \</div><div id="5489" class="line none"> 5489         <a href="kernel.h.html#5445">Z_HEAP_DEFINE_IN_SECT</a>(<a href="kernel.h.html#4006">name</a>, bytes, __nocache)</div><div id="5490" class="line none"> 5490 </div><div id="5491" class="line none"> 5491 /**</div><div id="5492" class="line none"> 5492  * @}</div><div id="5493" class="line none"> 5493  */</div><div id="5494" class="line none"> 5494 </div><div id="5495" class="line none"> 5495 /**</div><div id="5496" class="line none"> 5496  * @defgroup heap_apis Heap APIs</div><div id="5497" class="line none"> 5497  * @ingroup kernel_apis</div><div id="5498" class="line none"> 5498  * @{</div><div id="5499" class="line none"> 5499  */</div><div id="5500" class="line none"> 5500 </div><div id="5501" class="line none"> 5501 /**</div><div id="5502" class="line none"> 5502  * @brief Allocate memory from the heap with a specified alignment.</div><div id="5503" class="line none"> 5503  *</div><div id="5504" class="line none"> 5504  * This routine provides semantics similar to aligned_alloc(); memory is</div><div id="5505" class="line none"> 5505  * allocated from the heap with a specified alignment. However, one minor</div><div id="5506" class="line none"> 5506  * difference is that k_aligned_alloc() accepts any non-zero @p size,</div><div id="5507" class="line none"> 5507  * whereas aligned_alloc() only accepts a @p size that is an integral</div><div id="5508" class="line none"> 5508  * multiple of @p align.</div><div id="5509" class="line none"> 5509  *</div><div id="5510" class="line none"> 5510  * Above, aligned_alloc() refers to:</div><div id="5511" class="line none"> 5511  * C11 standard (ISO/IEC 9899:2011): 7.22.3.1</div><div id="5512" class="line none"> 5512  * The aligned_alloc function (p: 347-348)</div><div id="5513" class="line none"> 5513  *</div><div id="5514" class="line none"> 5514  * @param align Alignment of memory requested (in bytes).</div><div id="5515" class="line none"> 5515  * @param size Amount of memory requested (in bytes).</div><div id="5516" class="line none"> 5516  *</div><div id="5517" class="line none"> 5517  * @return Address of the allocated memory if successful; otherwise NULL.</div><div id="5518" class="line none"> 5518  */</div><div id="5519" class="line none"> 5519 void *k_aligned_alloc(size_t align, size_t <a href="kernel.h.html#4716">size</a>);</div><div id="5520" class="line none"> 5520 </div><div id="5521" class="line none"> 5521 /**</div><div id="5522" class="line none"> 5522  * @brief Allocate memory from the heap.</div><div id="5523" class="line none"> 5523  *</div><div id="5524" class="line none"> 5524  * This routine provides traditional malloc() semantics. Memory is</div><div id="5525" class="line none"> 5525  * allocated from the heap memory pool.</div><div id="5526" class="line none"> 5526  * Allocated memory is aligned on a multiple of pointer sizes.</div><div id="5527" class="line none"> 5527  *</div><div id="5528" class="line none"> 5528  * @param size Amount of memory requested (in bytes).</div><div id="5529" class="line none"> 5529  *</div><div id="5530" class="line none"> 5530  * @return Address of the allocated memory if successful; otherwise NULL.</div><div id="5531" class="line none"> 5531  */</div><div id="5532" class="line none"> 5532 void *k_malloc(size_t <a href="kernel.h.html#4716">size</a>);</div><div id="5533" class="line none"> 5533 </div><div id="5534" class="line none"> 5534 /**</div><div id="5535" class="line none"> 5535  * @brief Free memory allocated from heap.</div><div id="5536" class="line none"> 5536  *</div><div id="5537" class="line none"> 5537  * This routine provides traditional free() semantics. The memory being</div><div id="5538" class="line none"> 5538  * returned must have been allocated from the heap memory pool.</div><div id="5539" class="line none"> 5539  *</div><div id="5540" class="line none"> 5540  * If @a ptr is NULL, no operation is performed.</div><div id="5541" class="line none"> 5541  *</div><div id="5542" class="line none"> 5542  * @param ptr Pointer to previously allocated memory.</div><div id="5543" class="line none"> 5543  */</div><div id="5544" class="line none"> 5544 void k_free(void *ptr);</div><div id="5545" class="line none"> 5545 </div><div id="5546" class="line none"> 5546 /**</div><div id="5547" class="line none"> 5547  * @brief Allocate memory from heap, array style</div><div id="5548" class="line none"> 5548  *</div><div id="5549" class="line none"> 5549  * This routine provides traditional calloc() semantics. Memory is</div><div id="5550" class="line none"> 5550  * allocated from the heap memory pool and zeroed.</div><div id="5551" class="line none"> 5551  *</div><div id="5552" class="line none"> 5552  * @param nmemb Number of elements in the requested array</div><div id="5553" class="line none"> 5553  * @param size Size of each array element (in bytes).</div><div id="5554" class="line none"> 5554  *</div><div id="5555" class="line none"> 5555  * @return Address of the allocated memory if successful; otherwise NULL.</div><div id="5556" class="line none"> 5556  */</div><div id="5557" class="line none"> 5557 void *k_calloc(size_t nmemb, size_t <a href="kernel.h.html#4716">size</a>);</div><div id="5558" class="line none"> 5558 </div><div id="5559" class="line none"> 5559 /** @brief Expand the size of an existing allocation</div><div id="5560" class="line none"> 5560  *</div><div id="5561" class="line none"> 5561  * Returns a pointer to a new memory region with the same contents,</div><div id="5562" class="line none"> 5562  * but a different allocated size.  If the new allocation can be</div><div id="5563" class="line none"> 5563  * expanded in place, the pointer returned will be identical.</div><div id="5564" class="line none"> 5564  * Otherwise the data will be copies to a new block and the old one</div><div id="5565" class="line none"> 5565  * will be freed as per sys_heap_free().  If the specified size is</div><div id="5566" class="line none"> 5566  * smaller than the original, the block will be truncated in place and</div><div id="5567" class="line none"> 5567  * the remaining memory returned to the heap.  If the allocation of a</div><div id="5568" class="line none"> 5568  * new block fails, then NULL will be returned and the old block will</div><div id="5569" class="line none"> 5569  * not be freed or modified.</div><div id="5570" class="line none"> 5570  *</div><div id="5571" class="line none"> 5571  * @param ptr Original pointer returned from a previous allocation</div><div id="5572" class="line none"> 5572  * @param size Amount of memory requested (in bytes).</div><div id="5573" class="line none"> 5573  *</div><div id="5574" class="line none"> 5574  * @return Pointer to memory the caller can now use, or NULL.</div><div id="5575" class="line none"> 5575  */</div><div id="5576" class="line none"> 5576 void *k_realloc(void *ptr, size_t <a href="kernel.h.html#4716">size</a>);</div><div id="5577" class="line none"> 5577 </div><div id="5578" class="line none"> 5578 /** @} */</div><div id="5579" class="line none"> 5579 </div><div id="5580" class="line none"> 5580 /* polling API - PRIVATE */</div><div id="5581" class="line none"> 5581 </div><div id="5582" class="line none"> 5582 #ifdef CONFIG_POLL</div><div id="5583" class="line none"> 5583 #define <a href="kernel.h.html#5583">_INIT_OBJ_POLL_EVENT</a>(<a href="kernel.h.html#5739">obj</a>) do { (<a href="kernel.h.html#5739">obj</a>)-&gt;poll_event = NULL; } while (false)</div><div id="5584" class="line none"> 5584 #else</div><div id="5585" class="line none"> 5585 #define <a href="kernel.h.html#5583">_INIT_OBJ_POLL_EVENT</a>(<a href="kernel.h.html#5739">obj</a>) do { } while (false)</div><div id="5586" class="line none"> 5586 #endif</div><div id="5587" class="line none"> 5587 </div><div id="5588" class="line none"> 5588 /* private - types bit positions */</div><div id="5589" class="line none"> 5589 enum <a href="kernel.h.html#5589">_poll_types_bits</a> {</div><div id="5590" class="line none"> 5590         /* can be used to ignore an event */</div><div id="5591" class="line none"> 5591         <a href="kernel.h.html#5591">_POLL_TYPE_IGNORE</a>,</div><div id="5592" class="line none"> 5592 </div><div id="5593" class="line none"> 5593         /* to be signaled by k_poll_signal_raise() */</div><div id="5594" class="line none"> 5594         <a href="kernel.h.html#5594">_POLL_TYPE_SIGNAL</a>,</div><div id="5595" class="line none"> 5595 </div><div id="5596" class="line none"> 5596         /* semaphore availability */</div><div id="5597" class="line none"> 5597         <a href="kernel.h.html#5597">_POLL_TYPE_SEM_AVAILABLE</a>,</div><div id="5598" class="line none"> 5598 </div><div id="5599" class="line none"> 5599         /* queue/FIFO/LIFO data availability */</div><div id="5600" class="line none"> 5600         <a href="kernel.h.html#5600">_POLL_TYPE_DATA_AVAILABLE</a>,</div><div id="5601" class="line none"> 5601 </div><div id="5602" class="line none"> 5602         /* msgq data availability */</div><div id="5603" class="line none"> 5603         <a href="kernel.h.html#5603">_POLL_TYPE_MSGQ_DATA_AVAILABLE</a>,</div><div id="5604" class="line none"> 5604 </div><div id="5605" class="line none"> 5605         /* pipe data availability */</div><div id="5606" class="line none"> 5606         <a href="kernel.h.html#5606">_POLL_TYPE_PIPE_DATA_AVAILABLE</a>,</div><div id="5607" class="line none"> 5607 </div><div id="5608" class="line none"> 5608         <a href="kernel.h.html#5608">_POLL_NUM_TYPES</a></div><div id="5609" class="line none"> 5609 };</div><div id="5610" class="line none"> 5610 </div><div id="5611" class="line none"> 5611 #define <a href="kernel.h.html#5611">Z_POLL_TYPE_BIT</a>(<a href="kernel.h.html#5723">type</a>) (1U &lt;&lt; ((<a href="kernel.h.html#5723">type</a>) - 1U))</div><div id="5612" class="line none"> 5612 </div><div id="5613" class="line none"> 5613 /* private - states bit positions */</div><div id="5614" class="line none"> 5614 enum <a href="kernel.h.html#5614">_poll_states_bits</a> {</div><div id="5615" class="line none"> 5615         /* default state when creating event */</div><div id="5616" class="line none"> 5616         <a href="kernel.h.html#5616">_POLL_STATE_NOT_READY</a>,</div><div id="5617" class="line none"> 5617 </div><div id="5618" class="line none"> 5618         /* signaled by k_poll_signal_raise() */</div><div id="5619" class="line none"> 5619         <a href="kernel.h.html#5619">_POLL_STATE_SIGNALED</a>,</div><div id="5620" class="line none"> 5620 </div><div id="5621" class="line none"> 5621         /* semaphore is available */</div><div id="5622" class="line none"> 5622         <a href="kernel.h.html#5622">_POLL_STATE_SEM_AVAILABLE</a>,</div><div id="5623" class="line none"> 5623 </div><div id="5624" class="line none"> 5624         /* data is available to read on queue/FIFO/LIFO */</div><div id="5625" class="line none"> 5625         <a href="kernel.h.html#5625">_POLL_STATE_DATA_AVAILABLE</a>,</div><div id="5626" class="line none"> 5626 </div><div id="5627" class="line none"> 5627         /* queue/FIFO/LIFO wait was cancelled */</div><div id="5628" class="line none"> 5628         <a href="kernel.h.html#5628">_POLL_STATE_CANCELLED</a>,</div><div id="5629" class="line none"> 5629 </div><div id="5630" class="line none"> 5630         /* data is available to read on a message queue */</div><div id="5631" class="line none"> 5631         <a href="kernel.h.html#5631">_POLL_STATE_MSGQ_DATA_AVAILABLE</a>,</div><div id="5632" class="line none"> 5632 </div><div id="5633" class="line none"> 5633         /* data is available to read from a pipe */</div><div id="5634" class="line none"> 5634         <a href="kernel.h.html#5634">_POLL_STATE_PIPE_DATA_AVAILABLE</a>,</div><div id="5635" class="line none"> 5635 </div><div id="5636" class="line none"> 5636         <a href="kernel.h.html#5636">_POLL_NUM_STATES</a></div><div id="5637" class="line none"> 5637 };</div><div id="5638" class="line none"> 5638 </div><div id="5639" class="line none"> 5639 #define <a href="kernel.h.html#5639">Z_POLL_STATE_BIT</a>(<a href="kernel.h.html#5726">state</a>) (1U &lt;&lt; ((<a href="kernel.h.html#5726">state</a>) - 1U))</div><div id="5640" class="line none"> 5640 </div><div id="5641" class="line none"> 5641 #define <a href="kernel.h.html#5641">_POLL_EVENT_NUM_UNUSED_BITS</a> \</div><div id="5642" class="line none"> 5642         (32 - (0 \</div><div id="5643" class="line none"> 5643                + 8 /* tag */ \</div><div id="5644" class="line none"> 5644                + <a href="kernel.h.html#5608">_POLL_NUM_TYPES</a> \</div><div id="5645" class="line none"> 5645                + <a href="kernel.h.html#5636">_POLL_NUM_STATES</a> \</div><div id="5646" class="line none"> 5646                + 1 /* modes */ \</div><div id="5647" class="line none"> 5647               ))</div><div id="5648" class="line none"> 5648 </div><div id="5649" class="line none"> 5649 /* end of polling API - PRIVATE */</div><div id="5650" class="line none"> 5650 </div><div id="5651" class="line none"> 5651 </div><div id="5652" class="line none"> 5652 /**</div><div id="5653" class="line none"> 5653  * @defgroup poll_apis Async polling APIs</div><div id="5654" class="line none"> 5654  * @ingroup kernel_apis</div><div id="5655" class="line none"> 5655  * @{</div><div id="5656" class="line none"> 5656  */</div><div id="5657" class="line none"> 5657 </div><div id="5658" class="line none"> 5658 /* Public polling API */</div><div id="5659" class="line none"> 5659 </div><div id="5660" class="line none"> 5660 /* public - values for k_poll_event.type bitfield */</div><div id="5661" class="line none"> 5661 #define <a href="kernel.h.html#5661">K_POLL_TYPE_IGNORE</a> 0</div><div id="5662" class="line none"> 5662 #define <a href="kernel.h.html#5662">K_POLL_TYPE_SIGNAL</a> <a href="kernel.h.html#5611">Z_POLL_TYPE_BIT</a>(<a href="kernel.h.html#5594">_POLL_TYPE_SIGNAL</a>)</div><div id="5663" class="line none"> 5663 #define <a href="kernel.h.html#5663">K_POLL_TYPE_SEM_AVAILABLE</a> <a href="kernel.h.html#5611">Z_POLL_TYPE_BIT</a>(<a href="kernel.h.html#5597">_POLL_TYPE_SEM_AVAILABLE</a>)</div><div id="5664" class="line none"> 5664 #define <a href="kernel.h.html#5664">K_POLL_TYPE_DATA_AVAILABLE</a> <a href="kernel.h.html#5611">Z_POLL_TYPE_BIT</a>(<a href="kernel.h.html#5600">_POLL_TYPE_DATA_AVAILABLE</a>)</div><div id="5665" class="line none"> 5665 #define <a href="kernel.h.html#5665">K_POLL_TYPE_FIFO_DATA_AVAILABLE</a> <a href="kernel.h.html#5664">K_POLL_TYPE_DATA_AVAILABLE</a></div><div id="5666" class="line none"> 5666 #define <a href="kernel.h.html#5666">K_POLL_TYPE_MSGQ_DATA_AVAILABLE</a> <a href="kernel.h.html#5611">Z_POLL_TYPE_BIT</a>(<a href="kernel.h.html#5603">_POLL_TYPE_MSGQ_DATA_AVAILABLE</a>)</div><div id="5667" class="line none"> 5667 #define <a href="kernel.h.html#5667">K_POLL_TYPE_PIPE_DATA_AVAILABLE</a> <a href="kernel.h.html#5611">Z_POLL_TYPE_BIT</a>(<a href="kernel.h.html#5606">_POLL_TYPE_PIPE_DATA_AVAILABLE</a>)</div><div id="5668" class="line none"> 5668 </div><div id="5669" class="line none"> 5669 /* public - polling modes */</div><div id="5670" class="line none"> 5670 enum <a href="kernel.h.html#5670">k_poll_modes</a> {</div><div id="5671" class="line none"> 5671         /* polling thread does not take ownership of objects when available */</div><div id="5672" class="line none"> 5672         <a href="kernel.h.html#5672">K_POLL_MODE_NOTIFY_ONLY</a> = 0,</div><div id="5673" class="line none"> 5673 </div><div id="5674" class="line none"> 5674         <a href="kernel.h.html#5674">K_POLL_NUM_MODES</a></div><div id="5675" class="line none"> 5675 };</div><div id="5676" class="line none"> 5676 </div><div id="5677" class="line none"> 5677 /* public - values for k_poll_event.state bitfield */</div><div id="5678" class="line none"> 5678 #define <a href="kernel.h.html#5678">K_POLL_STATE_NOT_READY</a> 0</div><div id="5679" class="line none"> 5679 #define <a href="kernel.h.html#5679">K_POLL_STATE_SIGNALED</a> <a href="kernel.h.html#5639">Z_POLL_STATE_BIT</a>(<a href="kernel.h.html#5619">_POLL_STATE_SIGNALED</a>)</div><div id="5680" class="line none"> 5680 #define <a href="kernel.h.html#5680">K_POLL_STATE_SEM_AVAILABLE</a> <a href="kernel.h.html#5639">Z_POLL_STATE_BIT</a>(<a href="kernel.h.html#5622">_POLL_STATE_SEM_AVAILABLE</a>)</div><div id="5681" class="line none"> 5681 #define <a href="kernel.h.html#5681">K_POLL_STATE_DATA_AVAILABLE</a> <a href="kernel.h.html#5639">Z_POLL_STATE_BIT</a>(<a href="kernel.h.html#5625">_POLL_STATE_DATA_AVAILABLE</a>)</div><div id="5682" class="line none"> 5682 #define <a href="kernel.h.html#5682">K_POLL_STATE_FIFO_DATA_AVAILABLE</a> <a href="kernel.h.html#5681">K_POLL_STATE_DATA_AVAILABLE</a></div><div id="5683" class="line none"> 5683 #define <a href="kernel.h.html#5683">K_POLL_STATE_MSGQ_DATA_AVAILABLE</a> <a href="kernel.h.html#5639">Z_POLL_STATE_BIT</a>(<a href="kernel.h.html#5631">_POLL_STATE_MSGQ_DATA_AVAILABLE</a>)</div><div id="5684" class="line none"> 5684 #define <a href="kernel.h.html#5684">K_POLL_STATE_PIPE_DATA_AVAILABLE</a> <a href="kernel.h.html#5639">Z_POLL_STATE_BIT</a>(<a href="kernel.h.html#5634">_POLL_STATE_PIPE_DATA_AVAILABLE</a>)</div><div id="5685" class="line none"> 5685 #define <a href="kernel.h.html#5685">K_POLL_STATE_CANCELLED</a> <a href="kernel.h.html#5639">Z_POLL_STATE_BIT</a>(<a href="kernel.h.html#5628">_POLL_STATE_CANCELLED</a>)</div><div id="5686" class="line none"> 5686 </div><div id="5687" class="line none"> 5687 /* public - poll signal object */</div><div id="5688" class="line none"> 5688 struct <a href="kernel.h.html#5688">k_poll_signal</a> {</div><div id="5689" class="line none"> 5689         /** PRIVATE - DO NOT TOUCH */</div><div id="5690" class="line none"> 5690         <a href="sys/dlist.h.html#50">sys_dlist_t</a> <a href="kernel.h.html#5690">poll_events</a>;</div><div id="5691" class="line none"> 5691 </div><div id="5692" class="line none"> 5692         /**</div><div id="5693" class="line none"> 5693          * 1 if the event has been signaled, 0 otherwise. Stays set to 1 until</div><div id="5694" class="line none"> 5694          * user resets it to 0.</div><div id="5695" class="line none"> 5695          */</div><div id="5696" class="line none"> 5696         unsigned int <a href="kernel.h.html#5696">signaled</a>;</div><div id="5697" class="line none"> 5697 </div><div id="5698" class="line none"> 5698         /** custom result value passed to k_poll_signal_raise() if needed */</div><div id="5699" class="line none"> 5699         int <a href="kernel.h.html#5699">result</a>;</div><div id="5700" class="line none"> 5700 };</div><div id="5701" class="line none"> 5701 </div><div id="5702" class="line none"> 5702 #define <a href="kernel.h.html#5702">K_POLL_SIGNAL_INITIALIZER</a>(<a href="kernel.h.html#5739">obj</a>) \</div><div id="5703" class="line none"> 5703         { \</div><div id="5704" class="line none"> 5704         .<a href="kernel.h.html#5690">poll_events</a> = <a href="sys/dlist.h.html#211">SYS_DLIST_STATIC_INIT</a>(&amp;<a href="kernel.h.html#5739">obj</a>.<a href="kernel.h.html#5690">poll_events</a>), \</div><div id="5705" class="line none"> 5705         .<a href="kernel.h.html#5696">signaled</a> = 0, \</div><div id="5706" class="line none"> 5706         .<a href="kernel.h.html#5699">result</a> = 0, \</div><div id="5707" class="line none"> 5707         }</div><div id="5708" class="line none"> 5708 /**</div><div id="5709" class="line none"> 5709  * @brief Poll Event</div><div id="5710" class="line none"> 5710  *</div><div id="5711" class="line none"> 5711  */</div><div id="5712" class="line none"> 5712 struct <a href="kernel.h.html#5712">k_poll_event</a> {</div><div id="5713" class="line none"> 5713         /** PRIVATE - DO NOT TOUCH */</div><div id="5714" class="line none"> 5714         <a href="sys/dlist.h.html#54">sys_dnode_t</a> <a href="kernel.h.html#5714">_node</a>;</div><div id="5715" class="line none"> 5715 </div><div id="5716" class="line none"> 5716         /** PRIVATE - DO NOT TOUCH */</div><div id="5717" class="line none"> 5717         struct <a href="kernel/thread.h.html#250">z_poller</a> *<a href="kernel.h.html#4277">poller</a>;</div><div id="5718" class="line none"> 5718 </div><div id="5719" class="line none"> 5719         /** optional user-specified tag, opaque, untouched by the API */</div><div id="5720" class="line none"> 5720         uint32_t <a href="kernel.h.html#5720">tag</a>:8;</div><div id="5721" class="line none"> 5721 </div><div id="5722" class="line none"> 5722         /** bitfield of event types (bitwise-ORed K_POLL_TYPE_xxx values) */</div><div id="5723" class="line none"> 5723         uint32_t <a href="kernel.h.html#5723">type</a>:<a href="kernel.h.html#5608">_POLL_NUM_TYPES</a>;</div><div id="5724" class="line none"> 5724 </div><div id="5725" class="line none"> 5725         /** bitfield of event states (bitwise-ORed K_POLL_STATE_xxx values) */</div><div id="5726" class="line none"> 5726         uint32_t <a href="kernel.h.html#5726">state</a>:<a href="kernel.h.html#5636">_POLL_NUM_STATES</a>;</div><div id="5727" class="line none"> 5727 </div><div id="5728" class="line none"> 5728         /** mode of operation, from enum k_poll_modes */</div><div id="5729" class="line none"> 5729         uint32_t <a href="arch/arm/thread.h.html#118">mode</a>:1;</div><div id="5730" class="line none"> 5730 </div><div id="5731" class="line none"> 5731         /** unused bits in 32-bit word */</div><div id="5732" class="line none"> 5732         uint32_t <a href="kernel.h.html#5732">unused</a>:<a href="kernel.h.html#5641">_POLL_EVENT_NUM_UNUSED_BITS</a>;</div><div id="5733" class="line none"> 5733 </div><div id="5734" class="line none"> 5734         /** per-type data */</div><div id="5735" class="line none"> 5735         union {</div><div id="5736" class="line none"> 5736                 /* The typed_* fields below are used by K_POLL_EVENT_*INITIALIZER() macros to ensure</div><div id="5737" class="line none"> 5737                  * type safety of polled objects.</div><div id="5738" class="line none"> 5738                  */</div><div id="5739" class="line none"> 5739                 void *<a href="kernel.h.html#5739">obj</a>, *<a href="kernel.h.html#5739">typed_K_POLL_TYPE_IGNORE</a>;</div><div id="5740" class="line none"> 5740                 struct <a href="kernel.h.html#5688">k_poll_signal</a> *<a href="kernel.h.html#5740">signal</a>, *<a href="kernel.h.html#5740">typed_K_POLL_TYPE_SIGNAL</a>;</div><div id="5741" class="line none"> 5741                 struct <a href="kernel.h.html#3111">k_sem</a> *<a href="kernel.h.html#3956">sem</a>, *<a href="kernel.h.html#5741">typed_K_POLL_TYPE_SEM_AVAILABLE</a>;</div><div id="5742" class="line none"> 5742                 struct <a href="kernel.h.html#2388">k_fifo</a> *<a href="kernel.h.html#5742">fifo</a>, *<a href="kernel.h.html#5742">typed_K_POLL_TYPE_FIFO_DATA_AVAILABLE</a>;</div><div id="5743" class="line none"> 5743                 struct <a href="kernel.h.html#1850">k_queue</a> *<a href="kernel.h.html#3889">queue</a>, *<a href="kernel.h.html#5743">typed_K_POLL_TYPE_DATA_AVAILABLE</a>;</div><div id="5744" class="line none"> 5744                 struct <a href="kernel.h.html#4423">k_msgq</a> *<a href="kernel.h.html#5744">msgq</a>, *<a href="kernel.h.html#5744">typed_K_POLL_TYPE_MSGQ_DATA_AVAILABLE</a>;</div><div id="5745" class="line none"> 5745 #ifdef CONFIG_PIPES</div><div id="5746" class="line none"> 5746                 struct <a href="kernel.h.html#4867">k_pipe</a> *<a href="kernel.h.html#5746">pipe</a>, *<a href="kernel.h.html#5746">typed_K_POLL_TYPE_PIPE_DATA_AVAILABLE</a>;</div><div id="5747" class="line none"> 5747 #endif</div><div id="5748" class="line none"> 5748         };</div><div id="5749" class="line none"> 5749 };</div><div id="5750" class="line none"> 5750 </div><div id="5751" class="line none"> 5751 #define <a href="kernel.h.html#5751">K_POLL_EVENT_INITIALIZER</a>(_event_type, _event_mode, _event_obj) \</div><div id="5752" class="line none"> 5752         { \</div><div id="5753" class="line none"> 5753         .<a href="kernel.h.html#4277">poller</a> = NULL, \</div><div id="5754" class="line none"> 5754         .<a href="kernel.h.html#5723">type</a> = _event_type, \</div><div id="5755" class="line none"> 5755         .<a href="kernel.h.html#5726">state</a> = <a href="kernel.h.html#5678">K_POLL_STATE_NOT_READY</a>, \</div><div id="5756" class="line none"> 5756         .<a href="arch/arm/thread.h.html#118">mode</a> = _event_mode, \</div><div id="5757" class="line none"> 5757         .<a href="kernel.h.html#5732">unused</a> = 0, \</div><div id="5758" class="line none"> 5758         { \</div><div id="5759" class="line none"> 5759                 .typed_##_event_type = _event_obj, \</div><div id="5760" class="line none"> 5760         }, \</div><div id="5761" class="line none"> 5761         }</div><div id="5762" class="line none"> 5762 </div><div id="5763" class="line none"> 5763 #define <a href="kernel.h.html#5763">K_POLL_EVENT_STATIC_INITIALIZER</a>(_event_type, _event_mode, _event_obj, \</div><div id="5764" class="line none"> 5764                                         event_tag) \</div><div id="5765" class="line none"> 5765         { \</div><div id="5766" class="line none"> 5766         .<a href="kernel.h.html#5720">tag</a> = event_tag, \</div><div id="5767" class="line none"> 5767         .<a href="kernel.h.html#5723">type</a> = _event_type, \</div><div id="5768" class="line none"> 5768         .<a href="kernel.h.html#5726">state</a> = <a href="kernel.h.html#5678">K_POLL_STATE_NOT_READY</a>, \</div><div id="5769" class="line none"> 5769         .<a href="arch/arm/thread.h.html#118">mode</a> = _event_mode, \</div><div id="5770" class="line none"> 5770         .<a href="kernel.h.html#5732">unused</a> = 0, \</div><div id="5771" class="line none"> 5771         { \</div><div id="5772" class="line none"> 5772                 .typed_##_event_type = _event_obj, \</div><div id="5773" class="line none"> 5773         }, \</div><div id="5774" class="line none"> 5774         }</div><div id="5775" class="line none"> 5775 </div><div id="5776" class="line none"> 5776 /**</div><div id="5777" class="line none"> 5777  * @brief Initialize one struct k_poll_event instance</div><div id="5778" class="line none"> 5778  *</div><div id="5779" class="line none"> 5779  * After this routine is called on a poll event, the event it ready to be</div><div id="5780" class="line none"> 5780  * placed in an event array to be passed to k_poll().</div><div id="5781" class="line none"> 5781  *</div><div id="5782" class="line none"> 5782  * @param event The event to initialize.</div><div id="5783" class="line none"> 5783  * @param type A bitfield of the types of event, from the K_POLL_TYPE_xxx</div><div id="5784" class="line none"> 5784  *             values. Only values that apply to the same object being polled</div><div id="5785" class="line none"> 5785  *             can be used together. Choosing K_POLL_TYPE_IGNORE disables the</div><div id="5786" class="line none"> 5786  *             event.</div><div id="5787" class="line none"> 5787  * @param mode Future. Use K_POLL_MODE_NOTIFY_ONLY.</div><div id="5788" class="line none"> 5788  * @param obj Kernel object or poll signal.</div><div id="5789" class="line none"> 5789  */</div><div id="5790" class="line none"> 5790 </div><div id="5791" class="line none"> 5791 void k_poll_event_init(struct <a href="kernel.h.html#5712">k_poll_event</a> *event, uint32_t <a href="kernel.h.html#5723">type</a>,</div><div id="5792" class="line none"> 5792                               int <a href="arch/arm/thread.h.html#118">mode</a>, void *<a href="kernel.h.html#5739">obj</a>);</div><div id="5793" class="line none"> 5793 </div><div id="5794" class="line none"> 5794 /**</div><div id="5795" class="line none"> 5795  * @brief Wait for one or many of multiple poll events to occur</div><div id="5796" class="line none"> 5796  *</div><div id="5797" class="line none"> 5797  * This routine allows a thread to wait concurrently for one or many of</div><div id="5798" class="line none"> 5798  * multiple poll events to have occurred. Such events can be a kernel object</div><div id="5799" class="line none"> 5799  * being available, like a semaphore, or a poll signal event.</div><div id="5800" class="line none"> 5800  *</div><div id="5801" class="line none"> 5801  * When an event notifies that a kernel object is available, the kernel object</div><div id="5802" class="line none"> 5802  * is not "given" to the thread calling k_poll(): it merely signals the fact</div><div id="5803" class="line none"> 5803  * that the object was available when the k_poll() call was in effect. Also,</div><div id="5804" class="line none"> 5804  * all threads trying to acquire an object the regular way, i.e. by pending on</div><div id="5805" class="line none"> 5805  * the object, have precedence over the thread polling on the object. This</div><div id="5806" class="line none"> 5806  * means that the polling thread will never get the poll event on an object</div><div id="5807" class="line none"> 5807  * until the object becomes available and its pend queue is empty. For this</div><div id="5808" class="line none"> 5808  * reason, the k_poll() call is more effective when the objects being polled</div><div id="5809" class="line none"> 5809  * only have one thread, the polling thread, trying to acquire them.</div><div id="5810" class="line none"> 5810  *</div><div id="5811" class="line none"> 5811  * When k_poll() returns 0, the caller should loop on all the events that were</div><div id="5812" class="line none"> 5812  * passed to k_poll() and check the state field for the values that were</div><div id="5813" class="line none"> 5813  * expected and take the associated actions.</div><div id="5814" class="line none"> 5814  *</div><div id="5815" class="line none"> 5815  * Before being reused for another call to k_poll(), the user has to reset the</div><div id="5816" class="line none"> 5816  * state field to K_POLL_STATE_NOT_READY.</div><div id="5817" class="line none"> 5817  *</div><div id="5818" class="line none"> 5818  * When called from user mode, a temporary memory allocation is required from</div><div id="5819" class="line none"> 5819  * the caller's resource pool.</div><div id="5820" class="line none"> 5820  *</div><div id="5821" class="line none"> 5821  * @param events An array of events to be polled for.</div><div id="5822" class="line none"> 5822  * @param num_events The number of events in the array.</div><div id="5823" class="line none"> 5823  * @param timeout Waiting period for an event to be ready,</div><div id="5824" class="line none"> 5824  *                or one of the special values K_NO_WAIT and K_FOREVER.</div><div id="5825" class="line none"> 5825  *</div><div id="5826" class="line none"> 5826  * @retval 0 One or more events are ready.</div><div id="5827" class="line none"> 5827  * @retval -EAGAIN Waiting period timed out.</div><div id="5828" class="line none"> 5828  * @retval -EINTR Polling has been interrupted, e.g. with</div><div id="5829" class="line none"> 5829  *         k_queue_cancel_wait(). All output events are still set and valid,</div><div id="5830" class="line none"> 5830  *         cancelled event(s) will be set to K_POLL_STATE_CANCELLED. In other</div><div id="5831" class="line none"> 5831  *         words, -EINTR status means that at least one of output events is</div><div id="5832" class="line none"> 5832  *         K_POLL_STATE_CANCELLED.</div><div id="5833" class="line none"> 5833  * @retval -ENOMEM Thread resource pool insufficient memory (user mode only)</div><div id="5834" class="line none"> 5834  * @retval -EINVAL Bad parameters (user mode only)</div><div id="5835" class="line none"> 5835  */</div><div id="5836" class="line none"> 5836 </div><div id="5837" class="line none"> 5837 __syscall int k_poll(struct <a href="kernel.h.html#5712">k_poll_event</a> *<a href="kernel.h.html#2223">events</a>, int <a href="kernel.h.html#4279">num_events</a>,</div><div id="5838" class="line none"> 5838                      k_timeout_t <a href="kernel.h.html#1452">timeout</a>);</div><div id="5839" class="line none"> 5839 </div><div id="5840" class="line none"> 5840 /**</div><div id="5841" class="line none"> 5841  * @brief Initialize a poll signal object.</div><div id="5842" class="line none"> 5842  *</div><div id="5843" class="line none"> 5843  * Ready a poll signal object to be signaled via k_poll_signal_raise().</div><div id="5844" class="line none"> 5844  *</div><div id="5845" class="line none"> 5845  * @param sig A poll signal.</div><div id="5846" class="line none"> 5846  */</div><div id="5847" class="line none"> 5847 </div><div id="5848" class="line none"> 5848 __syscall void k_poll_signal_init(struct <a href="kernel.h.html#5688">k_poll_signal</a> *sig);</div><div id="5849" class="line none"> 5849 </div><div id="5850" class="line none"> 5850 /**</div><div id="5851" class="line none"> 5851  * @brief Reset a poll signal object's state to unsignaled.</div><div id="5852" class="line none"> 5852  *</div><div id="5853" class="line none"> 5853  * @param sig A poll signal object</div><div id="5854" class="line none"> 5854  */</div><div id="5855" class="line none"> 5855 __syscall void k_poll_signal_reset(struct <a href="kernel.h.html#5688">k_poll_signal</a> *sig);</div><div id="5856" class="line none"> 5856 </div><div id="5857" class="line none"> 5857 /**</div><div id="5858" class="line none"> 5858  * @brief Fetch the signaled state and result value of a poll signal</div><div id="5859" class="line none"> 5859  *</div><div id="5860" class="line none"> 5860  * @param sig A poll signal object</div><div id="5861" class="line none"> 5861  * @param signaled An integer buffer which will be written nonzero if the</div><div id="5862" class="line none"> 5862  *                 object was signaled</div><div id="5863" class="line none"> 5863  * @param result An integer destination buffer which will be written with the</div><div id="5864" class="line none"> 5864  *                 result value if the object was signaled, or an undefined</div><div id="5865" class="line none"> 5865  *                 value if it was not.</div><div id="5866" class="line none"> 5866  */</div><div id="5867" class="line none"> 5867 __syscall void k_poll_signal_check(struct <a href="kernel.h.html#5688">k_poll_signal</a> *sig,</div><div id="5868" class="line none"> 5868                                    unsigned int *<a href="kernel.h.html#5696">signaled</a>, int *<a href="kernel.h.html#5699">result</a>);</div><div id="5869" class="line none"> 5869 </div><div id="5870" class="line none"> 5870 /**</div><div id="5871" class="line none"> 5871  * @brief Signal a poll signal object.</div><div id="5872" class="line none"> 5872  *</div><div id="5873" class="line none"> 5873  * This routine makes ready a poll signal, which is basically a poll event of</div><div id="5874" class="line none"> 5874  * type K_POLL_TYPE_SIGNAL. If a thread was polling on that event, it will be</div><div id="5875" class="line none"> 5875  * made ready to run. A @a result value can be specified.</div><div id="5876" class="line none"> 5876  *</div><div id="5877" class="line none"> 5877  * The poll signal contains a 'signaled' field that, when set by</div><div id="5878" class="line none"> 5878  * k_poll_signal_raise(), stays set until the user sets it back to 0 with</div><div id="5879" class="line none"> 5879  * k_poll_signal_reset(). It thus has to be reset by the user before being</div><div id="5880" class="line none"> 5880  * passed again to k_poll() or k_poll() will consider it being signaled, and</div><div id="5881" class="line none"> 5881  * will return immediately.</div><div id="5882" class="line none"> 5882  *</div><div id="5883" class="line none"> 5883  * @note The result is stored and the 'signaled' field is set even if</div><div id="5884" class="line none"> 5884  * this function returns an error indicating that an expiring poll was</div><div id="5885" class="line none"> 5885  * not notified.  The next k_poll() will detect the missed raise.</div><div id="5886" class="line none"> 5886  *</div><div id="5887" class="line none"> 5887  * @param sig A poll signal.</div><div id="5888" class="line none"> 5888  * @param result The value to store in the result field of the signal.</div><div id="5889" class="line none"> 5889  *</div><div id="5890" class="line none"> 5890  * @retval 0 The signal was delivered successfully.</div><div id="5891" class="line none"> 5891  * @retval -EAGAIN The polling thread's timeout is in the process of expiring.</div><div id="5892" class="line none"> 5892  */</div><div id="5893" class="line none"> 5893 </div><div id="5894" class="line none"> 5894 __syscall int k_poll_signal_raise(struct <a href="kernel.h.html#5688">k_poll_signal</a> *sig, int <a href="kernel.h.html#5699">result</a>);</div><div id="5895" class="line none"> 5895 </div><div id="5896" class="line none"> 5896 /** @} */</div><div id="5897" class="line none"> 5897 </div><div id="5898" class="line none"> 5898 /**</div><div id="5899" class="line none"> 5899  * @defgroup cpu_idle_apis CPU Idling APIs</div><div id="5900" class="line none"> 5900  * @ingroup kernel_apis</div><div id="5901" class="line none"> 5901  * @{</div><div id="5902" class="line none"> 5902  */</div><div id="5903" class="line none"> 5903 /**</div><div id="5904" class="line none"> 5904  * @brief Make the CPU idle.</div><div id="5905" class="line none"> 5905  *</div><div id="5906" class="line none"> 5906  * This function makes the CPU idle until an event wakes it up.</div><div id="5907" class="line none"> 5907  *</div><div id="5908" class="line none"> 5908  * In a regular system, the idle thread should be the only thread responsible</div><div id="5909" class="line none"> 5909  * for making the CPU idle and triggering any type of power management.</div><div id="5910" class="line none"> 5910  * However, in some more constrained systems, such as a single-threaded system,</div><div id="5911" class="line none"> 5911  * the only thread would be responsible for this if needed.</div><div id="5912" class="line none"> 5912  *</div><div id="5913" class="line none"> 5913  * @note In some architectures, before returning, the function unmasks interrupts</div><div id="5914" class="line none"> 5914  * unconditionally.</div><div id="5915" class="line none"> 5915  */</div><div id="5916" class="line none"> 5916 static inline void <a href="kernel.h.html#5916">k_cpu_idle</a>(void)</div><div id="5917" class="line none"> 5917 {</div><div id="5918" class="line none"> 5918         arch_cpu_idle();</div><div id="5919" class="line none"> 5919 }</div><div id="5920" class="line none"> 5920 </div><div id="5921" class="line none"> 5921 /**</div><div id="5922" class="line none"> 5922  * @brief Make the CPU idle in an atomic fashion.</div><div id="5923" class="line none"> 5923  *</div><div id="5924" class="line none"> 5924  * Similar to k_cpu_idle(), but must be called with interrupts locked.</div><div id="5925" class="line none"> 5925  *</div><div id="5926" class="line none"> 5926  * Enabling interrupts and entering a low-power mode will be atomic,</div><div id="5927" class="line none"> 5927  * i.e. there will be no period of time where interrupts are enabled before</div><div id="5928" class="line none"> 5928  * the processor enters a low-power mode.</div><div id="5929" class="line none"> 5929  *</div><div id="5930" class="line none"> 5930  * After waking up from the low-power mode, the interrupt lockout state will</div><div id="5931" class="line none"> 5931  * be restored as if by irq_unlock(key).</div><div id="5932" class="line none"> 5932  *</div><div id="5933" class="line none"> 5933  * @param key Interrupt locking key obtained from irq_lock().</div><div id="5934" class="line none"> 5934  */</div><div id="5935" class="line none"> 5935 static inline void <a href="kernel.h.html#5935">k_cpu_atomic_idle</a>(unsigned int <a href="spinlock.h.html#35">key</a>)</div><div id="5936" class="line none"> 5936 {</div><div id="5937" class="line none"> 5937         arch_cpu_atomic_idle(<a href="spinlock.h.html#35">key</a>);</div><div id="5938" class="line none"> 5938 }</div><div id="5939" class="line none"> 5939 </div><div id="5940" class="line none"> 5940 /**</div><div id="5941" class="line none"> 5941  * @}</div><div id="5942" class="line none"> 5942  */</div><div id="5943" class="line none"> 5943 </div><div id="5944" class="line none"> 5944 /**</div><div id="5945" class="line none"> 5945  * @cond INTERNAL_HIDDEN</div><div id="5946" class="line none"> 5946  * @internal</div><div id="5947" class="line none"> 5947  */</div><div id="5948" class="line none"> 5948 #ifdef ARCH_EXCEPT</div><div id="5949" class="line none"> 5949 /* This architecture has direct support for triggering a CPU exception */</div><div id="5950" class="line none"> 5950 #define <a href="kernel.h.html#5950">z_except_reason</a>(reason) ARCH_EXCEPT(reason)</div><div id="5951" class="line none"> 5951 #else</div><div id="5952" class="line none"> 5952 </div><div id="5953" class="line none"> 5953 #if !defined(CONFIG_ASSERT_NO_FILE_INFO)</div><div id="5954" class="line none"> 5954 #define <a href="kernel.h.html#5954">__EXCEPT_LOC</a>() __ASSERT_PRINT("@ %s:%d\n", __FILE__, __LINE__)</div><div id="5955" class="line none"> 5955 #else</div><div id="5956" class="line none"> 5956 #define <a href="kernel.h.html#5954">__EXCEPT_LOC</a>()</div><div id="5957" class="line none"> 5957 #endif</div><div id="5958" class="line none"> 5958 </div><div id="5959" class="line none"> 5959 /* NOTE: This is the implementation for arches that do not implement</div><div id="5960" class="line none"> 5960  * ARCH_EXCEPT() to generate a real CPU exception.</div><div id="5961" class="line none"> 5961  *</div><div id="5962" class="line none"> 5962  * We won't have a real exception frame to determine the PC value when</div><div id="5963" class="line none"> 5963  * the oops occurred, so print file and line number before we jump into</div><div id="5964" class="line none"> 5964  * the fatal error handler.</div><div id="5965" class="line none"> 5965  */</div><div id="5966" class="line none"> 5966 #define <a href="kernel.h.html#5950">z_except_reason</a>(reason) do { \</div><div id="5967" class="line none"> 5967                 <a href="kernel.h.html#5954">__EXCEPT_LOC</a>();              \</div><div id="5968" class="line none"> 5968                 z_fatal_error(reason, NULL); \</div><div id="5969" class="line none"> 5969         } while (false)</div><div id="5970" class="line none"> 5970 </div><div id="5971" class="line none"> 5971 #endif /* _ARCH__EXCEPT */</div><div id="5972" class="line none"> 5972 /**</div><div id="5973" class="line none"> 5973  * INTERNAL_HIDDEN @endcond</div><div id="5974" class="line none"> 5974  */</div><div id="5975" class="line none"> 5975 </div><div id="5976" class="line none"> 5976 /**</div><div id="5977" class="line none"> 5977  * @brief Fatally terminate a thread</div><div id="5978" class="line none"> 5978  *</div><div id="5979" class="line none"> 5979  * This should be called when a thread has encountered an unrecoverable</div><div id="5980" class="line none"> 5980  * runtime condition and needs to terminate. What this ultimately</div><div id="5981" class="line none"> 5981  * means is determined by the _fatal_error_handler() implementation, which</div><div id="5982" class="line none"> 5982  * will be called will reason code K_ERR_KERNEL_OOPS.</div><div id="5983" class="line none"> 5983  *</div><div id="5984" class="line none"> 5984  * If this is called from ISR context, the default system fatal error handler</div><div id="5985" class="line none"> 5985  * will treat it as an unrecoverable system error, just like k_panic().</div><div id="5986" class="line none"> 5986  */</div><div id="5987" class="line none"> 5987 #define <a href="kernel.h.html#5987">k_oops</a>()        <a href="kernel.h.html#5950">z_except_reason</a>(K_ERR_KERNEL_OOPS)</div><div id="5988" class="line none"> 5988 </div><div id="5989" class="line none"> 5989 /**</div><div id="5990" class="line none"> 5990  * @brief Fatally terminate the system</div><div id="5991" class="line none"> 5991  *</div><div id="5992" class="line none"> 5992  * This should be called when the Zephyr kernel has encountered an</div><div id="5993" class="line none"> 5993  * unrecoverable runtime condition and needs to terminate. What this ultimately</div><div id="5994" class="line none"> 5994  * means is determined by the _fatal_error_handler() implementation, which</div><div id="5995" class="line none"> 5995  * will be called will reason code K_ERR_KERNEL_PANIC.</div><div id="5996" class="line none"> 5996  */</div><div id="5997" class="line none"> 5997 #define <a href="kernel.h.html#5997">k_panic</a>()       <a href="kernel.h.html#5950">z_except_reason</a>(K_ERR_KERNEL_PANIC)</div><div id="5998" class="line none"> 5998 </div><div id="5999" class="line none"> 5999 /**</div><div id="6000" class="line none"> 6000  * @cond INTERNAL_HIDDEN</div><div id="6001" class="line none"> 6001  */</div><div id="6002" class="line none"> 6002 </div><div id="6003" class="line none"> 6003 /*</div><div id="6004" class="line none"> 6004  * private APIs that are utilized by one or more public APIs</div><div id="6005" class="line none"> 6005  */</div><div id="6006" class="line none"> 6006 </div><div id="6007" class="line none"> 6007 /**</div><div id="6008" class="line none"> 6008  * @internal</div><div id="6009" class="line none"> 6009  */</div><div id="6010" class="line none"> 6010 void z_timer_expiration_handler(struct <a href="kernel_structs.h.html#293">_timeout</a> *<a href="kernel.h.html#1452">timeout</a>);</div><div id="6011" class="line none"> 6011 /**</div><div id="6012" class="line none"> 6012  * INTERNAL_HIDDEN @endcond</div><div id="6013" class="line none"> 6013  */</div><div id="6014" class="line none"> 6014 </div><div id="6015" class="line none"> 6015 #ifdef CONFIG_PRINTK</div><div id="6016" class="line none"> 6016 /**</div><div id="6017" class="line none"> 6017  * @brief Emit a character buffer to the console device</div><div id="6018" class="line none"> 6018  *</div><div id="6019" class="line none"> 6019  * @param c String of characters to print</div><div id="6020" class="line none"> 6020  * @param n The length of the string</div><div id="6021" class="line none"> 6021  *</div><div id="6022" class="line none"> 6022  */</div><div id="6023" class="line none"> 6023 __syscall void k_str_out(char *c, size_t n);</div><div id="6024" class="line none"> 6024 #endif</div><div id="6025" class="line none"> 6025 </div><div id="6026" class="line none"> 6026 /**</div><div id="6027" class="line none"> 6027  * @defgroup float_apis Floating Point APIs</div><div id="6028" class="line none"> 6028  * @ingroup kernel_apis</div><div id="6029" class="line none"> 6029  * @{</div><div id="6030" class="line none"> 6030  */</div><div id="6031" class="line none"> 6031 </div><div id="6032" class="line none"> 6032 /**</div><div id="6033" class="line none"> 6033  * @brief Disable preservation of floating point context information.</div><div id="6034" class="line none"> 6034  *</div><div id="6035" class="line none"> 6035  * This routine informs the kernel that the specified thread</div><div id="6036" class="line none"> 6036  * will no longer be using the floating point registers.</div><div id="6037" class="line none"> 6037  *</div><div id="6038" class="line none"> 6038  * @warning</div><div id="6039" class="line none"> 6039  * Some architectures apply restrictions on how the disabling of floating</div><div id="6040" class="line none"> 6040  * point preservation may be requested, see arch_float_disable.</div><div id="6041" class="line none"> 6041  *</div><div id="6042" class="line none"> 6042  * @warning</div><div id="6043" class="line none"> 6043  * This routine should only be used to disable floating point support for</div><div id="6044" class="line none"> 6044  * a thread that currently has such support enabled.</div><div id="6045" class="line none"> 6045  *</div><div id="6046" class="line none"> 6046  * @param thread ID of thread.</div><div id="6047" class="line none"> 6047  *</div><div id="6048" class="line none"> 6048  * @retval 0        On success.</div><div id="6049" class="line none"> 6049  * @retval -ENOTSUP If the floating point disabling is not implemented.</div><div id="6050" class="line none"> 6050  *         -EINVAL  If the floating point disabling could not be performed.</div><div id="6051" class="line none"> 6051  */</div><div id="6052" class="line none"> 6052 __syscall int k_float_disable(struct <a href="arch/arch_interface.h.html#43">k_thread</a> *<a href="kernel.h.html#4031">thread</a>);</div><div id="6053" class="line none"> 6053 </div><div id="6054" class="line none"> 6054 /**</div><div id="6055" class="line none"> 6055  * @brief Enable preservation of floating point context information.</div><div id="6056" class="line none"> 6056  *</div><div id="6057" class="line none"> 6057  * This routine informs the kernel that the specified thread</div><div id="6058" class="line none"> 6058  * will use the floating point registers.</div><div id="6059" class="line none"> 6059 </div><div id="6060" class="line none"> 6060  * Invoking this routine initializes the thread's floating point context info</div><div id="6061" class="line none"> 6061  * to that of an FPU that has been reset. The next time the thread is scheduled</div><div id="6062" class="line none"> 6062  * by z_swap() it will either inherit an FPU that is guaranteed to be in a</div><div id="6063" class="line none"> 6063  * "sane" state (if the most recent user of the FPU was cooperatively swapped</div><div id="6064" class="line none"> 6064  * out) or the thread's own floating point context will be loaded (if the most</div><div id="6065" class="line none"> 6065  * recent user of the FPU was preempted, or if this thread is the first user</div><div id="6066" class="line none"> 6066  * of the FPU). Thereafter, the kernel will protect the thread's FP context</div><div id="6067" class="line none"> 6067  * so that it is not altered during a preemptive context switch.</div><div id="6068" class="line none"> 6068  *</div><div id="6069" class="line none"> 6069  * The @a options parameter indicates which floating point register sets will</div><div id="6070" class="line none"> 6070  * be used by the specified thread.</div><div id="6071" class="line none"> 6071  *</div><div id="6072" class="line none"> 6072  * For x86 options:</div><div id="6073" class="line none"> 6073  *</div><div id="6074" class="line none"> 6074  * - K_FP_REGS  indicates x87 FPU and MMX registers only</div><div id="6075" class="line none"> 6075  * - K_SSE_REGS indicates SSE registers (and also x87 FPU and MMX registers)</div><div id="6076" class="line none"> 6076  *</div><div id="6077" class="line none"> 6077  * @warning</div><div id="6078" class="line none"> 6078  * Some architectures apply restrictions on how the enabling of floating</div><div id="6079" class="line none"> 6079  * point preservation may be requested, see arch_float_enable.</div><div id="6080" class="line none"> 6080  *</div><div id="6081" class="line none"> 6081  * @warning</div><div id="6082" class="line none"> 6082  * This routine should only be used to enable floating point support for</div><div id="6083" class="line none"> 6083  * a thread that currently has such support enabled.</div><div id="6084" class="line none"> 6084  *</div><div id="6085" class="line none"> 6085  * @param thread  ID of thread.</div><div id="6086" class="line none"> 6086  * @param options architecture dependent options</div><div id="6087" class="line none"> 6087  *</div><div id="6088" class="line none"> 6088  * @retval 0        On success.</div><div id="6089" class="line none"> 6089  * @retval -ENOTSUP If the floating point enabling is not implemented.</div><div id="6090" class="line none"> 6090  *         -EINVAL  If the floating point enabling could not be performed.</div><div id="6091" class="line none"> 6091  */</div><div id="6092" class="line none"> 6092 __syscall int k_float_enable(struct <a href="arch/arch_interface.h.html#43">k_thread</a> *<a href="kernel.h.html#4031">thread</a>, unsigned int options);</div><div id="6093" class="line none"> 6093 </div><div id="6094" class="line none"> 6094 /**</div><div id="6095" class="line none"> 6095  * @}</div><div id="6096" class="line none"> 6096  */</div><div id="6097" class="line none"> 6097 </div><div id="6098" class="line none"> 6098 /**</div><div id="6099" class="line none"> 6099  * @brief Get the runtime statistics of a thread</div><div id="6100" class="line none"> 6100  *</div><div id="6101" class="line none"> 6101  * @param thread ID of thread.</div><div id="6102" class="line none"> 6102  * @param stats Pointer to struct to copy statistics into.</div><div id="6103" class="line none"> 6103  * @return -EINVAL if null pointers, otherwise 0</div><div id="6104" class="line none"> 6104  */</div><div id="6105" class="line none"> 6105 int k_thread_runtime_stats_get(<a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4031">thread</a>,</div><div id="6106" class="line none"> 6106                                <a href="kernel/thread.h.html#248">k_thread_runtime_stats_t</a> *stats);</div><div id="6107" class="line none"> 6107 </div><div id="6108" class="line none"> 6108 /**</div><div id="6109" class="line none"> 6109  * @brief Get the runtime statistics of all threads</div><div id="6110" class="line none"> 6110  *</div><div id="6111" class="line none"> 6111  * @param stats Pointer to struct to copy statistics into.</div><div id="6112" class="line none"> 6112  * @return -EINVAL if null pointers, otherwise 0</div><div id="6113" class="line none"> 6113  */</div><div id="6114" class="line none"> 6114 int k_thread_runtime_stats_all_get(<a href="kernel/thread.h.html#248">k_thread_runtime_stats_t</a> *stats);</div><div id="6115" class="line none"> 6115 </div><div id="6116" class="line none"> 6116 /**</div><div id="6117" class="line none"> 6117  * @brief Enable gathering of runtime statistics for specified thread</div><div id="6118" class="line none"> 6118  *</div><div id="6119" class="line none"> 6119  * This routine enables the gathering of runtime statistics for the specified</div><div id="6120" class="line none"> 6120  * thread.</div><div id="6121" class="line none"> 6121  *</div><div id="6122" class="line none"> 6122  * @param thread ID of thread</div><div id="6123" class="line none"> 6123  * @return -EINVAL if invalid thread ID, otherwise 0</div><div id="6124" class="line none"> 6124  */</div><div id="6125" class="line none"> 6125 int k_thread_runtime_stats_enable(<a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4031">thread</a>);</div><div id="6126" class="line none"> 6126 </div><div id="6127" class="line none"> 6127 /**</div><div id="6128" class="line none"> 6128  * @brief Disable gathering of runtime statistics for specified thread</div><div id="6129" class="line none"> 6129  *</div><div id="6130" class="line none"> 6130  * This routine disables the gathering of runtime statistics for the specified</div><div id="6131" class="line none"> 6131  * thread.</div><div id="6132" class="line none"> 6132  *</div><div id="6133" class="line none"> 6133  * @param thread ID of thread</div><div id="6134" class="line none"> 6134  * @return -EINVAL if invalid thread ID, otherwise 0</div><div id="6135" class="line none"> 6135  */</div><div id="6136" class="line none"> 6136 int k_thread_runtime_stats_disable(<a href="kernel/thread.h.html#380">k_tid_t</a> <a href="kernel.h.html#4031">thread</a>);</div><div id="6137" class="line none"> 6137 </div><div id="6138" class="line none"> 6138 /**</div><div id="6139" class="line none"> 6139  * @brief Enable gathering of system runtime statistics</div><div id="6140" class="line none"> 6140  *</div><div id="6141" class="line none"> 6141  * This routine enables the gathering of system runtime statistics. Note that</div><div id="6142" class="line none"> 6142  * it does not affect the gathering of similar statistics for individual</div><div id="6143" class="line none"> 6143  * threads.</div><div id="6144" class="line none"> 6144  */</div><div id="6145" class="line none"> 6145 void k_sys_runtime_stats_enable(void);</div><div id="6146" class="line none"> 6146 </div><div id="6147" class="line none"> 6147 /**</div><div id="6148" class="line none"> 6148  * @brief Disable gathering of system runtime statistics</div><div id="6149" class="line none"> 6149  *</div><div id="6150" class="line none"> 6150  * This routine disables the gathering of system runtime statistics. Note that</div><div id="6151" class="line none"> 6151  * it does not affect the gathering of similar statistics for individual</div><div id="6152" class="line none"> 6152  * threads.</div><div id="6153" class="line none"> 6153  */</div><div id="6154" class="line none"> 6154 void k_sys_runtime_stats_disable(void);</div><div id="6155" class="line none"> 6155 </div><div id="6156" class="line none"> 6156 #ifdef __cplusplus</div><div id="6157" class="line none"> 6157 }</div><div id="6158" class="line none"> 6158 #endif</div><div id="6159" class="line none"> 6159 </div><div id="6160" class="line none"> 6160 #include &lt;zephyr/tracing/tracing.h&gt;</div><div id="6161" class="line none"> 6161 #include &lt;zephyr/syscalls/kernel.h&gt;</div><div id="6162" class="line none"> 6162 </div><div id="6163" class="line none"> 6163 #endif /* !_ASMLANGUAGE */</div><div id="6164" class="line none"> 6164 </div><div id="6165" class="line none"> 6165 #endif /* ZEPHYR_INCLUDE_KERNEL_H_ */</div>
</div>
</body>
</html>
