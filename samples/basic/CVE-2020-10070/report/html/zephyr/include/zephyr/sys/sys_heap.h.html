
<html>
<head>
<title>zephyr/include/zephyr/sys/sys_heap.h</title>
<link rel="stylesheet" type="text/css" href="../../../../viewer.css">
</head>

<body>
<div class="code">
<div id="1" class="line none">    1 /*</div><div id="2" class="line none">    2  * Copyright (c) 2019 Intel Corporation</div><div id="3" class="line none">    3  *</div><div id="4" class="line none">    4  * SPDX-License-Identifier: Apache-2.0</div><div id="5" class="line none">    5  */</div><div id="6" class="line none">    6 #ifndef <a href="sys_heap.h.html#7">ZEPHYR_INCLUDE_SYS_SYS_HEAP_H_</a></div><div id="7" class="line none">    7 #define <a href="sys_heap.h.html#7">ZEPHYR_INCLUDE_SYS_SYS_HEAP_H_</a></div><div id="8" class="line none">    8 </div><div id="9" class="line none">    9 #include &lt;stddef.h&gt;</div><div id="10" class="line none">   10 #include &lt;stdbool.h&gt;</div><div id="11" class="line none">   11 #include &lt;zephyr/types.h&gt;</div><div id="12" class="line none">   12 #include &lt;zephyr/sys/mem_stats.h&gt;</div><div id="13" class="line none">   13 </div><div id="14" class="line none">   14 #ifdef __cplusplus</div><div id="15" class="line none">   15 extern "C" {</div><div id="16" class="line none">   16 #endif</div><div id="17" class="line none">   17 </div><div id="18" class="line none">   18 /* Simple, fast heap implementation.</div><div id="19" class="line none">   19  *</div><div id="20" class="line none">   20  * A more or less conventional segregated fit allocator with</div><div id="21" class="line none">   21  * power-of-two buckets.</div><div id="22" class="line none">   22  *</div><div id="23" class="line none">   23  * Excellent space efficiency.  Chunks can be split arbitrarily in 8</div><div id="24" class="line none">   24  * byte units.  Overhead is only four bytes per allocated chunk (eight</div><div id="25" class="line none">   25  * bytes for heaps &gt;256kb or on 64 bit systems), plus a log2-sized</div><div id="26" class="line none">   26  * array of 2-word bucket headers.  No coarse alignment restrictions</div><div id="27" class="line none">   27  * on blocks, they can be split and merged (in units of 8 bytes)</div><div id="28" class="line none">   28  * arbitrarily.</div><div id="29" class="line none">   29  *</div><div id="30" class="line none">   30  * Simple API.  Initialize at runtime with any blob of memory and not</div><div id="31" class="line none">   31  * a macro-generated, carefully aligned static array.  Allocate and</div><div id="32" class="line none">   32  * free by user pointer and not an opaque block handle.</div><div id="33" class="line none">   33  *</div><div id="34" class="line none">   34  * Good fragmentation resistance.  Freed blocks are always immediately</div><div id="35" class="line none">   35  * merged with adjacent free blocks.  Allocations are attempted from a</div><div id="36" class="line none">   36  * sample of the smallest bucket that might fit, falling back rapidly</div><div id="37" class="line none">   37  * to the smallest block guaranteed to fit.  Split memory remaining in</div><div id="38" class="line none">   38  * the chunk is always returned immediately to the heap for other</div><div id="39" class="line none">   39  * allocation.</div><div id="40" class="line none">   40  *</div><div id="41" class="line none">   41  * Excellent performance with firmly bounded runtime.  All operations</div><div id="42" class="line none">   42  * are constant time (though there is a search of the smallest bucket</div><div id="43" class="line none">   43  * that has a compile-time-configurable upper bound, setting this to</div><div id="44" class="line none">   44  * extreme values results in an effectively linear search of the</div><div id="45" class="line none">   45  * list), objectively fast (~hundred instructions) and amenable to</div><div id="46" class="line none">   46  * locked operation.</div><div id="47" class="line none">   47  */</div><div id="48" class="line none">   48 </div><div id="49" class="line none">   49 /* Note: the init_mem/bytes fields are for the static initializer to</div><div id="50" class="line none">   50  * have somewhere to put the arguments.  The actual heap metadata at</div><div id="51" class="line none">   51  * runtime lives in the heap memory itself and this struct simply</div><div id="52" class="line none">   52  * functions as an opaque pointer.  Would be good to clean this up and</div><div id="53" class="line none">   53  * put the two values somewhere else, though it would make</div><div id="54" class="line none">   54  * SYS_HEAP_DEFINE a little hairy to write.</div><div id="55" class="line none">   55  */</div><div id="56" class="line none">   56 struct <a href="sys_heap.h.html#56">sys_heap</a> {</div><div id="57" class="line none">   57         struct <a href="sys_heap.h.html#57">z_heap</a> *<a href="../kernel.h.html#5318">heap</a>;</div><div id="58" class="line none">   58         void *<a href="sys_heap.h.html#58">init_mem</a>;</div><div id="59" class="line none">   59         size_t <a href="sys_heap.h.html#59">init_bytes</a>;</div><div id="60" class="line none">   60 };</div><div id="61" class="line none">   61 </div><div id="62" class="line none">   62 struct <a href="sys_heap.h.html#62">z_heap_stress_result</a> {</div><div id="63" class="line none">   63         uint32_t <a href="sys_heap.h.html#63">total_allocs</a>;</div><div id="64" class="line none">   64         uint32_t <a href="sys_heap.h.html#64">successful_allocs</a>;</div><div id="65" class="line none">   65         uint32_t <a href="sys_heap.h.html#65">total_frees</a>;</div><div id="66" class="line none">   66         uint64_t <a href="sys_heap.h.html#66">accumulated_in_use_bytes</a>;</div><div id="67" class="line none">   67 };</div><div id="68" class="line none">   68 </div><div id="69" class="line none">   69 /**</div><div id="70" class="line none">   70  * @defgroup low_level_heap_allocator Low Level Heap Allocator</div><div id="71" class="line none">   71  * @ingroup heaps</div><div id="72" class="line none">   72  * @{</div><div id="73" class="line none">   73  */</div><div id="74" class="line none">   74 </div><div id="75" class="line none">   75 #ifdef CONFIG_SYS_HEAP_RUNTIME_STATS</div><div id="76" class="line none">   76 </div><div id="77" class="line none">   77 /**</div><div id="78" class="line none">   78  * @brief Get the runtime statistics of a sys_heap</div><div id="79" class="line none">   79  *</div><div id="80" class="line none">   80  * @param heap Pointer to specified sys_heap</div><div id="81" class="line none">   81  * @param stats_t Pointer to struct to copy statistics into</div><div id="82" class="line none">   82  * @return -EINVAL if null pointers, otherwise 0</div><div id="83" class="line none">   83  */</div><div id="84" class="line none">   84 int sys_heap_runtime_stats_get(struct <a href="sys_heap.h.html#56">sys_heap</a> *<a href="../kernel.h.html#5318">heap</a>,</div><div id="85" class="line none">   85                 struct sys_memory_stats *stats);</div><div id="86" class="line none">   86 </div><div id="87" class="line none">   87 /**</div><div id="88" class="line none">   88  * @brief Reset the maximum heap usage.</div><div id="89" class="line none">   89  *</div><div id="90" class="line none">   90  * Set the statistic measuring the maximum number of allocated bytes to the</div><div id="91" class="line none">   91  * current number of allocated bytes.</div><div id="92" class="line none">   92  *</div><div id="93" class="line none">   93  * @param heap Pointer to sys_heap</div><div id="94" class="line none">   94  * @return -EINVAL if null pointer was passed, otherwise 0</div><div id="95" class="line none">   95  */</div><div id="96" class="line none">   96 int sys_heap_runtime_stats_reset_max(struct <a href="sys_heap.h.html#56">sys_heap</a> *<a href="../kernel.h.html#5318">heap</a>);</div><div id="97" class="line none">   97 </div><div id="98" class="line none">   98 #endif</div><div id="99" class="line none">   99 </div><div id="100" class="line none">  100 /** @brief Initialize sys_heap</div><div id="101" class="line none">  101  *</div><div id="102" class="line none">  102  * Initializes a sys_heap struct to manage the specified memory.</div><div id="103" class="line none">  103  *</div><div id="104" class="line none">  104  * @param heap Heap to initialize</div><div id="105" class="line none">  105  * @param mem Untyped pointer to unused memory</div><div id="106" class="line none">  106  * @param bytes Size of region pointed to by @a mem</div><div id="107" class="line none">  107  */</div><div id="108" class="line none">  108 void sys_heap_init(struct <a href="sys_heap.h.html#56">sys_heap</a> *<a href="../kernel.h.html#5318">heap</a>, void *mem, size_t bytes);</div><div id="109" class="line none">  109 </div><div id="110" class="line none">  110 /** @brief Allocate memory from a sys_heap</div><div id="111" class="line none">  111  *</div><div id="112" class="line none">  112  * Returns a pointer to a block of unused memory in the heap.  This</div><div id="113" class="line none">  113  * memory will not otherwise be used until it is freed with</div><div id="114" class="line none">  114  * sys_heap_free().  If no memory can be allocated, NULL will be</div><div id="115" class="line none">  115  * returned.  The allocated memory is guaranteed to have a starting</div><div id="116" class="line none">  116  * address which is a multiple of sizeof(void *).  If a bigger alignment</div><div id="117" class="line none">  117  * is necessary then sys_heap_aligned_alloc() should be used instead.</div><div id="118" class="line none">  118  *</div><div id="119" class="line none">  119  * @note The sys_heap implementation is not internally synchronized.</div><div id="120" class="line none">  120  * No two sys_heap functions should operate on the same heap at the</div><div id="121" class="line none">  121  * same time.  All locking must be provided by the user.</div><div id="122" class="line none">  122  *</div><div id="123" class="line none">  123  * @param heap Heap from which to allocate</div><div id="124" class="line none">  124  * @param bytes Number of bytes requested</div><div id="125" class="line none">  125  * @return Pointer to memory the caller can now use</div><div id="126" class="line none">  126  */</div><div id="127" class="line none">  127 void *sys_heap_alloc(struct <a href="sys_heap.h.html#56">sys_heap</a> *<a href="../kernel.h.html#5318">heap</a>, size_t bytes);</div><div id="128" class="line none">  128 </div><div id="129" class="line none">  129 /** @brief Allocate aligned memory from a sys_heap</div><div id="130" class="line none">  130  *</div><div id="131" class="line none">  131  * Behaves in all ways like sys_heap_alloc(), except that the returned</div><div id="132" class="line none">  132  * memory (if available) will have a starting address in memory which</div><div id="133" class="line none">  133  * is a multiple of the specified power-of-two alignment value in</div><div id="134" class="line none">  134  * bytes.  With align=0 this behaves exactly like sys_heap_alloc().</div><div id="135" class="line none">  135  * The resulting memory can be returned to the heap using sys_heap_free().</div><div id="136" class="line none">  136  *</div><div id="137" class="line none">  137  * @param heap Heap from which to allocate</div><div id="138" class="line none">  138  * @param align Alignment in bytes, must be a power of two</div><div id="139" class="line none">  139  * @param bytes Number of bytes requested</div><div id="140" class="line none">  140  * @return Pointer to memory the caller can now use</div><div id="141" class="line none">  141  */</div><div id="142" class="line none">  142 void *sys_heap_aligned_alloc(struct <a href="sys_heap.h.html#56">sys_heap</a> *<a href="../kernel.h.html#5318">heap</a>, size_t align, size_t bytes);</div><div id="143" class="line none">  143 </div><div id="144" class="line none">  144 /** @brief Free memory into a sys_heap</div><div id="145" class="line none">  145  *</div><div id="146" class="line none">  146  * De-allocates a pointer to memory previously returned from</div><div id="147" class="line none">  147  * sys_heap_alloc such that it can be used for other purposes.  The</div><div id="148" class="line none">  148  * caller must not use the memory region after entry to this function.</div><div id="149" class="line none">  149  *</div><div id="150" class="line none">  150  * @note The sys_heap implementation is not internally synchronized.</div><div id="151" class="line none">  151  * No two sys_heap functions should operate on the same heap at the</div><div id="152" class="line none">  152  * same time.  All locking must be provided by the user.</div><div id="153" class="line none">  153  *</div><div id="154" class="line none">  154  * @param heap Heap to which to return the memory</div><div id="155" class="line none">  155  * @param mem A pointer previously returned from sys_heap_alloc()</div><div id="156" class="line none">  156  */</div><div id="157" class="line none">  157 void sys_heap_free(struct <a href="sys_heap.h.html#56">sys_heap</a> *<a href="../kernel.h.html#5318">heap</a>, void *mem);</div><div id="158" class="line none">  158 </div><div id="159" class="line none">  159 /** @brief Expand the size of an existing allocation</div><div id="160" class="line none">  160  *</div><div id="161" class="line none">  161  * Returns a pointer to a new memory region with the same contents,</div><div id="162" class="line none">  162  * but a different allocated size.  If the new allocation can be</div><div id="163" class="line none">  163  * expanded in place, the pointer returned will be identical.</div><div id="164" class="line none">  164  * Otherwise the data will be copies to a new block and the old one</div><div id="165" class="line none">  165  * will be freed as per sys_heap_free().  If the specified size is</div><div id="166" class="line none">  166  * smaller than the original, the block will be truncated in place and</div><div id="167" class="line none">  167  * the remaining memory returned to the heap.  If the allocation of a</div><div id="168" class="line none">  168  * new block fails, then NULL will be returned and the old block will</div><div id="169" class="line none">  169  * not be freed or modified.</div><div id="170" class="line none">  170  *</div><div id="171" class="line none">  171  * @param heap Heap from which to allocate</div><div id="172" class="line none">  172  * @param ptr Original pointer returned from a previous allocation</div><div id="173" class="line none">  173  * @param align Alignment in bytes, must be a power of two</div><div id="174" class="line none">  174  * @param bytes Number of bytes requested for the new block</div><div id="175" class="line none">  175  * @return Pointer to memory the caller can now use, or NULL</div><div id="176" class="line none">  176  */</div><div id="177" class="line none">  177 void *sys_heap_aligned_realloc(struct <a href="sys_heap.h.html#56">sys_heap</a> *<a href="../kernel.h.html#5318">heap</a>, void *ptr,</div><div id="178" class="line none">  178                                size_t align, size_t bytes);</div><div id="179" class="line none">  179 </div><div id="180" class="line none">  180 #define <a href="sys_heap.h.html#180">sys_heap_realloc</a>(<a href="../kernel.h.html#5318">heap</a>, ptr, bytes) \</div><div id="181" class="line none">  181         sys_heap_aligned_realloc(<a href="../kernel.h.html#5318">heap</a>, ptr, 0, bytes)</div><div id="182" class="line none">  182 </div><div id="183" class="line none">  183 /** @brief Return allocated memory size</div><div id="184" class="line none">  184  *</div><div id="185" class="line none">  185  * Returns the size, in bytes, of a block returned from a successful</div><div id="186" class="line none">  186  * sys_heap_alloc() or sys_heap_alloc_aligned() call.  The value</div><div id="187" class="line none">  187  * returned is the size of the heap-managed memory, which may be</div><div id="188" class="line none">  188  * larger than the number of bytes requested due to allocation</div><div id="189" class="line none">  189  * granularity.  The heap code is guaranteed to make no access to this</div><div id="190" class="line none">  190  * region of memory until a subsequent sys_heap_free() on the same</div><div id="191" class="line none">  191  * pointer.</div><div id="192" class="line none">  192  *</div><div id="193" class="line none">  193  * @param heap Heap containing the block</div><div id="194" class="line none">  194  * @param mem Pointer to memory allocated from this heap</div><div id="195" class="line none">  195  * @return Size in bytes of the memory region</div><div id="196" class="line none">  196  */</div><div id="197" class="line none">  197 size_t sys_heap_usable_size(struct <a href="sys_heap.h.html#56">sys_heap</a> *<a href="../kernel.h.html#5318">heap</a>, void *mem);</div><div id="198" class="line none">  198 </div><div id="199" class="line none">  199 /** @brief Validate heap integrity</div><div id="200" class="line none">  200  *</div><div id="201" class="line none">  201  * Validates the internal integrity of a sys_heap.  Intended for unit</div><div id="202" class="line none">  202  * test and validation code, though potentially useful as a user API</div><div id="203" class="line none">  203  * for applications with complicated runtime reliability requirements.</div><div id="204" class="line none">  204  * Note: this cannot catch every possible error, but if it returns</div><div id="205" class="line none">  205  * true then the heap is in a consistent state and can correctly</div><div id="206" class="line none">  206  * handle any sys_heap_alloc() request and free any live pointer</div><div id="207" class="line none">  207  * returned from a previous allocation.</div><div id="208" class="line none">  208  *</div><div id="209" class="line none">  209  * @param heap Heap to validate</div><div id="210" class="line none">  210  * @return true, if the heap is valid, otherwise false</div><div id="211" class="line none">  211  */</div><div id="212" class="line none">  212 bool sys_heap_validate(struct <a href="sys_heap.h.html#56">sys_heap</a> *<a href="../kernel.h.html#5318">heap</a>);</div><div id="213" class="line none">  213 </div><div id="214" class="line none">  214 /** @brief sys_heap stress test rig</div><div id="215" class="line none">  215  *</div><div id="216" class="line none">  216  * Test rig for heap allocation validation.  This will loop for @a</div><div id="217" class="line none">  217  * op_count cycles, in each iteration making a random choice to</div><div id="218" class="line none">  218  * allocate or free a pointer of randomized (power law) size based on</div><div id="219" class="line none">  219  * heuristics designed to keep the heap in a state where it is near @a</div><div id="220" class="line none">  220  * target_percent full.  Allocation and free operations are provided</div><div id="221" class="line none">  221  * by the caller as callbacks (i.e. this can in theory test any heap).</div><div id="222" class="line none">  222  * Results, including counts of frees and successful/unsuccessful</div><div id="223" class="line none">  223  * allocations, are returned via the @a result struct.</div><div id="224" class="line none">  224  *</div><div id="225" class="line none">  225  * @param alloc_fn Callback to perform an allocation.  Passes back the @a</div><div id="226" class="line none">  226  *              arg parameter as a context handle.</div><div id="227" class="line none">  227  * @param free_fn Callback to perform a free of a pointer returned from</div><div id="228" class="line none">  228  *             @a alloc.  Passes back the @a arg parameter as a</div><div id="229" class="line none">  229  *             context handle.</div><div id="230" class="line none">  230  * @param arg Context handle to pass back to the callbacks</div><div id="231" class="line none">  231  * @param total_bytes Size of the byte array the heap was initialized in</div><div id="232" class="line none">  232  * @param op_count How many iterations to test</div><div id="233" class="line none">  233  * @param scratch_mem A pointer to scratch memory to be used by the</div><div id="234" class="line none">  234  *                    test.  Should be about 1/2 the size of the heap</div><div id="235" class="line none">  235  *                    for tests that need to stress fragmentation.</div><div id="236" class="line none">  236  * @param scratch_bytes Size of the memory pointed to by @a scratch_mem</div><div id="237" class="line none">  237  * @param target_percent Percentage fill value (1-100) to which the</div><div id="238" class="line none">  238  *                       random allocation choices will seek.  High</div><div id="239" class="line none">  239  *                       values will result in significant allocation</div><div id="240" class="line none">  240  *                       failures and a very fragmented heap.</div><div id="241" class="line none">  241  * @param result Struct into which to store test results.</div><div id="242" class="line none">  242  */</div><div id="243" class="line none">  243 void sys_heap_stress(void *(*alloc_fn)(void *arg, size_t bytes),</div><div id="244" class="line none">  244                      void (*free_fn)(void *arg, void *p),</div><div id="245" class="line none">  245                      void *arg, size_t total_bytes,</div><div id="246" class="line none">  246                      uint32_t op_count,</div><div id="247" class="line none">  247                      void *scratch_mem, size_t scratch_bytes,</div><div id="248" class="line none">  248                      int target_percent,</div><div id="249" class="line none">  249                      struct <a href="sys_heap.h.html#62">z_heap_stress_result</a> *<a href="../kernel.h.html#5699">result</a>);</div><div id="250" class="line none">  250 </div><div id="251" class="line none">  251 /** @brief Print heap internal structure information to the console</div><div id="252" class="line none">  252  *</div><div id="253" class="line none">  253  * Print information on the heap structure such as its size, chunk buckets,</div><div id="254" class="line none">  254  * chunk list and some statistics for debugging purpose.</div><div id="255" class="line none">  255  *</div><div id="256" class="line none">  256  * @param heap Heap to print information about</div><div id="257" class="line none">  257  * @param dump_chunks True to print the entire heap chunk list</div><div id="258" class="line none">  258  */</div><div id="259" class="line none">  259 void sys_heap_print_info(struct <a href="sys_heap.h.html#56">sys_heap</a> *<a href="../kernel.h.html#5318">heap</a>, bool dump_chunks);</div><div id="260" class="line none">  260 </div><div id="261" class="line none">  261 /**</div><div id="262" class="line none">  262  * @}</div><div id="263" class="line none">  263  */</div><div id="264" class="line none">  264 </div><div id="265" class="line none">  265 #ifdef __cplusplus</div><div id="266" class="line none">  266 }</div><div id="267" class="line none">  267 #endif</div><div id="268" class="line none">  268 </div><div id="269" class="line none">  269 #endif /* ZEPHYR_INCLUDE_SYS_SYS_HEAP_H_ */</div>
</div>
</body>
</html>
