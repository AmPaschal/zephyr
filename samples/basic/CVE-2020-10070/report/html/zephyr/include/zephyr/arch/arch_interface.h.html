
<html>
<head>
<title>zephyr/include/zephyr/arch/arch_interface.h</title>
<link rel="stylesheet" type="text/css" href="../../../../viewer.css">
</head>

<body>
<div class="code">
<div id="1" class="line none">    1 /*</div><div id="2" class="line none">    2  * Copyright (c) 2019 Intel Corporation.</div><div id="3" class="line none">    3  *</div><div id="4" class="line none">    4  * SPDX-License-Identifier: Apache-2.0</div><div id="5" class="line none">    5  */</div><div id="6" class="line none">    6 </div><div id="7" class="line none">    7 /**</div><div id="8" class="line none">    8  * @defgroup arch-interface Architecture Interface</div><div id="9" class="line none">    9  * @ingroup internal_api</div><div id="10" class="line none">   10  * @brief Internal kernel APIs with public scope</div><div id="11" class="line none">   11  *</div><div id="12" class="line none">   12  * Any public kernel APIs that are implemented as inline functions and need to</div><div id="13" class="line none">   13  * call architecture-specific API so will have the prototypes for the</div><div id="14" class="line none">   14  * architecture-specific APIs here. Architecture APIs that aren't used in this</div><div id="15" class="line none">   15  * way go in kernel/include/kernel_arch_interface.h.</div><div id="16" class="line none">   16  *</div><div id="17" class="line none">   17  * The set of architecture-specific APIs used internally by public macros and</div><div id="18" class="line none">   18  * inline functions in public headers are also specified and documented.</div><div id="19" class="line none">   19  *</div><div id="20" class="line none">   20  * For all macros and inline function prototypes described herein, &lt;arch/cpu.h&gt;</div><div id="21" class="line none">   21  * must eventually pull in full definitions for all of them (the actual macro</div><div id="22" class="line none">   22  * defines and inline function bodies)</div><div id="23" class="line none">   23  *</div><div id="24" class="line none">   24  * include/kernel.h and other public headers depend on definitions in this</div><div id="25" class="line none">   25  * header.</div><div id="26" class="line none">   26  */</div><div id="27" class="line none">   27 #ifndef <a href="arch_interface.h.html#28">ZEPHYR_INCLUDE_ARCH_ARCH_INTERFACE_H_</a></div><div id="28" class="line none">   28 #define <a href="arch_interface.h.html#28">ZEPHYR_INCLUDE_ARCH_ARCH_INTERFACE_H_</a></div><div id="29" class="line none">   29 </div><div id="30" class="line none">   30 #ifndef _ASMLANGUAGE</div><div id="31" class="line none">   31 #include &lt;zephyr/toolchain.h&gt;</div><div id="32" class="line none">   32 #include &lt;stddef.h&gt;</div><div id="33" class="line none">   33 #include &lt;zephyr/types.h&gt;</div><div id="34" class="line none">   34 #include &lt;zephyr/<a href="../kernel/thread.h.html#376">arch</a>/<a href="../kernel/thread.h.html#115">cpu</a>.h&gt;</div><div id="35" class="line none">   35 #include &lt;zephyr/irq_offload.h&gt;</div><div id="36" class="line none">   36 </div><div id="37" class="line none">   37 #ifdef __cplusplus</div><div id="38" class="line none">   38 extern "C" {</div><div id="39" class="line none">   39 #endif</div><div id="40" class="line none">   40 </div><div id="41" class="line none">   41 /* NOTE: We cannot pull in kernel.h here, need some forward declarations  */</div><div id="42" class="line none">   42 struct arch_esf;</div><div id="43" class="line none">   43 struct <a href="arch_interface.h.html#43">k_thread</a>;</div><div id="44" class="line none">   44 struct k_mem_domain;</div><div id="45" class="line none">   45 </div><div id="46" class="line none">   46 typedef struct z_thread_stack_element <a href="arch_interface.h.html#46">k_thread_stack_t</a>;</div><div id="47" class="line none">   47 </div><div id="48" class="line none">   48 typedef void (*<a href="arch_interface.h.html#48">k_thread_entry_t</a>)(void *p1, void *p2, void *p3);</div><div id="49" class="line none">   49 </div><div id="50" class="line none">   50 __deprecated typedef struct arch_esf <a href="arch_interface.h.html#50">z_arch_esf_t</a>;</div><div id="51" class="line none">   51 </div><div id="52" class="line none">   52 /**</div><div id="53" class="line none">   53  * @defgroup arch-timing Architecture timing APIs</div><div id="54" class="line none">   54  * @ingroup arch-interface</div><div id="55" class="line none">   55  * @{</div><div id="56" class="line none">   56  */</div><div id="57" class="line none">   57 </div><div id="58" class="line none">   58 /**</div><div id="59" class="line none">   59  * Obtain the current cycle count, in units specified by</div><div id="60" class="line none">   60  * CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC.  While this is historically</div><div id="61" class="line none">   61  * specified as part of the architecture API, in practice virtually</div><div id="62" class="line none">   62  * all platforms forward it to the sys_clock_cycle_get_32() API</div><div id="63" class="line none">   63  * provided by the timer driver.</div><div id="64" class="line none">   64  *</div><div id="65" class="line none">   65  * @see k_cycle_get_32()</div><div id="66" class="line none">   66  *</div><div id="67" class="line none">   67  * @return The current cycle time.  This should count up monotonically</div><div id="68" class="line none">   68  * through the full 32 bit space, wrapping at 0xffffffff.  Hardware</div><div id="69" class="line none">   69  * with fewer bits of precision in the timer is expected to synthesize</div><div id="70" class="line none">   70  * a 32 bit count.</div><div id="71" class="line none">   71  */</div><div id="72" class="line none">   72 static inline uint32_t arch_k_cycle_get_32(void);</div><div id="73" class="line none">   73 </div><div id="74" class="line none">   74 /**</div><div id="75" class="line none">   75  * As for arch_k_cycle_get_32(), but with a 64 bit return value.  Not</div><div id="76" class="line none">   76  * all timer hardware has a 64 bit timer, this needs to be implemented</div><div id="77" class="line none">   77  * only if CONFIG_TIMER_HAS_64BIT_CYCLE_COUNTER is set.</div><div id="78" class="line none">   78  *</div><div id="79" class="line none">   79  * @see arch_k_cycle_get_32()</div><div id="80" class="line none">   80  *</div><div id="81" class="line none">   81  * @return The current cycle time.  This should count up monotonically</div><div id="82" class="line none">   82  * through the full 64 bit space, wrapping at 2^64-1.  Hardware with</div><div id="83" class="line none">   83  * fewer bits of precision in the timer is generally not expected to</div><div id="84" class="line none">   84  * implement this API.</div><div id="85" class="line none">   85  */</div><div id="86" class="line none">   86 static inline uint64_t arch_k_cycle_get_64(void);</div><div id="87" class="line none">   87 </div><div id="88" class="line none">   88 /** @} */</div><div id="89" class="line none">   89 </div><div id="90" class="line none">   90 </div><div id="91" class="line none">   91 /**</div><div id="92" class="line none">   92  * @addtogroup arch-threads</div><div id="93" class="line none">   93  * @{</div><div id="94" class="line none">   94  */</div><div id="95" class="line none">   95 </div><div id="96" class="line none">   96 /**</div><div id="97" class="line none">   97  * @def ARCH_THREAD_STACK_RESERVED</div><div id="98" class="line none">   98  *</div><div id="99" class="line none">   99  * @see K_THREAD_STACK_RESERVED</div><div id="100" class="line none">  100  */</div><div id="101" class="line none">  101 </div><div id="102" class="line none">  102 /**</div><div id="103" class="line none">  103  * @def ARCH_STACK_PTR_ALIGN</div><div id="104" class="line none">  104  *</div><div id="105" class="line none">  105  * Required alignment of the CPU's stack pointer register value, dictated by</div><div id="106" class="line none">  106  * hardware constraints and the ABI calling convention.</div><div id="107" class="line none">  107  *</div><div id="108" class="line none">  108  * @see Z_STACK_PTR_ALIGN</div><div id="109" class="line none">  109  */</div><div id="110" class="line none">  110 </div><div id="111" class="line none">  111 /**</div><div id="112" class="line none">  112  * @def ARCH_THREAD_STACK_OBJ_ALIGN(size)</div><div id="113" class="line none">  113  *</div><div id="114" class="line none">  114  * Required alignment of the lowest address of a stack object.</div><div id="115" class="line none">  115  *</div><div id="116" class="line none">  116  * Optional definition.</div><div id="117" class="line none">  117  *</div><div id="118" class="line none">  118  * @see Z_THREAD_STACK_OBJ_ALIGN</div><div id="119" class="line none">  119  */</div><div id="120" class="line none">  120 </div><div id="121" class="line none">  121 /**</div><div id="122" class="line none">  122  * @def ARCH_THREAD_STACK_SIZE_ADJUST(size)</div><div id="123" class="line none">  123  * @brief Round up a stack buffer size to alignment constraints</div><div id="124" class="line none">  124  *</div><div id="125" class="line none">  125  * Adjust a requested stack buffer size to the true size of its underlying</div><div id="126" class="line none">  126  * buffer, defined as the area usable for thread stack context and thread-</div><div id="127" class="line none">  127  * local storage.</div><div id="128" class="line none">  128  *</div><div id="129" class="line none">  129  * The size value passed here does not include storage reserved for platform</div><div id="130" class="line none">  130  * data.</div><div id="131" class="line none">  131  *</div><div id="132" class="line none">  132  * The returned value is either the same size provided (if already properly</div><div id="133" class="line none">  133  * aligned), or rounded up to satisfy alignment constraints.  Calculations</div><div id="134" class="line none">  134  * performed here *must* be idempotent.</div><div id="135" class="line none">  135  *</div><div id="136" class="line none">  136  * Optional definition. If undefined, stack buffer sizes are either:</div><div id="137" class="line none">  137  * - Rounded up to the next power of two if user mode is enabled on an arch</div><div id="138" class="line none">  138  *   with an MPU that requires such alignment</div><div id="139" class="line none">  139  * - Rounded up to ARCH_STACK_PTR_ALIGN</div><div id="140" class="line none">  140  *</div><div id="141" class="line none">  141  * @see Z_THREAD_STACK_SIZE_ADJUST</div><div id="142" class="line none">  142  */</div><div id="143" class="line none">  143 </div><div id="144" class="line none">  144 /**</div><div id="145" class="line none">  145  * @def ARCH_KERNEL_STACK_RESERVED</div><div id="146" class="line none">  146  * @brief MPU guard size for kernel-only stacks</div><div id="147" class="line none">  147  *</div><div id="148" class="line none">  148  * If MPU stack guards are used to catch stack overflows, specify the</div><div id="149" class="line none">  149  * amount of space reserved in kernel stack objects. If guard sizes are</div><div id="150" class="line none">  150  * context dependent, this should be in the minimum guard size, with</div><div id="151" class="line none">  151  * remaining space carved out if needed.</div><div id="152" class="line none">  152  *</div><div id="153" class="line none">  153  * Optional definition, defaults to 0.</div><div id="154" class="line none">  154  *</div><div id="155" class="line none">  155  * @see K_KERNEL_STACK_RESERVED</div><div id="156" class="line none">  156  */</div><div id="157" class="line none">  157 </div><div id="158" class="line none">  158 /**</div><div id="159" class="line none">  159  * @def ARCH_KERNEL_STACK_OBJ_ALIGN</div><div id="160" class="line none">  160  * @brief Required alignment of the lowest address of a kernel-only stack.</div><div id="161" class="line none">  161  */</div><div id="162" class="line none">  162 </div><div id="163" class="line none">  163 /** @} */</div><div id="164" class="line none">  164 </div><div id="165" class="line none">  165 /**</div><div id="166" class="line none">  166  * @addtogroup arch-pm</div><div id="167" class="line none">  167  * @{</div><div id="168" class="line none">  168  */</div><div id="169" class="line none">  169 </div><div id="170" class="line none">  170 /**</div><div id="171" class="line none">  171  * @brief Power save idle routine</div><div id="172" class="line none">  172  *</div><div id="173" class="line none">  173  * This function will be called by the kernel idle loop or possibly within</div><div id="174" class="line none">  174  * an implementation of z_pm_save_idle in the kernel when the</div><div id="175" class="line none">  175  * '_pm_save_flag' variable is non-zero.</div><div id="176" class="line none">  176  *</div><div id="177" class="line none">  177  * Architectures that do not implement power management instructions may</div><div id="178" class="line none">  178  * immediately return, otherwise a power-saving instruction should be</div><div id="179" class="line none">  179  * issued to wait for an interrupt.</div><div id="180" class="line none">  180  *</div><div id="181" class="line none">  181  * @note The function is expected to return after the interrupt that has</div><div id="182" class="line none">  182  * caused the CPU to exit power-saving mode has been serviced, although</div><div id="183" class="line none">  183  * this is not a firm requirement.</div><div id="184" class="line none">  184  *</div><div id="185" class="line none">  185  * @see k_cpu_idle()</div><div id="186" class="line none">  186  */</div><div id="187" class="line none">  187 void arch_cpu_idle(void);</div><div id="188" class="line none">  188 </div><div id="189" class="line none">  189 /**</div><div id="190" class="line none">  190  * @brief Atomically re-enable interrupts and enter low power mode</div><div id="191" class="line none">  191  *</div><div id="192" class="line none">  192  * The requirements for arch_cpu_atomic_idle() are as follows:</div><div id="193" class="line none">  193  *</div><div id="194" class="line none">  194  * -# Enabling interrupts and entering a low-power mode needs to be</div><div id="195" class="line none">  195  *    atomic, i.e. there should be no period of time where interrupts are</div><div id="196" class="line none">  196  *    enabled before the processor enters a low-power mode.  See the comments</div><div id="197" class="line none">  197  *    in k_lifo_get(), for example, of the race condition that</div><div id="198" class="line none">  198  *    occurs if this requirement is not met.</div><div id="199" class="line none">  199  *</div><div id="200" class="line none">  200  * -# After waking up from the low-power mode, the interrupt lockout state</div><div id="201" class="line none">  201  *    must be restored as indicated in the 'key' input parameter.</div><div id="202" class="line none">  202  *</div><div id="203" class="line none">  203  * @see k_cpu_atomic_idle()</div><div id="204" class="line none">  204  *</div><div id="205" class="line none">  205  * @param key Lockout key returned by previous invocation of arch_irq_lock()</div><div id="206" class="line none">  206  */</div><div id="207" class="line none">  207 void arch_cpu_atomic_idle(unsigned int <a href="../spinlock.h.html#35">key</a>);</div><div id="208" class="line none">  208 </div><div id="209" class="line none">  209 /** @} */</div><div id="210" class="line none">  210 </div><div id="211" class="line none">  211 </div><div id="212" class="line none">  212 /**</div><div id="213" class="line none">  213  * @addtogroup arch-smp</div><div id="214" class="line none">  214  * @{</div><div id="215" class="line none">  215  */</div><div id="216" class="line none">  216 </div><div id="217" class="line none">  217 /**</div><div id="218" class="line none">  218  * Per-cpu entry function</div><div id="219" class="line none">  219  *</div><div id="220" class="line none">  220  * @param data context parameter, implementation specific</div><div id="221" class="line none">  221  */</div><div id="222" class="line none">  222 typedef void (*<a href="arch_interface.h.html#222">arch_cpustart_t</a>)(void *<a href="../logging/log_msg.h.html#100">data</a>);</div><div id="223" class="line none">  223 </div><div id="224" class="line none">  224 /**</div><div id="225" class="line none">  225  * @brief Start a numbered CPU on a MP-capable system</div><div id="226" class="line none">  226  *</div><div id="227" class="line none">  227  * This starts and initializes a specific CPU.  The main thread on startup is</div><div id="228" class="line none">  228  * running on CPU zero, other processors are numbered sequentially.  On return</div><div id="229" class="line none">  229  * from this function, the CPU is known to have begun operating and will enter</div><div id="230" class="line none">  230  * the provided function.  Its interrupts will be initialized but disabled such</div><div id="231" class="line none">  231  * that irq_unlock() with the provided key will work to enable them.</div><div id="232" class="line none">  232  *</div><div id="233" class="line none">  233  * Normally, in SMP mode this function will be called by the kernel</div><div id="234" class="line none">  234  * initialization and should not be used as a user API.  But it is defined here</div><div id="235" class="line none">  235  * for special-purpose apps which want Zephyr running on one core and to use</div><div id="236" class="line none">  236  * others for design-specific processing.</div><div id="237" class="line none">  237  *</div><div id="238" class="line none">  238  * @param cpu_num Integer number of the CPU</div><div id="239" class="line none">  239  * @param stack Stack memory for the CPU</div><div id="240" class="line none">  240  * @param sz Stack buffer size, in bytes</div><div id="241" class="line none">  241  * @param fn Function to begin running on the CPU.</div><div id="242" class="line none">  242  * @param arg Untyped argument to be passed to "fn"</div><div id="243" class="line none">  243  */</div><div id="244" class="line none">  244 void arch_cpu_start(int cpu_num, <a href="arch_interface.h.html#46">k_thread_stack_t</a> *<a href="../sys/rb.h.html#173">stack</a>, int <a href="../kernel/thread.h.html#181">sz</a>,</div><div id="245" class="line none">  245                     <a href="arch_interface.h.html#222">arch_cpustart_t</a> <a href="../kernel_structs.h.html#298">fn</a>, void *arg);</div><div id="246" class="line none">  246 </div><div id="247" class="line none">  247 /**</div><div id="248" class="line none">  248  * @brief Return CPU power status</div><div id="249" class="line none">  249  *</div><div id="250" class="line none">  250  * @param cpu_num Integer number of the CPU</div><div id="251" class="line none">  251  */</div><div id="252" class="line none">  252 bool arch_cpu_active(int cpu_num);</div><div id="253" class="line none">  253 </div><div id="254" class="line none">  254 /** @} */</div><div id="255" class="line none">  255 </div><div id="256" class="line none">  256 </div><div id="257" class="line none">  257 /**</div><div id="258" class="line none">  258  * @addtogroup arch-irq</div><div id="259" class="line none">  259  * @{</div><div id="260" class="line none">  260  */</div><div id="261" class="line none">  261 </div><div id="262" class="line none">  262 /**</div><div id="263" class="line none">  263  * Lock interrupts on the current CPU</div><div id="264" class="line none">  264  *</div><div id="265" class="line none">  265  * @see irq_lock()</div><div id="266" class="line none">  266  */</div><div id="267" class="line none">  267 static inline unsigned int arch_irq_lock(void);</div><div id="268" class="line none">  268 </div><div id="269" class="line none">  269 /**</div><div id="270" class="line none">  270  * Unlock interrupts on the current CPU</div><div id="271" class="line none">  271  *</div><div id="272" class="line none">  272  * @see irq_unlock()</div><div id="273" class="line none">  273  */</div><div id="274" class="line none">  274 static inline void arch_irq_unlock(unsigned int <a href="../spinlock.h.html#35">key</a>);</div><div id="275" class="line none">  275 </div><div id="276" class="line none">  276 /**</div><div id="277" class="line none">  277  * Test if calling arch_irq_unlock() with this key would unlock irqs</div><div id="278" class="line none">  278  *</div><div id="279" class="line none">  279  * @param key value returned by arch_irq_lock()</div><div id="280" class="line none">  280  * @return true if interrupts were unlocked prior to the arch_irq_lock()</div><div id="281" class="line none">  281  * call that produced the key argument.</div><div id="282" class="line none">  282  */</div><div id="283" class="line none">  283 static inline bool arch_irq_unlocked(unsigned int <a href="../spinlock.h.html#35">key</a>);</div><div id="284" class="line none">  284 </div><div id="285" class="line none">  285 /**</div><div id="286" class="line none">  286  * Disable the specified interrupt line</div><div id="287" class="line none">  287  *</div><div id="288" class="line none">  288  * @note: The behavior of interrupts that arrive after this call</div><div id="289" class="line none">  289  * returns and before the corresponding call to arch_irq_enable() is</div><div id="290" class="line none">  290  * undefined.  The hardware is not required to latch and deliver such</div><div id="291" class="line none">  291  * an interrupt, though on some architectures that may work.  Other</div><div id="292" class="line none">  292  * architectures will simply lose such an interrupt and never deliver</div><div id="293" class="line none">  293  * it.  Many drivers and subsystems are not tolerant of such dropped</div><div id="294" class="line none">  294  * interrupts and it is the job of the application layer to ensure</div><div id="295" class="line none">  295  * that behavior remains correct.</div><div id="296" class="line none">  296  *</div><div id="297" class="line none">  297  * @see irq_disable()</div><div id="298" class="line none">  298  */</div><div id="299" class="line none">  299 void arch_irq_disable(unsigned int irq);</div><div id="300" class="line none">  300 </div><div id="301" class="line none">  301 /**</div><div id="302" class="line none">  302  * Enable the specified interrupt line</div><div id="303" class="line none">  303  *</div><div id="304" class="line none">  304  * @see irq_enable()</div><div id="305" class="line none">  305  */</div><div id="306" class="line none">  306 void arch_irq_enable(unsigned int irq);</div><div id="307" class="line none">  307 </div><div id="308" class="line none">  308 /**</div><div id="309" class="line none">  309  * Test if an interrupt line is enabled</div><div id="310" class="line none">  310  *</div><div id="311" class="line none">  311  * @see irq_is_enabled()</div><div id="312" class="line none">  312  */</div><div id="313" class="line none">  313 int arch_irq_is_enabled(unsigned int irq);</div><div id="314" class="line none">  314 </div><div id="315" class="line none">  315 /**</div><div id="316" class="line none">  316  * Arch-specific hook to install a dynamic interrupt.</div><div id="317" class="line none">  317  *</div><div id="318" class="line none">  318  * @param irq IRQ line number</div><div id="319" class="line none">  319  * @param priority Interrupt priority</div><div id="320" class="line none">  320  * @param routine Interrupt service routine</div><div id="321" class="line none">  321  * @param parameter ISR parameter</div><div id="322" class="line none">  322  * @param flags Arch-specific IRQ configuration flag</div><div id="323" class="line none">  323  *</div><div id="324" class="line none">  324  * @return The vector assigned to this interrupt</div><div id="325" class="line none">  325  */</div><div id="326" class="line none">  326 int arch_irq_connect_dynamic(unsigned int irq, unsigned int priority,</div><div id="327" class="line none">  327                              void (*routine)(const void *parameter),</div><div id="328" class="line none">  328                              const void *parameter, uint32_t <a href="../kernel.h.html#2764">flags</a>);</div><div id="329" class="line none">  329 </div><div id="330" class="line none">  330 /**</div><div id="331" class="line none">  331  * Arch-specific hook to dynamically uninstall a shared interrupt.</div><div id="332" class="line none">  332  * If the interrupt is not being shared, then the associated</div><div id="333" class="line none">  333  * _sw_isr_table entry will be replaced by (NULL, z_irq_spurious)</div><div id="334" class="line none">  334  * (default entry).</div><div id="335" class="line none">  335  *</div><div id="336" class="line none">  336  * @param irq IRQ line number</div><div id="337" class="line none">  337  * @param priority Interrupt priority</div><div id="338" class="line none">  338  * @param routine Interrupt service routine</div><div id="339" class="line none">  339  * @param parameter ISR parameter</div><div id="340" class="line none">  340  * @param flags Arch-specific IRQ configuration flag</div><div id="341" class="line none">  341  *</div><div id="342" class="line none">  342  * @return 0 in case of success, negative value otherwise</div><div id="343" class="line none">  343  */</div><div id="344" class="line none">  344 int arch_irq_disconnect_dynamic(unsigned int irq, unsigned int priority,</div><div id="345" class="line none">  345                                 void (*routine)(const void *parameter),</div><div id="346" class="line none">  346                                 const void *parameter, uint32_t <a href="../kernel.h.html#2764">flags</a>);</div><div id="347" class="line none">  347 </div><div id="348" class="line none">  348 /**</div><div id="349" class="line none">  349  * @def ARCH_IRQ_CONNECT(irq, pri, isr, arg, flags)</div><div id="350" class="line none">  350  *</div><div id="351" class="line none">  351  * @see IRQ_CONNECT()</div><div id="352" class="line none">  352  */</div><div id="353" class="line none">  353 </div><div id="354" class="line none">  354 #ifdef CONFIG_PCIE</div><div id="355" class="line none">  355 /**</div><div id="356" class="line none">  356  * @def ARCH_PCIE_IRQ_CONNECT(bdf, irq, pri, isr, arg, flags)</div><div id="357" class="line none">  357  *</div><div id="358" class="line none">  358  * @see PCIE_IRQ_CONNECT()</div><div id="359" class="line none">  359  */</div><div id="360" class="line none">  360 #endif /* CONFIG_PCIE */</div><div id="361" class="line none">  361 </div><div id="362" class="line none">  362 /**</div><div id="363" class="line none">  363  * @def ARCH_IRQ_DIRECT_CONNECT(irq_p, priority_p, isr_p, flags_p)</div><div id="364" class="line none">  364  *</div><div id="365" class="line none">  365  * @see IRQ_DIRECT_CONNECT()</div><div id="366" class="line none">  366  */</div><div id="367" class="line none">  367 </div><div id="368" class="line none">  368 /**</div><div id="369" class="line none">  369  * @def ARCH_ISR_DIRECT_PM()</div><div id="370" class="line none">  370  *</div><div id="371" class="line none">  371  * @see ISR_DIRECT_PM()</div><div id="372" class="line none">  372  */</div><div id="373" class="line none">  373 </div><div id="374" class="line none">  374 /**</div><div id="375" class="line none">  375  * @def ARCH_ISR_DIRECT_HEADER()</div><div id="376" class="line none">  376  *</div><div id="377" class="line none">  377  * @see ISR_DIRECT_HEADER()</div><div id="378" class="line none">  378  */</div><div id="379" class="line none">  379 </div><div id="380" class="line none">  380 /**</div><div id="381" class="line none">  381  * @def ARCH_ISR_DIRECT_FOOTER(swap)</div><div id="382" class="line none">  382  *</div><div id="383" class="line none">  383  * @see ISR_DIRECT_FOOTER()</div><div id="384" class="line none">  384  */</div><div id="385" class="line none">  385 </div><div id="386" class="line none">  386 /**</div><div id="387" class="line none">  387  * @def ARCH_ISR_DIRECT_DECLARE(name)</div><div id="388" class="line none">  388  *</div><div id="389" class="line none">  389  * @see ISR_DIRECT_DECLARE()</div><div id="390" class="line none">  390  */</div><div id="391" class="line none">  391 </div><div id="392" class="line none">  392 #ifndef CONFIG_PCIE_CONTROLLER</div><div id="393" class="line none">  393 /**</div><div id="394" class="line none">  394  * @brief Arch-specific hook for allocating IRQs</div><div id="395" class="line none">  395  *</div><div id="396" class="line none">  396  * Note: disable/enable IRQ relevantly inside the implementation of such</div><div id="397" class="line none">  397  * function to avoid concurrency issues. Also, an allocated IRQ is assumed</div><div id="398" class="line none">  398  * to be used thus a following @see arch_irq_is_used() should return true.</div><div id="399" class="line none">  399  *</div><div id="400" class="line none">  400  * @return The newly allocated IRQ or UINT_MAX on error.</div><div id="401" class="line none">  401  */</div><div id="402" class="line none">  402 unsigned int arch_irq_allocate(void);</div><div id="403" class="line none">  403 </div><div id="404" class="line none">  404 /**</div><div id="405" class="line none">  405  * @brief Arch-specific hook for declaring an IRQ being used</div><div id="406" class="line none">  406  *</div><div id="407" class="line none">  407  * Note: disable/enable IRQ relevantly inside the implementation of such</div><div id="408" class="line none">  408  * function to avoid concurrency issues.</div><div id="409" class="line none">  409  *</div><div id="410" class="line none">  410  * @param irq the IRQ to declare being used</div><div id="411" class="line none">  411  */</div><div id="412" class="line none">  412 void arch_irq_set_used(unsigned int irq);</div><div id="413" class="line none">  413 </div><div id="414" class="line none">  414 /**</div><div id="415" class="line none">  415  * @brief Arch-specific hook for checking if an IRQ is being used already</div><div id="416" class="line none">  416  *</div><div id="417" class="line none">  417  * @param irq the IRQ to check</div><div id="418" class="line none">  418  *</div><div id="419" class="line none">  419  * @return true if being, false otherwise</div><div id="420" class="line none">  420  */</div><div id="421" class="line none">  421 bool arch_irq_is_used(unsigned int irq);</div><div id="422" class="line none">  422 </div><div id="423" class="line none">  423 #endif /* CONFIG_PCIE_CONTROLLER */</div><div id="424" class="line none">  424 </div><div id="425" class="line none">  425 /**</div><div id="426" class="line none">  426  * @def ARCH_EXCEPT(reason_p)</div><div id="427" class="line none">  427  *</div><div id="428" class="line none">  428  * Generate a software induced fatal error.</div><div id="429" class="line none">  429  *</div><div id="430" class="line none">  430  * If the caller is running in user mode, only K_ERR_KERNEL_OOPS or</div><div id="431" class="line none">  431  * K_ERR_STACK_CHK_FAIL may be induced.</div><div id="432" class="line none">  432  *</div><div id="433" class="line none">  433  * This should ideally generate a software trap, with exception context</div><div id="434" class="line none">  434  * indicating state when this was invoked. General purpose register state at</div><div id="435" class="line none">  435  * the time of trap should not be disturbed from the calling context.</div><div id="436" class="line none">  436  *</div><div id="437" class="line none">  437  * @param reason_p K_ERR_ scoped reason code for the fatal error.</div><div id="438" class="line none">  438  */</div><div id="439" class="line none">  439 </div><div id="440" class="line none">  440 #ifdef CONFIG_IRQ_OFFLOAD</div><div id="441" class="line none">  441 /**</div><div id="442" class="line none">  442  * Run a function in interrupt context.</div><div id="443" class="line none">  443  *</div><div id="444" class="line none">  444  * Implementations should invoke an exception such that the kernel goes through</div><div id="445" class="line none">  445  * its interrupt handling dispatch path, to include switching to the interrupt</div><div id="446" class="line none">  446  * stack, and runs the provided routine and parameter.</div><div id="447" class="line none">  447  *</div><div id="448" class="line none">  448  * The only intended use-case for this function is for test code to simulate</div><div id="449" class="line none">  449  * the correctness of kernel APIs in interrupt handling context. This API</div><div id="450" class="line none">  450  * is not intended for real applications.</div><div id="451" class="line none">  451  *</div><div id="452" class="line none">  452  * @see irq_offload()</div><div id="453" class="line none">  453  *</div><div id="454" class="line none">  454  * @param routine Function to run in interrupt context</div><div id="455" class="line none">  455  * @param parameter Value to pass to the function when invoked</div><div id="456" class="line none">  456  */</div><div id="457" class="line none">  457 void arch_irq_offload(irq_offload_routine_t routine, const void *parameter);</div><div id="458" class="line none">  458 #endif /* CONFIG_IRQ_OFFLOAD */</div><div id="459" class="line none">  459 </div><div id="460" class="line none">  460 /** @} */</div><div id="461" class="line none">  461 </div><div id="462" class="line none">  462 </div><div id="463" class="line none">  463 /**</div><div id="464" class="line none">  464  * @defgroup arch-smp Architecture-specific SMP APIs</div><div id="465" class="line none">  465  * @ingroup arch-interface</div><div id="466" class="line none">  466  * @{</div><div id="467" class="line none">  467  */</div><div id="468" class="line none">  468 #ifdef CONFIG_SMP</div><div id="469" class="line none">  469 /** Return the CPU struct for the currently executing CPU */</div><div id="470" class="line none">  470 static inline struct <a href="../kernel_structs.h.html#144">_cpu</a> *arch_curr_cpu(void);</div><div id="471" class="line none">  471 </div><div id="472" class="line none">  472 </div><div id="473" class="line none">  473 /**</div><div id="474" class="line none">  474  * @brief Processor hardware ID</div><div id="475" class="line none">  475  *</div><div id="476" class="line none">  476  * Most multiprocessor architectures have a low-level unique ID value</div><div id="477" class="line none">  477  * associated with the current CPU that can be retrieved rapidly and</div><div id="478" class="line none">  478  * efficiently in kernel context.  Note that while the numbering of</div><div id="479" class="line none">  479  * the CPUs is guaranteed to be unique, the values are</div><div id="480" class="line none">  480  * platform-defined. In particular, they are not guaranteed to match</div><div id="481" class="line none">  481  * Zephyr's own sequential CPU IDs (even though on some platforms they</div><div id="482" class="line none">  482  * do).</div><div id="483" class="line none">  483  *</div><div id="484" class="line none">  484  * @note There is an inherent race with this API: the system may</div><div id="485" class="line none">  485  * preempt the current thread and migrate it to another CPU before the</div><div id="486" class="line none">  486  * value is used.  Safe usage requires knowing the migration is</div><div id="487" class="line none">  487  * impossible (e.g. because the code is in interrupt context, holds a</div><div id="488" class="line none">  488  * spinlock, or cannot migrate due to k_cpu_mask state).</div><div id="489" class="line none">  489  *</div><div id="490" class="line none">  490  * @return Unique ID for currently-executing CPU</div><div id="491" class="line none">  491  */</div><div id="492" class="line none">  492 static inline uint32_t arch_proc_id(void);</div><div id="493" class="line none">  493 </div><div id="494" class="line none">  494 /**</div><div id="495" class="line none">  495  * Broadcast an interrupt to all CPUs</div><div id="496" class="line none">  496  *</div><div id="497" class="line none">  497  * This will invoke z_sched_ipi() on all other CPUs in the system.</div><div id="498" class="line none">  498  */</div><div id="499" class="line none">  499 void arch_sched_broadcast_ipi(void);</div><div id="500" class="line none">  500 </div><div id="501" class="line none">  501 /**</div><div id="502" class="line none">  502  * Direct IPIs to the specified CPUs</div><div id="503" class="line none">  503  *</div><div id="504" class="line none">  504  * This will invoke z_sched_ipi() on the CPUs identified by @a cpu_bitmap.</div><div id="505" class="line none">  505  *</div><div id="506" class="line none">  506  * @param cpu_bitmap A bitmap indicating which CPUs need the IPI</div><div id="507" class="line none">  507  */</div><div id="508" class="line none">  508 void arch_sched_directed_ipi(uint32_t cpu_bitmap);</div><div id="509" class="line none">  509 </div><div id="510" class="line none">  510 int arch_smp_init(void);</div><div id="511" class="line none">  511 </div><div id="512" class="line none">  512 #endif /* CONFIG_SMP */</div><div id="513" class="line none">  513 </div><div id="514" class="line none">  514 /**</div><div id="515" class="line none">  515  * @brief Returns the number of CPUs</div><div id="516" class="line none">  516  *</div><div id="517" class="line none">  517  * For most systems this will be the same as CONFIG_MP_MAX_NUM_CPUS,</div><div id="518" class="line none">  518  * however some systems may determine this at runtime instead.</div><div id="519" class="line none">  519  *</div><div id="520" class="line none">  520  * @return the number of CPUs</div><div id="521" class="line none">  521  */</div><div id="522" class="line none">  522 static inline unsigned int arch_num_cpus(void);</div><div id="523" class="line none">  523 </div><div id="524" class="line none">  524 /** @} */</div><div id="525" class="line none">  525 </div><div id="526" class="line none">  526 </div><div id="527" class="line none">  527 /**</div><div id="528" class="line none">  528  * @defgroup arch-userspace Architecture-specific userspace APIs</div><div id="529" class="line none">  529  * @ingroup arch-interface</div><div id="530" class="line none">  530  * @{</div><div id="531" class="line none">  531  */</div><div id="532" class="line none">  532 </div><div id="533" class="line none">  533 #ifdef CONFIG_USERSPACE</div><div id="534" class="line none">  534 #include &lt;zephyr/<a href="../kernel/thread.h.html#376">arch</a>/syscall.h&gt;</div><div id="535" class="line none">  535 </div><div id="536" class="line none">  536 /**</div><div id="537" class="line none">  537  * Invoke a system call with 0 arguments.</div><div id="538" class="line none">  538  *</div><div id="539" class="line none">  539  * No general-purpose register state other than return value may be preserved</div><div id="540" class="line none">  540  * when transitioning from supervisor mode back down to user mode for</div><div id="541" class="line none">  541  * security reasons.</div><div id="542" class="line none">  542  *</div><div id="543" class="line none">  543  * It is required that all arguments be stored in registers when elevating</div><div id="544" class="line none">  544  * privileges from user to supervisor mode.</div><div id="545" class="line none">  545  *</div><div id="546" class="line none">  546  * Processing of the syscall takes place on a separate kernel stack. Interrupts</div><div id="547" class="line none">  547  * should be enabled when invoking the system call marshallers from the</div><div id="548" class="line none">  548  * dispatch table. Thread preemption may occur when handling system calls.</div><div id="549" class="line none">  549  *</div><div id="550" class="line none">  550  * Call IDs are untrusted and must be bounds-checked, as the value is used to</div><div id="551" class="line none">  551  * index the system call dispatch table, containing function pointers to the</div><div id="552" class="line none">  552  * specific system call code.</div><div id="553" class="line none">  553  *</div><div id="554" class="line none">  554  * @param call_id System call ID</div><div id="555" class="line none">  555  * @return Return value of the system call. Void system calls return 0 here.</div><div id="556" class="line none">  556  */</div><div id="557" class="line none">  557 static inline uintptr_t arch_syscall_invoke0(uintptr_t call_id);</div><div id="558" class="line none">  558 </div><div id="559" class="line none">  559 /**</div><div id="560" class="line none">  560  * Invoke a system call with 1 argument.</div><div id="561" class="line none">  561  *</div><div id="562" class="line none">  562  * @see arch_syscall_invoke0()</div><div id="563" class="line none">  563  *</div><div id="564" class="line none">  564  * @param arg1 First argument to the system call.</div><div id="565" class="line none">  565  * @param call_id System call ID, will be bounds-checked and used to reference</div><div id="566" class="line none">  566  *                kernel-side dispatch table</div><div id="567" class="line none">  567  * @return Return value of the system call. Void system calls return 0 here.</div><div id="568" class="line none">  568  */</div><div id="569" class="line none">  569 static inline uintptr_t arch_syscall_invoke1(uintptr_t arg1,</div><div id="570" class="line none">  570                                              uintptr_t call_id);</div><div id="571" class="line none">  571 </div><div id="572" class="line none">  572 /**</div><div id="573" class="line none">  573  * Invoke a system call with 2 arguments.</div><div id="574" class="line none">  574  *</div><div id="575" class="line none">  575  * @see arch_syscall_invoke0()</div><div id="576" class="line none">  576  *</div><div id="577" class="line none">  577  * @param arg1 First argument to the system call.</div><div id="578" class="line none">  578  * @param arg2 Second argument to the system call.</div><div id="579" class="line none">  579  * @param call_id System call ID, will be bounds-checked and used to reference</div><div id="580" class="line none">  580  *                kernel-side dispatch table</div><div id="581" class="line none">  581  * @return Return value of the system call. Void system calls return 0 here.</div><div id="582" class="line none">  582  */</div><div id="583" class="line none">  583 static inline uintptr_t arch_syscall_invoke2(uintptr_t arg1, uintptr_t arg2,</div><div id="584" class="line none">  584                                              uintptr_t call_id);</div><div id="585" class="line none">  585 </div><div id="586" class="line none">  586 /**</div><div id="587" class="line none">  587  * Invoke a system call with 3 arguments.</div><div id="588" class="line none">  588  *</div><div id="589" class="line none">  589  * @see arch_syscall_invoke0()</div><div id="590" class="line none">  590  *</div><div id="591" class="line none">  591  * @param arg1 First argument to the system call.</div><div id="592" class="line none">  592  * @param arg2 Second argument to the system call.</div><div id="593" class="line none">  593  * @param arg3 Third argument to the system call.</div><div id="594" class="line none">  594  * @param call_id System call ID, will be bounds-checked and used to reference</div><div id="595" class="line none">  595  *                kernel-side dispatch table</div><div id="596" class="line none">  596  * @return Return value of the system call. Void system calls return 0 here.</div><div id="597" class="line none">  597  */</div><div id="598" class="line none">  598 static inline uintptr_t arch_syscall_invoke3(uintptr_t arg1, uintptr_t arg2,</div><div id="599" class="line none">  599                                              uintptr_t arg3,</div><div id="600" class="line none">  600                                              uintptr_t call_id);</div><div id="601" class="line none">  601 </div><div id="602" class="line none">  602 /**</div><div id="603" class="line none">  603  * Invoke a system call with 4 arguments.</div><div id="604" class="line none">  604  *</div><div id="605" class="line none">  605  * @see arch_syscall_invoke0()</div><div id="606" class="line none">  606  *</div><div id="607" class="line none">  607  * @param arg1 First argument to the system call.</div><div id="608" class="line none">  608  * @param arg2 Second argument to the system call.</div><div id="609" class="line none">  609  * @param arg3 Third argument to the system call.</div><div id="610" class="line none">  610  * @param arg4 Fourth argument to the system call.</div><div id="611" class="line none">  611  * @param call_id System call ID, will be bounds-checked and used to reference</div><div id="612" class="line none">  612  *                kernel-side dispatch table</div><div id="613" class="line none">  613  * @return Return value of the system call. Void system calls return 0 here.</div><div id="614" class="line none">  614  */</div><div id="615" class="line none">  615 static inline uintptr_t arch_syscall_invoke4(uintptr_t arg1, uintptr_t arg2,</div><div id="616" class="line none">  616                                              uintptr_t arg3, uintptr_t arg4,</div><div id="617" class="line none">  617                                              uintptr_t call_id);</div><div id="618" class="line none">  618 </div><div id="619" class="line none">  619 /**</div><div id="620" class="line none">  620  * Invoke a system call with 5 arguments.</div><div id="621" class="line none">  621  *</div><div id="622" class="line none">  622  * @see arch_syscall_invoke0()</div><div id="623" class="line none">  623  *</div><div id="624" class="line none">  624  * @param arg1 First argument to the system call.</div><div id="625" class="line none">  625  * @param arg2 Second argument to the system call.</div><div id="626" class="line none">  626  * @param arg3 Third argument to the system call.</div><div id="627" class="line none">  627  * @param arg4 Fourth argument to the system call.</div><div id="628" class="line none">  628  * @param arg5 Fifth argument to the system call.</div><div id="629" class="line none">  629  * @param call_id System call ID, will be bounds-checked and used to reference</div><div id="630" class="line none">  630  *                kernel-side dispatch table</div><div id="631" class="line none">  631  * @return Return value of the system call. Void system calls return 0 here.</div><div id="632" class="line none">  632  */</div><div id="633" class="line none">  633 static inline uintptr_t arch_syscall_invoke5(uintptr_t arg1, uintptr_t arg2,</div><div id="634" class="line none">  634                                              uintptr_t arg3, uintptr_t arg4,</div><div id="635" class="line none">  635                                              uintptr_t arg5,</div><div id="636" class="line none">  636                                              uintptr_t call_id);</div><div id="637" class="line none">  637 </div><div id="638" class="line none">  638 /**</div><div id="639" class="line none">  639  * Invoke a system call with 6 arguments.</div><div id="640" class="line none">  640  *</div><div id="641" class="line none">  641  * @see arch_syscall_invoke0()</div><div id="642" class="line none">  642  *</div><div id="643" class="line none">  643  * @param arg1 First argument to the system call.</div><div id="644" class="line none">  644  * @param arg2 Second argument to the system call.</div><div id="645" class="line none">  645  * @param arg3 Third argument to the system call.</div><div id="646" class="line none">  646  * @param arg4 Fourth argument to the system call.</div><div id="647" class="line none">  647  * @param arg5 Fifth argument to the system call.</div><div id="648" class="line none">  648  * @param arg6 Sixth argument to the system call.</div><div id="649" class="line none">  649  * @param call_id System call ID, will be bounds-checked and used to reference</div><div id="650" class="line none">  650  *                kernel-side dispatch table</div><div id="651" class="line none">  651  * @return Return value of the system call. Void system calls return 0 here.</div><div id="652" class="line none">  652  */</div><div id="653" class="line none">  653 static inline uintptr_t arch_syscall_invoke6(uintptr_t arg1, uintptr_t arg2,</div><div id="654" class="line none">  654                                              uintptr_t arg3, uintptr_t arg4,</div><div id="655" class="line none">  655                                              uintptr_t arg5, uintptr_t arg6,</div><div id="656" class="line none">  656                                              uintptr_t call_id);</div><div id="657" class="line none">  657 </div><div id="658" class="line none">  658 /**</div><div id="659" class="line none">  659  * Indicate whether we are currently running in user mode</div><div id="660" class="line none">  660  *</div><div id="661" class="line none">  661  * @return True if the CPU is currently running with user permissions</div><div id="662" class="line none">  662  */</div><div id="663" class="line none">  663 static inline bool arch_is_user_context(void);</div><div id="664" class="line none">  664 </div><div id="665" class="line none">  665 /**</div><div id="666" class="line none">  666  * @brief Get the maximum number of partitions for a memory domain</div><div id="667" class="line none">  667  *</div><div id="668" class="line none">  668  * @return Max number of partitions, or -1 if there is no limit</div><div id="669" class="line none">  669  */</div><div id="670" class="line none">  670 int arch_mem_domain_max_partitions_get(void);</div><div id="671" class="line none">  671 </div><div id="672" class="line none">  672 #ifdef CONFIG_ARCH_MEM_DOMAIN_DATA</div><div id="673" class="line none">  673 /**</div><div id="674" class="line none">  674  *</div><div id="675" class="line none">  675  * @brief Architecture-specific hook for memory domain initialization</div><div id="676" class="line none">  676  *</div><div id="677" class="line none">  677  * Perform any tasks needed to initialize architecture-specific data within</div><div id="678" class="line none">  678  * the memory domain, such as reserving memory for page tables. All members</div><div id="679" class="line none">  679  * of the provided memory domain aside from `arch` will be initialized when</div><div id="680" class="line none">  680  * this is called, but no threads will be a assigned yet.</div><div id="681" class="line none">  681  *</div><div id="682" class="line none">  682  * This function may fail if initializing the memory domain requires allocation,</div><div id="683" class="line none">  683  * such as for page tables.</div><div id="684" class="line none">  684  *</div><div id="685" class="line none">  685  * The associated function k_mem_domain_init() documents that making</div><div id="686" class="line none">  686  * multiple init calls to the same memory domain is undefined behavior,</div><div id="687" class="line none">  687  * but has no assertions in place to check this. If this matters, it may be</div><div id="688" class="line none">  688  * desirable to add checks for this in the implementation of this function.</div><div id="689" class="line none">  689  *</div><div id="690" class="line none">  690  * @param domain The memory domain to initialize</div><div id="691" class="line none">  691  * @retval 0 Success</div><div id="692" class="line none">  692  * @retval -ENOMEM Insufficient memory</div><div id="693" class="line none">  693  */</div><div id="694" class="line none">  694 int arch_mem_domain_init(struct k_mem_domain *<a href="../logging/log_msg.h.html#58">domain</a>);</div><div id="695" class="line none">  695 #endif /* CONFIG_ARCH_MEM_DOMAIN_DATA */</div><div id="696" class="line none">  696 </div><div id="697" class="line none">  697 #ifdef CONFIG_ARCH_MEM_DOMAIN_SYNCHRONOUS_API</div><div id="698" class="line none">  698 /**</div><div id="699" class="line none">  699  * @brief Add a thread to a memory domain (arch-specific)</div><div id="700" class="line none">  700  *</div><div id="701" class="line none">  701  * Architecture-specific hook to manage internal data structures or hardware</div><div id="702" class="line none">  702  * state when the provided thread has been added to a memory domain.</div><div id="703" class="line none">  703  *</div><div id="704" class="line none">  704  * The thread-&gt;mem_domain_info.mem_domain pointer will be set to the domain to</div><div id="705" class="line none">  705  * be added to before this is called. Implementations may assume that the</div><div id="706" class="line none">  706  * thread is not already a member of this domain.</div><div id="707" class="line none">  707  *</div><div id="708" class="line none">  708  * @param thread Thread which needs to be configured.</div><div id="709" class="line none">  709  *</div><div id="710" class="line none">  710  * @retval 0 if successful</div><div id="711" class="line none">  711  * @retval -EINVAL if invalid parameters supplied</div><div id="712" class="line none">  712  * @retval -ENOSPC if running out of space in internal structures</div><div id="713" class="line none">  713  *                    (e.g. translation tables)</div><div id="714" class="line none">  714  */</div><div id="715" class="line none">  715 int arch_mem_domain_thread_add(struct <a href="arch_interface.h.html#43">k_thread</a> *<a href="../kernel.h.html#4031">thread</a>);</div><div id="716" class="line none">  716 </div><div id="717" class="line none">  717 /**</div><div id="718" class="line none">  718  * @brief Remove a thread from a memory domain (arch-specific)</div><div id="719" class="line none">  719  *</div><div id="720" class="line none">  720  * Architecture-specific hook to manage internal data structures or hardware</div><div id="721" class="line none">  721  * state when the provided thread has been removed from a memory domain.</div><div id="722" class="line none">  722  *</div><div id="723" class="line none">  723  * The thread's memory domain pointer will be the domain that the thread</div><div id="724" class="line none">  724  * is being removed from.</div><div id="725" class="line none">  725  *</div><div id="726" class="line none">  726  * @param thread Thread being removed from its memory domain</div><div id="727" class="line none">  727  *</div><div id="728" class="line none">  728  * @retval 0 if successful</div><div id="729" class="line none">  729  * @retval -EINVAL if invalid parameters supplied</div><div id="730" class="line none">  730  */</div><div id="731" class="line none">  731 int arch_mem_domain_thread_remove(struct <a href="arch_interface.h.html#43">k_thread</a> *<a href="../kernel.h.html#4031">thread</a>);</div><div id="732" class="line none">  732 </div><div id="733" class="line none">  733 /**</div><div id="734" class="line none">  734  * @brief Remove a partition from the memory domain (arch-specific)</div><div id="735" class="line none">  735  *</div><div id="736" class="line none">  736  * Architecture-specific hook to manage internal data structures or hardware</div><div id="737" class="line none">  737  * state when a memory domain has had a partition removed.</div><div id="738" class="line none">  738  *</div><div id="739" class="line none">  739  * The partition index data, and the number of partitions configured, are not</div><div id="740" class="line none">  740  * respectively cleared and decremented in the domain until after this function</div><div id="741" class="line none">  741  * runs.</div><div id="742" class="line none">  742  *</div><div id="743" class="line none">  743  * @param domain The memory domain structure</div><div id="744" class="line none">  744  * @param partition_id The partition index that needs to be deleted</div><div id="745" class="line none">  745  *</div><div id="746" class="line none">  746  * @retval 0 if successful</div><div id="747" class="line none">  747  * @retval -EINVAL if invalid parameters supplied</div><div id="748" class="line none">  748  * @retval -ENOENT if no matching partition found</div><div id="749" class="line none">  749  */</div><div id="750" class="line none">  750 int arch_mem_domain_partition_remove(struct k_mem_domain *<a href="../logging/log_msg.h.html#58">domain</a>,</div><div id="751" class="line none">  751                                      uint32_t partition_id);</div><div id="752" class="line none">  752 </div><div id="753" class="line none">  753 /**</div><div id="754" class="line none">  754  * @brief Add a partition to the memory domain</div><div id="755" class="line none">  755  *</div><div id="756" class="line none">  756  * Architecture-specific hook to manage internal data structures or hardware</div><div id="757" class="line none">  757  * state when a memory domain has a partition added.</div><div id="758" class="line none">  758  *</div><div id="759" class="line none">  759  * @param domain The memory domain structure</div><div id="760" class="line none">  760  * @param partition_id The partition that needs to be added</div><div id="761" class="line none">  761  *</div><div id="762" class="line none">  762  * @retval 0 if successful</div><div id="763" class="line none">  763  * @retval -EINVAL if invalid parameters supplied</div><div id="764" class="line none">  764  */</div><div id="765" class="line none">  765 int arch_mem_domain_partition_add(struct k_mem_domain *<a href="../logging/log_msg.h.html#58">domain</a>,</div><div id="766" class="line none">  766                                   uint32_t partition_id);</div><div id="767" class="line none">  767 #endif /* CONFIG_ARCH_MEM_DOMAIN_SYNCHRONOUS_API */</div><div id="768" class="line none">  768 </div><div id="769" class="line none">  769 /**</div><div id="770" class="line none">  770  * @brief Check memory region permissions</div><div id="771" class="line none">  771  *</div><div id="772" class="line none">  772  * Given a memory region, return whether the current memory management hardware</div><div id="773" class="line none">  773  * configuration would allow a user thread to read/write that region. Used by</div><div id="774" class="line none">  774  * system calls to validate buffers coming in from userspace.</div><div id="775" class="line none">  775  *</div><div id="776" class="line none">  776  * Notes:</div><div id="777" class="line none">  777  * The function is guaranteed to never return validation success, if the entire</div><div id="778" class="line none">  778  * buffer area is not user accessible.</div><div id="779" class="line none">  779  *</div><div id="780" class="line none">  780  * The function is guaranteed to correctly validate the permissions of the</div><div id="781" class="line none">  781  * supplied buffer, if the user access permissions of the entire buffer are</div><div id="782" class="line none">  782  * enforced by a single, enabled memory management region.</div><div id="783" class="line none">  783  *</div><div id="784" class="line none">  784  * In some architectures the validation will always return failure</div><div id="785" class="line none">  785  * if the supplied memory buffer spans multiple enabled memory management</div><div id="786" class="line none">  786  * regions (even if all such regions permit user access).</div><div id="787" class="line none">  787  *</div><div id="788" class="line none">  788  * @warning Buffer of size zero (0) has undefined behavior.</div><div id="789" class="line none">  789  *</div><div id="790" class="line none">  790  * @param addr start address of the buffer</div><div id="791" class="line none">  791  * @param size the size of the buffer</div><div id="792" class="line none">  792  * @param write If non-zero, additionally check if the area is writable.</div><div id="793" class="line none">  793  *        Otherwise, just check if the memory can be read.</div><div id="794" class="line none">  794  *</div><div id="795" class="line none">  795  * @return nonzero if the permissions don't match.</div><div id="796" class="line none">  796  */</div><div id="797" class="line none">  797 int arch_buffer_validate(const void *<a href="../kernel/thread.h.html#178">addr</a>, size_t <a href="../kernel.h.html#4716">size</a>, int write);</div><div id="798" class="line none">  798 </div><div id="799" class="line none">  799 /**</div><div id="800" class="line none">  800  * Get the optimal virtual region alignment to optimize the MMU table layout</div><div id="801" class="line none">  801  *</div><div id="802" class="line none">  802  * Some MMU HW requires some region to be aligned to some of the intermediate</div><div id="803" class="line none">  803  * block alignment in order to reduce table usage.</div><div id="804" class="line none">  804  * This call returns the optimal virtual address alignment in order to permit</div><div id="805" class="line none">  805  * such optimization in the following MMU mapping call.</div><div id="806" class="line none">  806  *</div><div id="807" class="line none">  807  * @param[in] phys Physical address of region to be mapped,</div><div id="808" class="line none">  808  *                 aligned to @kconfig{CONFIG_MMU_PAGE_SIZE}</div><div id="809" class="line none">  809  * @param[in] size Size of region to be mapped,</div><div id="810" class="line none">  810  *                 aligned to @kconfig{CONFIG_MMU_PAGE_SIZE}</div><div id="811" class="line none">  811  *</div><div id="812" class="line none">  812  * @return Alignment to apply on the virtual address of this region</div><div id="813" class="line none">  813  */</div><div id="814" class="line none">  814 size_t arch_virt_region_align(uintptr_t phys, size_t <a href="../kernel.h.html#4716">size</a>);</div><div id="815" class="line none">  815 </div><div id="816" class="line none">  816 /**</div><div id="817" class="line none">  817  * Perform a one-way transition from supervisor to user mode.</div><div id="818" class="line none">  818  *</div><div id="819" class="line none">  819  * Implementations of this function must do the following:</div><div id="820" class="line none">  820  *</div><div id="821" class="line none">  821  * - Reset the thread's stack pointer to a suitable initial value. We do not</div><div id="822" class="line none">  822  *   need any prior context since this is a one-way operation.</div><div id="823" class="line none">  823  * - Set up any kernel stack region for the CPU to use during privilege</div><div id="824" class="line none">  824  *   elevation</div><div id="825" class="line none">  825  * - Put the CPU in whatever its equivalent of user mode is</div><div id="826" class="line none">  826  * - Transfer execution to arch_new_thread() passing along all the supplied</div><div id="827" class="line none">  827  *   arguments, in user mode.</div><div id="828" class="line none">  828  *</div><div id="829" class="line none">  829  * @param user_entry Entry point to start executing as a user thread</div><div id="830" class="line none">  830  * @param p1 1st parameter to user thread</div><div id="831" class="line none">  831  * @param p2 2nd parameter to user thread</div><div id="832" class="line none">  832  * @param p3 3rd parameter to user thread</div><div id="833" class="line none">  833  */</div><div id="834" class="line none">  834 FUNC_NORETURN void arch_user_mode_enter(<a href="arch_interface.h.html#48">k_thread_entry_t</a> user_entry,</div><div id="835" class="line none">  835                                         void *p1, void *p2, void *p3);</div><div id="836" class="line none">  836 </div><div id="837" class="line none">  837 /**</div><div id="838" class="line none">  838  * @brief Induce a kernel oops that appears to come from a specific location</div><div id="839" class="line none">  839  *</div><div id="840" class="line none">  840  * Normally, k_oops() generates an exception that appears to come from the</div><div id="841" class="line none">  841  * call site of the k_oops() itself.</div><div id="842" class="line none">  842  *</div><div id="843" class="line none">  843  * However, when validating arguments to a system call, if there are problems</div><div id="844" class="line none">  844  * we want the oops to appear to come from where the system call was invoked</div><div id="845" class="line none">  845  * and not inside the validation function.</div><div id="846" class="line none">  846  *</div><div id="847" class="line none">  847  * @param ssf System call stack frame pointer. This gets passed as an argument</div><div id="848" class="line none">  848  *            to _k_syscall_handler_t functions and its contents are completely</div><div id="849" class="line none">  849  *            architecture specific.</div><div id="850" class="line none">  850  */</div><div id="851" class="line none">  851 FUNC_NORETURN void arch_syscall_oops(void *ssf);</div><div id="852" class="line none">  852 </div><div id="853" class="line none">  853 /**</div><div id="854" class="line none">  854  * @brief Safely take the length of a potentially bad string</div><div id="855" class="line none">  855  *</div><div id="856" class="line none">  856  * This must not fault, instead the @p err parameter must have -1 written to it.</div><div id="857" class="line none">  857  * This function otherwise should work exactly like libc strnlen(). On success</div><div id="858" class="line none">  858  * @p err should be set to 0.</div><div id="859" class="line none">  859  *</div><div id="860" class="line none">  860  * @param s String to measure</div><div id="861" class="line none">  861  * @param maxsize Max length of the string</div><div id="862" class="line none">  862  * @param err Error value to write</div><div id="863" class="line none">  863  * @return Length of the string, not counting NULL byte, up to maxsize</div><div id="864" class="line none">  864  */</div><div id="865" class="line none">  865 size_t arch_user_string_nlen(const char *s, size_t maxsize, int *err);</div><div id="866" class="line none">  866 #endif /* CONFIG_USERSPACE */</div><div id="867" class="line none">  867 </div><div id="868" class="line none">  868 /**</div><div id="869" class="line none">  869  * @brief Detect memory coherence type</div><div id="870" class="line none">  870  *</div><div id="871" class="line none">  871  * Required when ARCH_HAS_COHERENCE is true.  This function returns</div><div id="872" class="line none">  872  * true if the byte pointed to lies within an architecture-defined</div><div id="873" class="line none">  873  * "coherence region" (typically implemented with uncached memory) and</div><div id="874" class="line none">  874  * can safely be used in multiprocessor code without explicit flush or</div><div id="875" class="line none">  875  * invalidate operations.</div><div id="876" class="line none">  876  *</div><div id="877" class="line none">  877  * @note The result is for only the single byte at the specified</div><div id="878" class="line none">  878  * address, this API is not required to check region boundaries or to</div><div id="879" class="line none">  879  * expect aligned pointers.  The expectation is that the code above</div><div id="880" class="line none">  880  * will have queried the appropriate address(es).</div><div id="881" class="line none">  881  */</div><div id="882" class="line none">  882 #ifndef CONFIG_ARCH_HAS_COHERENCE</div><div id="883" class="line none">  883 static inline bool <a href="arch_interface.h.html#883">arch_mem_coherent</a>(void *ptr)</div><div id="884" class="line none">  884 {</div><div id="885" class="line none">  885         ARG_UNUSED(ptr);</div><div id="886" class="line none">  886         return true;</div><div id="887" class="line none">  887 }</div><div id="888" class="line none">  888 #endif</div><div id="889" class="line none">  889 </div><div id="890" class="line none">  890 /**</div><div id="891" class="line none">  891  * @brief Ensure cache coherence prior to context switch</div><div id="892" class="line none">  892  *</div><div id="893" class="line none">  893  * Required when ARCH_HAS_COHERENCE is true.  On cache-incoherent</div><div id="894" class="line none">  894  * multiprocessor architectures, thread stacks are cached by default</div><div id="895" class="line none">  895  * for performance reasons.  They must therefore be flushed</div><div id="896" class="line none">  896  * appropriately on context switch.  The rules are:</div><div id="897" class="line none">  897  *</div><div id="898" class="line none">  898  * 1. The region containing live data in the old stack (generally the</div><div id="899" class="line none">  899  *    bytes between the current stack pointer and the top of the stack</div><div id="900" class="line none">  900  *    memory) must be flushed to underlying storage so a new CPU that</div><div id="901" class="line none">  901  *    runs the same thread sees the correct data.  This must happen</div><div id="902" class="line none">  902  *    before the assignment of the switch_handle field in the thread</div><div id="903" class="line none">  903  *    struct which signals the completion of context switch.</div><div id="904" class="line none">  904  *</div><div id="905" class="line none">  905  * 2. Any data areas to be read from the new stack (generally the same</div><div id="906" class="line none">  906  *    as the live region when it was saved) should be invalidated (and</div><div id="907" class="line none">  907  *    NOT flushed!) in the data cache.  This is because another CPU</div><div id="908" class="line none">  908  *    may have run or re-initialized the thread since this CPU</div><div id="909" class="line none">  909  *    suspended it, and any data present in cache will be stale.</div><div id="910" class="line none">  910  *</div><div id="911" class="line none">  911  * @note The kernel will call this function during interrupt exit when</div><div id="912" class="line none">  912  * a new thread has been chosen to run, and also immediately before</div><div id="913" class="line none">  913  * entering arch_switch() to effect a code-driven context switch.  In</div><div id="914" class="line none">  914  * the latter case, it is very likely that more data will be written</div><div id="915" class="line none">  915  * to the old_thread stack region after this function returns but</div><div id="916" class="line none">  916  * before the completion of the switch.  Simply flushing naively here</div><div id="917" class="line none">  917  * is not sufficient on many architectures and coordination with the</div><div id="918" class="line none">  918  * arch_switch() implementation is likely required.</div><div id="919" class="line none">  919  *</div><div id="920" class="line none">  920  * @param old_thread The old thread to be flushed before being allowed</div><div id="921" class="line none">  921  *                   to run on other CPUs.</div><div id="922" class="line none">  922  * @param old_switch_handle The switch handle to be stored into</div><div id="923" class="line none">  923  *                          old_thread (it will not be valid until the</div><div id="924" class="line none">  924  *                          cache is flushed so is not present yet).</div><div id="925" class="line none">  925  *                          This will be NULL if inside z_swap()</div><div id="926" class="line none">  926  *                          (because the arch_switch() has not saved it</div><div id="927" class="line none">  927  *                          yet).</div><div id="928" class="line none">  928  * @param new_thread The new thread to be invalidated before it runs locally.</div><div id="929" class="line none">  929  */</div><div id="930" class="line none">  930 #ifndef CONFIG_KERNEL_COHERENCE</div><div id="931" class="line none">  931 static inline void <a href="arch_interface.h.html#931">arch_cohere_stacks</a>(struct <a href="arch_interface.h.html#43">k_thread</a> *old_thread,</div><div id="932" class="line none">  932                                       void *old_switch_handle,</div><div id="933" class="line none">  933                                       struct <a href="arch_interface.h.html#43">k_thread</a> *new_thread)</div><div id="934" class="line none">  934 {</div><div id="935" class="line none">  935         ARG_UNUSED(old_thread);</div><div id="936" class="line none">  936         ARG_UNUSED(old_switch_handle);</div><div id="937" class="line none">  937         ARG_UNUSED(new_thread);</div><div id="938" class="line none">  938 }</div><div id="939" class="line none">  939 #endif</div><div id="940" class="line none">  940 </div><div id="941" class="line none">  941 /** @} */</div><div id="942" class="line none">  942 </div><div id="943" class="line none">  943 /**</div><div id="944" class="line none">  944  * @defgroup arch-gdbstub Architecture-specific gdbstub APIs</div><div id="945" class="line none">  945  * @ingroup arch-interface</div><div id="946" class="line none">  946  * @{</div><div id="947" class="line none">  947  */</div><div id="948" class="line none">  948 </div><div id="949" class="line none">  949 #ifdef CONFIG_GDBSTUB</div><div id="950" class="line none">  950 struct gdb_ctx;</div><div id="951" class="line none">  951 </div><div id="952" class="line none">  952 /**</div><div id="953" class="line none">  953  * @brief Architecture layer debug start</div><div id="954" class="line none">  954  *</div><div id="955" class="line none">  955  * This function is called by @c gdb_init()</div><div id="956" class="line none">  956  */</div><div id="957" class="line none">  957 void arch_gdb_init(void);</div><div id="958" class="line none">  958 </div><div id="959" class="line none">  959 /**</div><div id="960" class="line none">  960  * @brief Continue running program</div><div id="961" class="line none">  961  *</div><div id="962" class="line none">  962  * Continue software execution.</div><div id="963" class="line none">  963  */</div><div id="964" class="line none">  964 void arch_gdb_continue(void);</div><div id="965" class="line none">  965 </div><div id="966" class="line none">  966 /**</div><div id="967" class="line none">  967  * @brief Continue with one step</div><div id="968" class="line none">  968  *</div><div id="969" class="line none">  969  * Continue software execution until reaches the next statement.</div><div id="970" class="line none">  970  */</div><div id="971" class="line none">  971 void arch_gdb_step(void);</div><div id="972" class="line none">  972 </div><div id="973" class="line none">  973 /**</div><div id="974" class="line none">  974  * @brief Read all registers, and outputs as hexadecimal string.</div><div id="975" class="line none">  975  *</div><div id="976" class="line none">  976  * This reads all CPU registers and outputs as hexadecimal string.</div><div id="977" class="line none">  977  * The output string must be parsable by GDB.</div><div id="978" class="line none">  978  *</div><div id="979" class="line none">  979  * @param ctx    GDB context</div><div id="980" class="line none">  980  * @param buf    Buffer to output hexadecimal string.</div><div id="981" class="line none">  981  * @param buflen Length of buffer.</div><div id="982" class="line none">  982  *</div><div id="983" class="line none">  983  * @return Length of hexadecimal string written.</div><div id="984" class="line none">  984  *         Return 0 if error or not supported.</div><div id="985" class="line none">  985  */</div><div id="986" class="line none">  986 size_t arch_gdb_reg_readall(struct gdb_ctx *ctx, uint8_t *<a href="../logging/log_msg.h.html#118">buf</a>, size_t buflen);</div><div id="987" class="line none">  987 </div><div id="988" class="line none">  988 /**</div><div id="989" class="line none">  989  * @brief Take a hexadecimal string and update all registers.</div><div id="990" class="line none">  990  *</div><div id="991" class="line none">  991  * This takes in a hexadecimal string as presented from GDB,</div><div id="992" class="line none">  992  * and updates all CPU registers with new values.</div><div id="993" class="line none">  993  *</div><div id="994" class="line none">  994  * @param ctx    GDB context</div><div id="995" class="line none">  995  * @param hex    Input hexadecimal string.</div><div id="996" class="line none">  996  * @param hexlen Length of hexadecimal string.</div><div id="997" class="line none">  997  *</div><div id="998" class="line none">  998  * @return Length of hexadecimal string parsed.</div><div id="999" class="line none">  999  *         Return 0 if error or not supported.</div><div id="1000" class="line none"> 1000  */</div><div id="1001" class="line none"> 1001 size_t arch_gdb_reg_writeall(struct gdb_ctx *ctx, uint8_t *hex, size_t hexlen);</div><div id="1002" class="line none"> 1002 </div><div id="1003" class="line none"> 1003 /**</div><div id="1004" class="line none"> 1004  * @brief Read one register, and outputs as hexadecimal string.</div><div id="1005" class="line none"> 1005  *</div><div id="1006" class="line none"> 1006  * This reads one CPU register and outputs as hexadecimal string.</div><div id="1007" class="line none"> 1007  * The output string must be parsable by GDB.</div><div id="1008" class="line none"> 1008  *</div><div id="1009" class="line none"> 1009  * @param ctx    GDB context</div><div id="1010" class="line none"> 1010  * @param buf    Buffer to output hexadecimal string.</div><div id="1011" class="line none"> 1011  * @param buflen Length of buffer.</div><div id="1012" class="line none"> 1012  * @param regno  Register number</div><div id="1013" class="line none"> 1013  *</div><div id="1014" class="line none"> 1014  * @return Length of hexadecimal string written.</div><div id="1015" class="line none"> 1015  *         Return 0 if error or not supported.</div><div id="1016" class="line none"> 1016  */</div><div id="1017" class="line none"> 1017 size_t arch_gdb_reg_readone(struct gdb_ctx *ctx, uint8_t *<a href="../logging/log_msg.h.html#118">buf</a>, size_t buflen,</div><div id="1018" class="line none"> 1018                             uint32_t regno);</div><div id="1019" class="line none"> 1019 </div><div id="1020" class="line none"> 1020 /**</div><div id="1021" class="line none"> 1021  * @brief Take a hexadecimal string and update one register.</div><div id="1022" class="line none"> 1022  *</div><div id="1023" class="line none"> 1023  * This takes in a hexadecimal string as presented from GDB,</div><div id="1024" class="line none"> 1024  * and updates one CPU registers with new value.</div><div id="1025" class="line none"> 1025  *</div><div id="1026" class="line none"> 1026  * @param ctx    GDB context</div><div id="1027" class="line none"> 1027  * @param hex    Input hexadecimal string.</div><div id="1028" class="line none"> 1028  * @param hexlen Length of hexadecimal string.</div><div id="1029" class="line none"> 1029  * @param regno  Register number</div><div id="1030" class="line none"> 1030  *</div><div id="1031" class="line none"> 1031  * @return Length of hexadecimal string parsed.</div><div id="1032" class="line none"> 1032  *         Return 0 if error or not supported.</div><div id="1033" class="line none"> 1033  */</div><div id="1034" class="line none"> 1034 size_t arch_gdb_reg_writeone(struct gdb_ctx *ctx, uint8_t *hex, size_t hexlen,</div><div id="1035" class="line none"> 1035                              uint32_t regno);</div><div id="1036" class="line none"> 1036 </div><div id="1037" class="line none"> 1037 /**</div><div id="1038" class="line none"> 1038  * @brief Add breakpoint or watchpoint.</div><div id="1039" class="line none"> 1039  *</div><div id="1040" class="line none"> 1040  * @param ctx GDB context</div><div id="1041" class="line none"> 1041  * @param type Breakpoint or watchpoint type</div><div id="1042" class="line none"> 1042  * @param addr Address of breakpoint or watchpoint</div><div id="1043" class="line none"> 1043  * @param kind Size of breakpoint/watchpoint in bytes</div><div id="1044" class="line none"> 1044  *</div><div id="1045" class="line none"> 1045  * @retval 0  Operation successful</div><div id="1046" class="line none"> 1046  * @retval -1 Error encountered</div><div id="1047" class="line none"> 1047  * @retval -2 Not supported</div><div id="1048" class="line none"> 1048  */</div><div id="1049" class="line none"> 1049 int arch_gdb_add_breakpoint(struct gdb_ctx *ctx, uint8_t <a href="../kernel.h.html#5723">type</a>,</div><div id="1050" class="line none"> 1050                             uintptr_t <a href="../kernel/thread.h.html#178">addr</a>, uint32_t kind);</div><div id="1051" class="line none"> 1051 </div><div id="1052" class="line none"> 1052 /**</div><div id="1053" class="line none"> 1053  * @brief Remove breakpoint or watchpoint.</div><div id="1054" class="line none"> 1054  *</div><div id="1055" class="line none"> 1055  * @param ctx GDB context</div><div id="1056" class="line none"> 1056  * @param type Breakpoint or watchpoint type</div><div id="1057" class="line none"> 1057  * @param addr Address of breakpoint or watchpoint</div><div id="1058" class="line none"> 1058  * @param kind Size of breakpoint/watchpoint in bytes</div><div id="1059" class="line none"> 1059  *</div><div id="1060" class="line none"> 1060  * @retval 0  Operation successful</div><div id="1061" class="line none"> 1061  * @retval -1 Error encountered</div><div id="1062" class="line none"> 1062  * @retval -2 Not supported</div><div id="1063" class="line none"> 1063  */</div><div id="1064" class="line none"> 1064 int arch_gdb_remove_breakpoint(struct gdb_ctx *ctx, uint8_t <a href="../kernel.h.html#5723">type</a>,</div><div id="1065" class="line none"> 1065                                uintptr_t <a href="../kernel/thread.h.html#178">addr</a>, uint32_t kind);</div><div id="1066" class="line none"> 1066 </div><div id="1067" class="line none"> 1067 #endif</div><div id="1068" class="line none"> 1068 /** @} */</div><div id="1069" class="line none"> 1069 </div><div id="1070" class="line none"> 1070 #ifdef CONFIG_TIMING_FUNCTIONS</div><div id="1071" class="line none"> 1071 #include &lt;zephyr/timing/types.h&gt;</div><div id="1072" class="line none"> 1072 </div><div id="1073" class="line none"> 1073 /**</div><div id="1074" class="line none"> 1074  * @brief Arch specific Timing Measurement APIs</div><div id="1075" class="line none"> 1075  * @defgroup timing_api_arch Arch specific Timing Measurement APIs</div><div id="1076" class="line none"> 1076  * @ingroup timing_api</div><div id="1077" class="line none"> 1077  *</div><div id="1078" class="line none"> 1078  * Implements the necessary bits to support timing measurement</div><div id="1079" class="line none"> 1079  * using architecture specific timing measurement mechanism.</div><div id="1080" class="line none"> 1080  *</div><div id="1081" class="line none"> 1081  * @{</div><div id="1082" class="line none"> 1082  */</div><div id="1083" class="line none"> 1083 </div><div id="1084" class="line none"> 1084 /**</div><div id="1085" class="line none"> 1085  * @brief Initialize the timing subsystem.</div><div id="1086" class="line none"> 1086  *</div><div id="1087" class="line none"> 1087  * Perform the necessary steps to initialize the timing subsystem.</div><div id="1088" class="line none"> 1088  *</div><div id="1089" class="line none"> 1089  * @see timing_init()</div><div id="1090" class="line none"> 1090  */</div><div id="1091" class="line none"> 1091 void arch_timing_init(void);</div><div id="1092" class="line none"> 1092 </div><div id="1093" class="line none"> 1093 /**</div><div id="1094" class="line none"> 1094  * @brief Signal the start of the timing information gathering.</div><div id="1095" class="line none"> 1095  *</div><div id="1096" class="line none"> 1096  * Signal to the timing subsystem that timing information</div><div id="1097" class="line none"> 1097  * will be gathered from this point forward.</div><div id="1098" class="line none"> 1098  *</div><div id="1099" class="line none"> 1099  * @note Any call to arch_timing_counter_get() must be done between</div><div id="1100" class="line none"> 1100  * calls to arch_timing_start() and arch_timing_stop(), and on the</div><div id="1101" class="line none"> 1101  * same CPU core.</div><div id="1102" class="line none"> 1102  *</div><div id="1103" class="line none"> 1103  * @see timing_start()</div><div id="1104" class="line none"> 1104  */</div><div id="1105" class="line none"> 1105 void arch_timing_start(void);</div><div id="1106" class="line none"> 1106 </div><div id="1107" class="line none"> 1107 /**</div><div id="1108" class="line none"> 1108  * @brief Signal the end of the timing information gathering.</div><div id="1109" class="line none"> 1109  *</div><div id="1110" class="line none"> 1110  * Signal to the timing subsystem that timing information</div><div id="1111" class="line none"> 1111  * is no longer being gathered from this point forward.</div><div id="1112" class="line none"> 1112  *</div><div id="1113" class="line none"> 1113  * @note Any call to arch_timing_counter_get() must be done between</div><div id="1114" class="line none"> 1114  * calls to arch_timing_start() and arch_timing_stop(), and on the</div><div id="1115" class="line none"> 1115  * same CPU core.</div><div id="1116" class="line none"> 1116  *</div><div id="1117" class="line none"> 1117  * @see timing_stop()</div><div id="1118" class="line none"> 1118  */</div><div id="1119" class="line none"> 1119 void arch_timing_stop(void);</div><div id="1120" class="line none"> 1120 </div><div id="1121" class="line none"> 1121 /**</div><div id="1122" class="line none"> 1122  * @brief Return timing counter.</div><div id="1123" class="line none"> 1123  *</div><div id="1124" class="line none"> 1124  * @parblock</div><div id="1125" class="line none"> 1125  *</div><div id="1126" class="line none"> 1126  * @note Any call to arch_timing_counter_get() must be done between</div><div id="1127" class="line none"> 1127  * calls to arch_timing_start() and arch_timing_stop(), and on the</div><div id="1128" class="line none"> 1128  * same CPU core.</div><div id="1129" class="line none"> 1129  *</div><div id="1130" class="line none"> 1130  * @endparblock</div><div id="1131" class="line none"> 1131  *</div><div id="1132" class="line none"> 1132  * @parblock</div><div id="1133" class="line none"> 1133  *</div><div id="1134" class="line none"> 1134  * @note Not all architectures have a timing counter with 64 bit precision.</div><div id="1135" class="line none"> 1135  * It is possible to see this value "go backwards" due to internal</div><div id="1136" class="line none"> 1136  * rollover.  Timing code must be prepared to address the rollover</div><div id="1137" class="line none"> 1137  * (with platform-dependent code, e.g. by casting to a uint32_t before</div><div id="1138" class="line none"> 1138  * subtraction) or by using arch_timing_cycles_get() which is required</div><div id="1139" class="line none"> 1139  * to understand the distinction.</div><div id="1140" class="line none"> 1140  *</div><div id="1141" class="line none"> 1141  * @endparblock</div><div id="1142" class="line none"> 1142  *</div><div id="1143" class="line none"> 1143  * @return Timing counter.</div><div id="1144" class="line none"> 1144  *</div><div id="1145" class="line none"> 1145  * @see timing_counter_get()</div><div id="1146" class="line none"> 1146  */</div><div id="1147" class="line none"> 1147 timing_t arch_timing_counter_get(void);</div><div id="1148" class="line none"> 1148 </div><div id="1149" class="line none"> 1149 /**</div><div id="1150" class="line none"> 1150  * @brief Get number of cycles between @p start and @p end.</div><div id="1151" class="line none"> 1151  *</div><div id="1152" class="line none"> 1152  * @note For some architectures, the raw numbers from counter need</div><div id="1153" class="line none"> 1153  * to be scaled to obtain actual number of cycles, or may roll over</div><div id="1154" class="line none"> 1154  * internally.  This function computes a positive-definite interval</div><div id="1155" class="line none"> 1155  * between two returned cycle values.</div><div id="1156" class="line none"> 1156  *</div><div id="1157" class="line none"> 1157  * @param start Pointer to counter at start of a measured execution.</div><div id="1158" class="line none"> 1158  * @param end Pointer to counter at stop of a measured execution.</div><div id="1159" class="line none"> 1159  * @return Number of cycles between start and end.</div><div id="1160" class="line none"> 1160  *</div><div id="1161" class="line none"> 1161  * @see timing_cycles_get()</div><div id="1162" class="line none"> 1162  */</div><div id="1163" class="line none"> 1163 uint64_t arch_timing_cycles_get(volatile timing_t *const <a href="../kernel/thread.h.html#158">start</a>,</div><div id="1164" class="line none"> 1164                                 volatile timing_t *const <a href="../../../subsys/net/lib/mqtt/mqtt_internal.h.html#130">end</a>);</div><div id="1165" class="line none"> 1165 </div><div id="1166" class="line none"> 1166 /**</div><div id="1167" class="line none"> 1167  * @brief Get frequency of counter used (in Hz).</div><div id="1168" class="line none"> 1168  *</div><div id="1169" class="line none"> 1169  * @return Frequency of counter used for timing in Hz.</div><div id="1170" class="line none"> 1170  *</div><div id="1171" class="line none"> 1171  * @see timing_freq_get()</div><div id="1172" class="line none"> 1172  */</div><div id="1173" class="line none"> 1173 uint64_t arch_timing_freq_get(void);</div><div id="1174" class="line none"> 1174 </div><div id="1175" class="line none"> 1175 /**</div><div id="1176" class="line none"> 1176  * @brief Convert number of @p cycles into nanoseconds.</div><div id="1177" class="line none"> 1177  *</div><div id="1178" class="line none"> 1178  * @param cycles Number of cycles</div><div id="1179" class="line none"> 1179  * @return Converted time value</div><div id="1180" class="line none"> 1180  *</div><div id="1181" class="line none"> 1181  * @see timing_cycles_to_ns()</div><div id="1182" class="line none"> 1182  */</div><div id="1183" class="line none"> 1183 uint64_t arch_timing_cycles_to_ns(uint64_t cycles);</div><div id="1184" class="line none"> 1184 </div><div id="1185" class="line none"> 1185 /**</div><div id="1186" class="line none"> 1186  * @brief Convert number of @p cycles into nanoseconds with averaging.</div><div id="1187" class="line none"> 1187  *</div><div id="1188" class="line none"> 1188  * @param cycles Number of cycles</div><div id="1189" class="line none"> 1189  * @param count Times of accumulated cycles to average over</div><div id="1190" class="line none"> 1190  * @return Converted time value</div><div id="1191" class="line none"> 1191  *</div><div id="1192" class="line none"> 1192  * @see timing_cycles_to_ns_avg()</div><div id="1193" class="line none"> 1193  */</div><div id="1194" class="line none"> 1194 uint64_t arch_timing_cycles_to_ns_avg(uint64_t cycles, uint32_t <a href="../kernel.h.html#3113">count</a>);</div><div id="1195" class="line none"> 1195 </div><div id="1196" class="line none"> 1196 /**</div><div id="1197" class="line none"> 1197  * @brief Get frequency of counter used (in MHz).</div><div id="1198" class="line none"> 1198  *</div><div id="1199" class="line none"> 1199  * @return Frequency of counter used for timing in MHz.</div><div id="1200" class="line none"> 1200  *</div><div id="1201" class="line none"> 1201  * @see timing_freq_get_mhz()</div><div id="1202" class="line none"> 1202  */</div><div id="1203" class="line none"> 1203 uint32_t arch_timing_freq_get_mhz(void);</div><div id="1204" class="line none"> 1204 </div><div id="1205" class="line none"> 1205 /** @} */</div><div id="1206" class="line none"> 1206 </div><div id="1207" class="line none"> 1207 #endif /* CONFIG_TIMING_FUNCTIONS */</div><div id="1208" class="line none"> 1208 </div><div id="1209" class="line none"> 1209 #ifdef CONFIG_PCIE_MSI_MULTI_VECTOR</div><div id="1210" class="line none"> 1210 </div><div id="1211" class="line none"> 1211 struct msi_vector;</div><div id="1212" class="line none"> 1212 typedef struct msi_vector <a href="arch_interface.h.html#1212">msi_vector_t</a>;</div><div id="1213" class="line none"> 1213 </div><div id="1214" class="line none"> 1214 /**</div><div id="1215" class="line none"> 1215  * @brief Allocate vector(s) for the endpoint MSI message(s).</div><div id="1216" class="line none"> 1216  *</div><div id="1217" class="line none"> 1217  * @param priority the MSI vectors base interrupt priority</div><div id="1218" class="line none"> 1218  * @param vectors an array to fill with allocated MSI vectors</div><div id="1219" class="line none"> 1219  * @param n_vector the size of MSI vectors array</div><div id="1220" class="line none"> 1220  *</div><div id="1221" class="line none"> 1221  * @return The number of allocated MSI vectors</div><div id="1222" class="line none"> 1222  */</div><div id="1223" class="line none"> 1223 uint8_t arch_pcie_msi_vectors_allocate(unsigned int priority,</div><div id="1224" class="line none"> 1224                                        <a href="arch_interface.h.html#1212">msi_vector_t</a> *vectors,</div><div id="1225" class="line none"> 1225                                        uint8_t n_vector);</div><div id="1226" class="line none"> 1226 </div><div id="1227" class="line none"> 1227 /**</div><div id="1228" class="line none"> 1228  * @brief Connect an MSI vector to the given routine</div><div id="1229" class="line none"> 1229  *</div><div id="1230" class="line none"> 1230  * @param vector The MSI vector to connect to</div><div id="1231" class="line none"> 1231  * @param routine Interrupt service routine</div><div id="1232" class="line none"> 1232  * @param parameter ISR parameter</div><div id="1233" class="line none"> 1233  * @param flags Arch-specific IRQ configuration flag</div><div id="1234" class="line none"> 1234  *</div><div id="1235" class="line none"> 1235  * @return True on success, false otherwise</div><div id="1236" class="line none"> 1236  */</div><div id="1237" class="line none"> 1237 bool arch_pcie_msi_vector_connect(<a href="arch_interface.h.html#1212">msi_vector_t</a> *vector,</div><div id="1238" class="line none"> 1238                                   void (*routine)(const void *parameter),</div><div id="1239" class="line none"> 1239                                   const void *parameter,</div><div id="1240" class="line none"> 1240                                   uint32_t <a href="../kernel.h.html#2764">flags</a>);</div><div id="1241" class="line none"> 1241 </div><div id="1242" class="line none"> 1242 #endif /* CONFIG_PCIE_MSI_MULTI_VECTOR */</div><div id="1243" class="line none"> 1243 </div><div id="1244" class="line none"> 1244 /**</div><div id="1245" class="line none"> 1245  * @brief Perform architecture specific processing within spin loops</div><div id="1246" class="line none"> 1246  *</div><div id="1247" class="line none"> 1247  * This is invoked from busy loops with IRQs disabled such as the contended</div><div id="1248" class="line none"> 1248  * spinlock loop. The default implementation is a weak function that calls</div><div id="1249" class="line none"> 1249  * arch_nop(). Architectures may implement this function to perform extra</div><div id="1250" class="line none"> 1250  * checks or power management tricks if needed.</div><div id="1251" class="line none"> 1251  */</div><div id="1252" class="line none"> 1252 void arch_spin_relax(void);</div><div id="1253" class="line none"> 1253 </div><div id="1254" class="line none"> 1254 /**</div><div id="1255" class="line none"> 1255  * stack_trace_callback_fn - Callback for @ref arch_stack_walk</div><div id="1256" class="line none"> 1256  * @param cookie Caller supplied pointer handed back by @ref arch_stack_walk</div><div id="1257" class="line none"> 1257  * @param addr The stack entry address to consume</div><div id="1258" class="line none"> 1258  *</div><div id="1259" class="line none"> 1259  * @return True, if the entry was consumed or skipped. False, if there is no space left to store</div><div id="1260" class="line none"> 1260  */</div><div id="1261" class="line none"> 1261 typedef bool (*<a href="arch_interface.h.html#1261">stack_trace_callback_fn</a>)(void *cookie, unsigned long <a href="../kernel/thread.h.html#178">addr</a>);</div><div id="1262" class="line none"> 1262 </div><div id="1263" class="line none"> 1263 /**</div><div id="1264" class="line none"> 1264  * @brief Architecture-specific function to walk the stack</div><div id="1265" class="line none"> 1265  *</div><div id="1266" class="line none"> 1266  * @param callback_fn Callback which is invoked by the architecture code for each entry.</div><div id="1267" class="line none"> 1267  * @param cookie Caller supplied pointer which is handed back to @a callback_fn</div><div id="1268" class="line none"> 1268  * @param thread Pointer to a k_thread struct, can be NULL</div><div id="1269" class="line none"> 1269  * @param esf Pointer to an arch_esf struct, can be NULL</div><div id="1270" class="line none"> 1270  *</div><div id="1271" class="line none"> 1271  * ============ ======= ============================================</div><div id="1272" class="line none"> 1272  * thread       esf</div><div id="1273" class="line none"> 1273  * ============ ======= ============================================</div><div id="1274" class="line none"> 1274  * thread       NULL    Stack trace from thread (can be _current)</div><div id="1275" class="line none"> 1275  * thread       esf     Stack trace starting on esf</div><div id="1276" class="line none"> 1276  * ============ ======= ============================================</div><div id="1277" class="line none"> 1277  */</div><div id="1278" class="line none"> 1278 void arch_stack_walk(<a href="arch_interface.h.html#1261">stack_trace_callback_fn</a> callback_fn, void *cookie,</div><div id="1279" class="line none"> 1279                      const struct <a href="arch_interface.h.html#43">k_thread</a> *<a href="../kernel.h.html#4031">thread</a>, const struct arch_esf *esf);</div><div id="1280" class="line none"> 1280 </div><div id="1281" class="line none"> 1281 #ifdef __cplusplus</div><div id="1282" class="line none"> 1282 }</div><div id="1283" class="line none"> 1283 #endif /* __cplusplus */</div><div id="1284" class="line none"> 1284 </div><div id="1285" class="line none"> 1285 #include &lt;zephyr/<a href="../kernel/thread.h.html#376">arch</a>/arch_inlines.h&gt;</div><div id="1286" class="line none"> 1286 </div><div id="1287" class="line none"> 1287 #endif /* _ASMLANGUAGE */</div><div id="1288" class="line none"> 1288 </div><div id="1289" class="line none"> 1289 #endif /* ZEPHYR_INCLUDE_ARCH_ARCH_INTERFACE_H_ */</div>
</div>
</body>
</html>
