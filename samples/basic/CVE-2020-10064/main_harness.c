#include <ieee802154_frame.c>

uint16_t nondet_uint16_t();
uint16_t nondet_uint16_t();

static bool validate_mac_command(struct ieee802154_mpdu *mpdu, uint8_t *buf, uint8_t length)
{
	return true;
}

void harness()
{

	// size_t buf_size;
	// __CPROVER_assume(buf_size > 0 && buf_size <= IEEE802154_MTU);
	// uint8_t *buf = malloc(buf_size);
	// __CPROVER_assume(buf != NULL);

	struct net_pkt pkt;
	__CPROVER_assume(&pkt != NULL);
	uint8_t *buf = (uint8_t *)&pkt;

	uint8_t length = sizeof(struct net_pkt);
	__CPROVER_assume(length > 0);

	struct ieee802154_mpdu mpdu;

	bool result = ieee802154_validate_frame(buf, length, &mpdu);

	// __CPROVER_assume(mpdu.payload != NULL);
	__CPROVER_assume(mpdu.mhr.fs != NULL);
	__CPROVER_assume(&(mpdu.mhr.fs->fc) != NULL);
	__CPROVER_assume(mpdu.payload_length > 0 &&
			 mpdu.mhr.fs->fc.frame_type == IEEE802154_FRAME_TYPE_MAC_COMMAND);
	__CPROVER_assume(mpdu.payload != NULL);
	__CPROVER_assert(mpdu.payload_length > length, "ERROR: Buffer underflow");
}

int main(void)
{
	harness();
	return 0;
}
